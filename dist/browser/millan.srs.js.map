{"version":3,"sources":["webpack://millan.[name]/webpack/universalModuleDefinition","webpack://millan.[name]/webpack/bootstrap","webpack://millan.[name]/./src/turtle/TurtleParser.ts","webpack://millan.[name]/./src/sparql/StardogSparqlParser.ts","webpack://millan.[name]/./src/sparql/W3SpecSparqlParser.ts","webpack://millan.[name]/./src/sparql/index.ts","webpack://millan.[name]/./src/srs/tokens.ts","webpack://millan.[name]/./src/srs/visitor.ts","webpack://millan.[name]/./src/turtle/defaultNamespaces.ts","webpack://millan.[name]/./src/srs/customErrors.ts","webpack://millan.[name]/./src/srs/SrsParser.ts","webpack://millan.[name]/./src/srs/index.ts","webpack://millan.[name]/./src/sparql/BaseSparqlParser.ts","webpack://millan.[name]/./src/helpers/cst.ts","webpack://millan.[name]/./src/helpers/unescape.ts","webpack://millan.[name]/./src/turtle/tokens.ts"],"names":["root","factory","exports","module","define","amd","self","this","webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","6","5","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","oldJsonpFunction","slice","__webpack_exports__","TurtleParser","extendStatics","chevrotain__WEBPACK_IMPORTED_MODULE_0__","__extends","b","setPrototypeOf","__proto__","Array","__","constructor","__assign","assign","arguments","_a","turtleTokenTypes","turtleTokenMap","_super","config","tokens","lexerDefinition","performSelfAnalysis","_this","outputCst","recoveryEnabled","namespacesMap","semanticErrors","resetManagedState","tokenize","document","lexer","parse","input","cst","turtleDoc","errors","RULE","allowEdgeProperties","MANY","SUBRULE","statement","ARGS","OR","ALT","directive","triples","CONSUME","Period","prefixID","base","sparqlPrefix","sparqlBase","TTL_PREFIX","pnameNsToken","PNAME_NS","iriToken","IRIREF","pnameImageWithoutColon","image","iriImage","TTL_BASE","BASE","PREFIX","subject","SUBRULE1","predicateObjectList","GATE","Boolean","EmbeddedTriplePattern","blankNodePropertyList","OPTION","SUBRULE2","LEmbed","REmbed","verb","objectList","EmbeddedPredicateObjectList","Semicolon","OR1","LCurly","RCurly","iri","BlankNode","collection","predicate","Comma","A","literal","RDFLiteral","NumericLiteral","BooleanLiteral","LBracket","RBracket","LParen","RParen","INTEGER","DECIMAL","DOUBLE","String","LANGTAG","DoubleCaret","TRUE","FALSE","STRING_LITERAL_QUOTE","STRING_LITERAL_SINGLE_QUOTE","STRING_LITERAL_LONG_SINGLE_QUOTE","STRING_LITERAL_LONG_QUOTE","PrefixedName","prefixedNameToken","PNAME_LN","indexOf","message","token","context","ruleStack","getHumanReadableRuleStack","ruleOccurrenceStack","RULE_OCCURRENCE_STACK","resyncedTokens","BLANK_NODE_LABEL","ANON","StardogSparqlParser","_BaseSparqlParser__WEBPACK_IMPORTED_MODULE_0__","chevrotain__WEBPACK_IMPORTED_MODULE_1__","sparqlTokenMap","stardogSparqlTokens","options","Query","OVERRIDE_RULE","SelectQuery","ConstructQuery","DescribeQuery","AskQuery","PathQuery","ValuesClause","PathSpec","DatasetClause","START","PathTerminal","END","Via","MaxLength","SolutionModifier","VIA","GroupGraphPattern","Var","Path","Equals","Constant","PATHS","PATHS_SHORTEST","PATHS_ALL","OPTION1","CYCLIC","GraphPatternNotTriples","GroupOrUnionGraphPattern","OptionalGraphPattern","MinusGraphPattern","GraphGraphPattern","ServiceGraphPattern","Filter","Bind","Unnest","InlineData","TriplesSameSubject","VarOrTerm","PropertyListNotEmpty","TriplesNode","PropertyList","disallowEdgeProperties","Verb","ObjectList","EmbeddedPropertyList","GraphNode","TriplesSameSubjectPath","PropertyListPathNotEmpty","TriplesNodePath","PropertyListPath","VerbPath","VerbSimple","ObjectListPath","EmbeddedPropertyListPath","ObjectPath","OR2","OR3","GraphNodePath","VarOrTermOrEmbeddedTriplePattern","VarOrBlankNodeOrIriOrLit","GraphTerm","BIND","ExpressionOrEmbeddedTriplePattern","AS","Expression","UNNEST","BuiltInCall","Aggregate","BuiltInCall_STR","BuiltInCall_LANG","BuiltInCall_LANGMATCHES","BuiltInCall_DATATYPE","BuiltInCall_BOUND","BuiltInCall_IRI","BuiltInCall_URI","BuiltInCall_BNODE","BuiltInCall_RAND","BuiltInCall_ABS","BuiltInCall_CEIL","BuiltInCall_FLOOR","BuiltInCall_ROUND","BuiltInCall_CONCAT","SubstringExpression","BuiltInCall_STRLEN","StrReplaceExpression","BuiltInCall_UCASE","BuiltInCall_LCASE","BuiltInCall_ENCODE_FOR_URI","BuiltInCall_CONTAINS","BuiltInCall_STRSTARTS","BuiltInCall_STRENDS","BuiltInCall_STRBEFORE","BuiltInCall_STRAFTER","BuiltInCall_YEAR","BuiltInCall_MONTH","BuiltInCall_DAY","BuiltInCall_HOURS","BuiltInCall_MINUTES","BuiltInCall_SECONDS","BuiltInCall_TIMEZONE","BuiltInCall_TZ","BuiltInCall_NOW","BuiltInCall_UUID","BuiltInCall_STRUUID","BuiltInCall_MD5","BuiltInCall_SHA1","BuiltInCall_SHA256","BuiltInCall_SHA384","BuiltInCall_SHA512","BuiltInCall_COALESCE","BuiltInCall_IF","BuiltInCall_STRLANG","BuiltInCall_STRDT","BuiltInCall_sameTerm","BuiltInCall_isIRI","BuiltInCall_isURI","BuiltInCall_isBLANK","BuiltInCall_isLITERAL","BuiltInCall_isNUMERIC","RegexExpression","ExistsFunction","NotExistsFunction","StardogOrCustomFunction","Unknown","ExpressionList","ConstructTemplate","Quads","baseTokens","W3SpecSparqlParser_W3SpecSparqlParser","W3SpecSparqlParser","api","BaseSparqlParser","sparqlTokens","keywords","terminals","multiModeLexerDefinition","srsTokenMap","srsTokenTypes","LexerMode","_helpers_matchers__WEBPACK_IMPORTED_MODULE_1__","_b","Rule","pattern","If","push_mode","IFCLAUSE","Then","THENCLAUSE","EndThen","pop_mode","text","startOffset","cursor","unclosedBraceCount","exec","line_breaks","TriplesBlock","indexOfIriRef","modes","TURTLE","concat","WhiteSpace","defaultMode","defaultNamespacesMap","freeze","reduce","prefix","getSparqlSrsVisitor","BaseVisitor","SparqlSrsVisitor","groupGraphPatterns","triplesBlocks","IfClause","ctx","cstInputTokens","$storePlaceholderTokenReplacement","tokenStore","originalTokenContext","subParserRule","sparqlParser","parseGroupGraphPattern","ThenClause","parseTriplesBlock","stripWrappers","originalToken","replacement","$getPlaceholderTokenReplacement","parseResult","frontPadding","latestEndOffset","latestEndLine","linesBetweenTokens","startLine","untokenizedSpaceBetweenTokens","repeat","Math","max","split","forEach","line","idx","endOffset","endLine","parseImage","$getGroupGraphPatterns","$getTriplesBlocks","$resetState","sparql","validateVisitor","reduceVisitorItemErrors","acc","item","findAndSwapPlaceholders","node","parentNode","visitorItems","matchingVisitorItem","find","visitorItem","children","customErrors_a","subExpressionMatcher","defaultEarlyAbortTest","disallowedSparqlTokenNameToRuleMap","EXISTS","tokenName","NOT_EXISTS","NOW","disallowedSparqlTokenNames","keys","disallowedSparqlLiteralTokenNames","DOUBLE_POSITIVE","DECIMAL_POSITIVE","INTEGER_POSITIVE","DOUBLE_NEGATIVE","DECIMAL_NEGATIVE","INTEGER_NEGATIVE","STRING_LITERAL1","STRING_LITERAL2","STRING_LITERAL_LONG1","STRING_LITERAL_LONG2","map","isCstNodeTraverseContext","getCustomErrorRuleStack","traverseCtx","fullCtx","startRuleNames","topLevelSubParserRuleName","earlyAbortTest","stackUnwindingPointer","helpers_cst","includes","parentCtx","unshift","getCustomIRecognitionException","getNoPrefixError","subParserRuleName","getDisallowedTokenError","tokenType","getDisallowedLiteralError","foundPropertyListPathNotEmptyCtx","didFindSubExpressionWithMultipleChildren","errorContext","errorRuleStack","stackCtx","nodeName","test","isExpression","isTriplesBlock","isBoundExpressionWithLiteralSubject","parentNodeName","isParentBindOrBoundExpressionOrEmbeddedTriplePattern","isTriplesBlockSubject","SrsParser_extends","SrsParser_assign","SrsParser_a","SrsParser_SrsParser","SrsParser","baseNamespacesMap","visitCst","sparqlSrsVisitor","BaseSrsVisitor","getBaseCstVisitorConstructorWithDefaults","visit","getSparqlRulesFromVisitor","setBaseNamespaces","newBaseNamespaces","SrsDoc","next","currentTokenName","some","error","addIfClauseErrorsToErrors","addThenClauseErrorsToErrors","RuleDoc","MANY1","RuleClause","srsTokens","log","args","_i","tokenVocab","entryRule","SparqlDoc","Prologue","QueryUnit","UpdateUnit","MAX_LENGTH","Update","AT_LEAST_ONE","BaseDecl","PrefixDecl","SelectClause","WhereClause","SubSelect","SELECT","DISTINCT","REDUCED","Star","CONSTRUCT","WHERE","TriplesTemplate","DESCRIBE","VarOrIri","ASK","FROM","DefaultGraphClause","NamedGraphClause","SourceSelector","NAMED","GroupClause","HavingClause","OPTION2","OrderClause","OPTION3","LimitOffsetClause","GROUP_BY","GroupCondition","FunctionCall","HAVING","HavingCondition","Constraint","ORDER_BY","OrderCondition","ASC","DESC","BrackettedExpression","LimitClause","OffsetClause","OFFSET","LIMIT","VALUES","DataBlock","Update1","Load","Clear","Drop","Add","Move","Copy","Create","InsertData","DeleteData","DeleteWhere","Modify","LOAD","SILENT","INTO","GraphRef","CLEAR","GraphRefAll","DROP","CREATE","ADD","GraphOrDefault","TO","MOVE","COPY","INSERT_DATA","QuadData","DELETE_DATA","DELETE_WHERE","QuadPattern","WITH","DeleteClause","InsertClause","UsingClause","DELETE","INSERT","USING","DEFAULT","GRAPH","ALL","QuadsNotTriples","GroupGraphPatternSub","OPTIONAL","SERVICE","InlineDataOneVar","InlineDataFull","DataBlockValue","NIL","CONSUME1","MANY2","UNDEF","MINUS","UNION","FILTER","ArgList","ConstructTriples","AT_LEAST_ONE_SEP","SEP","DEF","PathAlternative","Pipe","PathSequence","ForwardSlash","PathEltOrInverse","PathElt","PathPrimary","PathMod","Caret","QuestionMark","Plus","Bang","PathNegatedPropertySet","PathOneInPropertySet","MANY_SEP","Integer","Collection","BlankNodePropertyList","CollectionPath","BlankNodePropertyListPath","VAR1","VAR2","ConditionalOrExpression","LogicalOr","ConditionalAndExpression","LogicalAnd","ValueLogical","RelationalExpression","NumericExpression","NotEquals","LessThan","GreaterThan","LessThanEquals","GreaterThanEquals","IN","NOT_IN","AdditiveExpression","MultiplicativeExpression","Minus","NumericLiteralPositive","NumericLiteralNegative","OR4","UnaryExpression","PrimaryExpression","SUBRULE3","iriOrFunction","STR","LANG","LANGMATCHES","DATATYPE","BOUND","IRI","URI","BNODE","RAND","ABS","CEIL","FLOOR","ROUND","CONCAT","STRLEN","UCASE","LCASE","ENCODE_FOR_URI","CONTAINS","STRSTARTS","STRENDS","STRBEFORE","STRAFTER","YEAR","MONTH","DAY","HOURS","MINUTES","SECONDS","TIMEZONE","TZ","UUID","STRUUID","MD5","SHA1","SHA256","SHA384","SHA512","COALESCE","IF","STRLANG","STRDT","sameTerm","isIRI","isURI","isBLANK","isLITERAL","isNUMERIC","REGEX","SUBSTR","REPLACE","CONSUME2","Count","COUNT","CONSUME3","Sum","SUM","Min","MIN","Max","MAX","Avg","AVG","Sample","SAMPLE","GroupConcat","GROUP_CONCAT","SEPARATOR","NumericLiteralUnsigned","traverse","unsafeTraverse","isCstNode","_traverse","TraverseContext","visitSafely","childType","child","childCtx","transformedCtx","nextCtx","escapeSequence","escapeReplacements","\\","'","\"","f","_","~",".","-","!","$","&","(",")","*","+",",",";","=","/","?","#","@","%","unescapedStringLiteralQuote","unescapedStringLiteralSingleQuote","stringLiteralQuote","stringLiteralSingleQuote","stringLiteralLongQuote","stringLiteralLongSingleQuote","illegalIriChars","escapedIri","unescapedIri","unescape_unescape","replace","unicode4","unicode8","escapedChar","fromCharCode","parseInt","charCode","Error","unicodeRegexp","Comment","group","regex","and","option","or","matchers","EXPONENT","ECHAR","PLX","PERCENT","HEX","match","textToMatch","UCHAR","PN_CHARS_BASE","PN_CHARS_U","PN_CHARS","PN_PREFIX","PN_LOCAL","PN_LOCAL_ESC"],"mappings":"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","file":"millan.srs.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"srs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"srs\"] = factory();\n\telse\n\t\troot[\"millan\"] = root[\"millan\"] || {}, root[\"millan\"][\"srs\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t6: 0,\n \t\t5: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = (typeof self !== 'undefined' ? self : this)[\"webpackJsonp\"] = (typeof self !== 'undefined' ? self : this)[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([65,0,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar _a = require('./tokens'), turtleTokenTypes = _a.turtleTokenTypes, turtleTokenMap = _a.turtleTokenMap;\nimport { Parser, Lexer, } from 'chevrotain';\nvar TurtleParser = /** @class */ (function (_super) {\n    __extends(TurtleParser, _super);\n    function TurtleParser(config, tokens, lexerDefinition, performSelfAnalysis) {\n        if (config === void 0) { config = {}; }\n        if (tokens === void 0) { tokens = turtleTokenTypes; }\n        if (lexerDefinition === void 0) { lexerDefinition = tokens; }\n        if (performSelfAnalysis === void 0) { performSelfAnalysis = true; }\n        var _this = _super.call(this, tokens, __assign({ outputCst: true, recoveryEnabled: true }, config)) || this;\n        // Parsing Turtle requires that the parser keep a map of namespaces in state.\n        // Empty prefixes, for example, are allowed only if the empty prefix has been\n        // added to the namespaces map (for now, that's all this tracks). (TODO: We\n        // might want to use a visitor for this, but I'm doing it quick-and-dirty for\n        // now.)\n        // See here: https://www.w3.org/TR/turtle/#handle-PNAME_LN\n        _this.namespacesMap = {};\n        _this.semanticErrors = [];\n        // Clears the state that we have to manage on our own for each parse (see\n        // above for details).\n        _this.resetManagedState = function () {\n            _this.namespacesMap = {};\n            _this.semanticErrors = [];\n        };\n        _this.tokenize = function (document) {\n            return _this.lexer.tokenize(document).tokens;\n        };\n        // NOTE: This parser can parse in two modes, 'standard' and 'stardog'. The\n        // latter includes non-standard features like embedded triples patterns (edge\n        // properties).\n        _this.parse = function (document, mode) {\n            if (mode === void 0) { mode = 'standard'; }\n            _this.input = _this.lexer.tokenize(document).tokens;\n            var cst = _this.turtleDoc(0, [mode]);\n            // Next two items are copied so that they can be returned/held after parse\n            // state is cleared.\n            var errors = _this.errors.slice();\n            var semanticErrors = _this.semanticErrors.slice();\n            _this.resetManagedState();\n            return {\n                errors: errors,\n                semanticErrors: semanticErrors,\n                cst: cst,\n            };\n        };\n        _this.turtleDoc = _this.RULE('turtleDoc', function (mode) {\n            var allowEdgeProperties = mode === 'stardog';\n            _this.MANY(function () {\n                return _this.SUBRULE(_this.statement, { ARGS: [allowEdgeProperties] });\n            });\n        });\n        _this.statement = _this.RULE('statement', function (allowEdgeProperties) {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.directive); } },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.triples, { ARGS: [allowEdgeProperties] });\n                        _this.CONSUME(turtleTokenMap.Period);\n                    },\n                },\n            ]);\n        });\n        _this.directive = _this.RULE('directive', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.prefixID); } },\n                { ALT: function () { return _this.SUBRULE(_this.base); } },\n                { ALT: function () { return _this.SUBRULE(_this.sparqlPrefix); } },\n                { ALT: function () { return _this.SUBRULE(_this.sparqlBase); } },\n            ]);\n        });\n        _this.prefixID = _this.RULE('prefixID', function () {\n            _this.CONSUME(turtleTokenMap.TTL_PREFIX);\n            var pnameNsToken = _this.CONSUME(turtleTokenMap.PNAME_NS);\n            var iriToken = _this.CONSUME(turtleTokenMap.IRIREF);\n            var pnameImageWithoutColon = pnameNsToken.image.slice(0, -1);\n            var iriImage = iriToken.image;\n            _this.namespacesMap[pnameImageWithoutColon] = iriImage;\n            _this.CONSUME(turtleTokenMap.Period);\n        });\n        _this.base = _this.RULE('base', function () {\n            _this.CONSUME(turtleTokenMap.TTL_BASE);\n            _this.CONSUME(turtleTokenMap.IRIREF);\n            _this.CONSUME(turtleTokenMap.Period);\n        });\n        _this.sparqlBase = _this.RULE('sparqlBase', function () {\n            _this.CONSUME(turtleTokenMap.BASE);\n            _this.CONSUME(turtleTokenMap.IRIREF);\n        });\n        _this.sparqlPrefix = _this.RULE('sparqlPrefix', function () {\n            _this.CONSUME(turtleTokenMap.PREFIX);\n            var pnameNsToken = _this.CONSUME(turtleTokenMap.PNAME_NS);\n            var iriToken = _this.CONSUME(turtleTokenMap.IRIREF);\n            var pnameImageWithoutColon = pnameNsToken.image.slice(0, -1);\n            var iriImage = iriToken.image;\n            _this.namespacesMap[pnameImageWithoutColon] = iriImage;\n        });\n        // NOTE: Not part of Turtle spec. Part of Stardog's support for edge\n        // properties/embedded triples/a subset of RDF*.\n        // ALSO NOTE: Intentionally does not conform to the RDF* spec.\n        // Stardog does not allow nesting of embedded triples.\n        _this.triples = _this.RULE('triples', function (allowEdgeProperties) {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.subject);\n                        _this.SUBRULE1(_this.predicateObjectList, {\n                            ARGS: [allowEdgeProperties],\n                        });\n                    },\n                },\n                {\n                    GATE: function () { return Boolean(allowEdgeProperties); },\n                    ALT: function () {\n                        _this.SUBRULE(_this.EmbeddedTriplePattern);\n                        _this.SUBRULE(_this.predicateObjectList);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.blankNodePropertyList, {\n                            ARGS: [allowEdgeProperties],\n                        });\n                        _this.OPTION(function () {\n                            return _this.SUBRULE2(_this.predicateObjectList, {\n                                ARGS: [allowEdgeProperties],\n                            });\n                        });\n                    },\n                },\n            ]);\n        });\n        // NOTE: Not part of Turtle spec. Part of Stardog's support for edge\n        // properties/embedded triples/a subset of RDF*.\n        // ALSO NOTE: Intentionally does not conform to the RDF* spec.\n        // Stardog does not allow nesting of embedded triples.\n        _this.EmbeddedTriplePattern = _this.RULE('EmbeddedTriplePattern', function () {\n            _this.CONSUME(turtleTokenMap.LEmbed);\n            _this.SUBRULE(_this.triples);\n            _this.CONSUME(turtleTokenMap.REmbed);\n        });\n        // NOTE: Not part of Turtle spec. Part of Stardog's support for edge\n        // properties/embedded triples/a subset of RDF*.\n        // ALSO NOTE: Intentionally does not conform to the RDF* spec.\n        // Stardog does not allow embedded triples with object lists.\n        _this.predicateObjectList = _this.RULE('predicateObjectList', function (allowEdgeProperties) {\n            _this.SUBRULE(_this.verb);\n            _this.OR([\n                {\n                    ALT: function () {\n                        return _this.SUBRULE(_this.objectList, { ARGS: [allowEdgeProperties] });\n                    },\n                },\n                {\n                    GATE: function () { return Boolean(allowEdgeProperties); },\n                    ALT: function () {\n                        _this.SUBRULE(_this.EmbeddedPredicateObjectList);\n                        _this.SUBRULE(_this.object, { ARGS: [allowEdgeProperties] });\n                    },\n                },\n            ]);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.SUBRULE1(_this.verb);\n                    _this.OR1([\n                        {\n                            ALT: function () {\n                                return _this.SUBRULE1(_this.objectList, { ARGS: [allowEdgeProperties] });\n                            },\n                        },\n                        {\n                            GATE: function () { return Boolean(allowEdgeProperties); },\n                            ALT: function () {\n                                _this.SUBRULE1(_this.EmbeddedPredicateObjectList);\n                                _this.SUBRULE1(_this.object, { ARGS: [allowEdgeProperties] });\n                            },\n                        },\n                    ]);\n                });\n            });\n        });\n        // NOTE: Not part of Turtle spec. Part of Stardog's support for edge\n        // properties/embedded triples/a subset of RDF*.\n        // ALSO NOTE: Intentionally does not conform to the RDF* spec.\n        // Stardog does not allow nesting of embedded triples.\n        _this.EmbeddedPredicateObjectList = _this.RULE('EmbeddedPredicateObjectList', function () {\n            _this.CONSUME(turtleTokenMap.LCurly);\n            _this.SUBRULE(_this.predicateObjectList);\n            _this.CONSUME(turtleTokenMap.RCurly);\n        });\n        _this.subject = _this.RULE('subject', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNode); } },\n                { ALT: function () { return _this.SUBRULE(_this.collection); } },\n            ]);\n        });\n        _this.predicate = _this.RULE('predicate', function () {\n            _this.SUBRULE(_this.iri);\n        });\n        _this.objectList = _this.RULE('objectList', function (allowEdgeProperties) {\n            _this.SUBRULE(_this.object, { ARGS: [allowEdgeProperties] });\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Comma);\n                _this.SUBRULE1(_this.object, { ARGS: [allowEdgeProperties] });\n            });\n        });\n        _this.verb = _this.RULE('verb', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.predicate); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.A); } },\n            ]);\n        });\n        _this.literal = _this.RULE('literal', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.RDFLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.BooleanLiteral); } },\n            ]);\n        });\n        _this.blankNodePropertyList = _this.RULE('blankNodePropertyList', function (allowEdgeProperties) {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.SUBRULE(_this.predicateObjectList, { ARGS: [allowEdgeProperties] });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.object = _this.RULE('object', function (allowEdgeProperties) {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNode); } },\n                { ALT: function () { return _this.SUBRULE(_this.collection); } },\n                {\n                    ALT: function () {\n                        return _this.SUBRULE(_this.blankNodePropertyList, {\n                            ARGS: [allowEdgeProperties],\n                        });\n                    },\n                },\n                { ALT: function () { return _this.SUBRULE(_this.literal); } },\n            ]);\n        });\n        _this.collection = _this.RULE('collection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () { return _this.SUBRULE(_this.object); });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.NumericLiteral = _this.RULE('NumericLiteral', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.INTEGER); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.DECIMAL); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.DOUBLE); } },\n            ]);\n        });\n        _this.RDFLiteral = _this.RULE('RDFLiteral', function () {\n            _this.SUBRULE(_this.String);\n            _this.OPTION(function () {\n                _this.OR([\n                    { ALT: function () { return _this.CONSUME(turtleTokenMap.LANGTAG); } },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(turtleTokenMap.DoubleCaret);\n                            _this.SUBRULE(_this.iri);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.BooleanLiteral = _this.RULE('BooleanLiteral', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.TRUE); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.FALSE); } },\n            ]);\n        });\n        _this.String = _this.RULE('String', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_QUOTE); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_SINGLE_QUOTE); } },\n                {\n                    ALT: function () {\n                        return _this.CONSUME(turtleTokenMap.STRING_LITERAL_LONG_SINGLE_QUOTE);\n                    },\n                },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_LONG_QUOTE); } },\n            ]);\n        });\n        _this.iri = _this.RULE('iri', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.IRIREF); } },\n                { ALT: function () { return _this.SUBRULE(_this.PrefixedName); } },\n            ]);\n        });\n        _this.PrefixedName = _this.RULE('PrefixedName', function () {\n            var prefixedNameToken = _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.PNAME_LN); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.PNAME_NS); } },\n            ]);\n            var pnameNsImage = prefixedNameToken.image.slice(0, prefixedNameToken.image.indexOf(':'));\n            if (!(pnameNsImage in _this.namespacesMap)) {\n                _this.semanticErrors.push({\n                    name: 'NoNamespacePrefixError',\n                    message: 'A prefix was used for which there was no namespace defined.',\n                    token: prefixedNameToken,\n                    context: {\n                        ruleStack: _this.getHumanReadableRuleStack(),\n                        ruleOccurrenceStack: _this.RULE_OCCURRENCE_STACK.slice(),\n                    },\n                    resyncedTokens: [],\n                });\n            }\n        });\n        _this.BlankNode = _this.RULE('BlankNode', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.BLANK_NODE_LABEL); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.ANON); } },\n            ]);\n        });\n        _this.lexer = new Lexer(lexerDefinition);\n        if (performSelfAnalysis) {\n            Parser.performSelfAnalysis(_this);\n        }\n        return _this;\n    }\n    return TurtleParser;\n}(Parser));\nexport { TurtleParser };\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar _a = require('./tokens'), sparqlTokenMap = _a.sparqlTokenMap, stardogSparqlTokens = _a.stardogSparqlTokens;\nimport { BaseSparqlParser } from './BaseSparqlParser';\nimport { Parser } from 'chevrotain';\nvar StardogSparqlParser = /** @class */ (function (_super) {\n    __extends(StardogSparqlParser, _super);\n    function StardogSparqlParser(options) {\n        var _this = _super.call(this, options, stardogSparqlTokens) || this;\n        _this.Query = _this.OVERRIDE_RULE('Query', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.SelectQuery); } },\n                { ALT: function () { return _this.SUBRULE(_this.ConstructQuery); } },\n                { ALT: function () { return _this.SUBRULE(_this.DescribeQuery); } },\n                { ALT: function () { return _this.SUBRULE(_this.AskQuery); } },\n                { ALT: function () { return _this.SUBRULE(_this.PathQuery); } },\n            ]);\n            _this.SUBRULE(_this.ValuesClause);\n        });\n        _this.PathQuery = _this.RULE('PathQuery', function () {\n            _this.SUBRULE(_this.PathSpec);\n            _this.MANY(function () { return _this.SUBRULE(_this.DatasetClause); });\n            _this.CONSUME(sparqlTokenMap.START);\n            _this.SUBRULE(_this.PathTerminal);\n            _this.CONSUME(sparqlTokenMap.END);\n            _this.SUBRULE1(_this.PathTerminal);\n            _this.SUBRULE(_this.Via);\n            _this.OPTION(function () { return _this.SUBRULE(_this.MaxLength); });\n            _this.SUBRULE(_this.SolutionModifier);\n        });\n        _this.Via = _this.RULE('Via', function () {\n            _this.CONSUME(sparqlTokenMap.VIA);\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.GroupGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.Var); } },\n                { ALT: function () { return _this.SUBRULE(_this.Path); } },\n            ]);\n        });\n        _this.PathTerminal = _this.RULE('PathTerminal', function () {\n            _this.SUBRULE(_this.Var);\n            _this.OPTION(function () {\n                _this.OR([\n                    {\n                        ALT: function () {\n                            _this.CONSUME(sparqlTokenMap.Equals);\n                            _this.SUBRULE(_this.Constant);\n                        },\n                    },\n                    { ALT: function () { return _this.SUBRULE(_this.GroupGraphPattern); } },\n                ]);\n            });\n        });\n        _this.PathSpec = _this.RULE('PathSpec', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.PATHS); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.PATHS_SHORTEST); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.PATHS_ALL); } },\n            ]);\n            _this.OPTION1(function () { return _this.CONSUME(sparqlTokenMap.CYCLIC); });\n        });\n        _this.GraphPatternNotTriples = _this.OVERRIDE_RULE('GraphPatternNotTriples', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.GroupOrUnionGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.OptionalGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.MinusGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.GraphGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.ServiceGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.Filter); } },\n                { ALT: function () { return _this.SUBRULE(_this.Bind); } },\n                { ALT: function () { return _this.SUBRULE(_this.Unnest); } },\n                { ALT: function () { return _this.SUBRULE(_this.InlineData); } },\n            ]);\n        });\n        _this.TriplesSameSubject = _this.OVERRIDE_RULE('TriplesSameSubject', function () {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.VarOrTerm);\n                        _this.SUBRULE(_this.PropertyListNotEmpty);\n                    },\n                },\n                {\n                    ALT: function () {\n                        // NOTE: Intentionally does not conform to the SPARQL* spec.\n                        // Stardog does not allow nesting of embedded triples.\n                        _this.SUBRULE(_this.EmbeddedTriplePattern);\n                        _this.SUBRULE1(_this.PropertyListNotEmpty, { ARGS: [true] });\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.TriplesNode);\n                        _this.SUBRULE(_this.PropertyList);\n                    },\n                },\n            ]);\n        });\n        // NOTE: Intentionally does not conform to the SPARQL* spec.\n        // Stardog does not allow embedded triples with object lists.\n        _this.PropertyListNotEmpty = _this.OVERRIDE_RULE('PropertyListNotEmpty', function (disallowEdgeProperties) {\n            _this.SUBRULE(_this.Verb);\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.ObjectList);\n                    },\n                },\n                {\n                    GATE: function () { return !disallowEdgeProperties; },\n                    ALT: function () {\n                        _this.SUBRULE(_this.EmbeddedPropertyList);\n                        _this.SUBRULE(_this.Object);\n                    },\n                },\n            ]);\n            _this.MANY(function () {\n                _this.CONSUME(sparqlTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.SUBRULE1(_this.Verb);\n                    _this.OR1([\n                        {\n                            ALT: function () {\n                                _this.SUBRULE1(_this.ObjectList);\n                            },\n                        },\n                        {\n                            GATE: function () { return !disallowEdgeProperties; },\n                            ALT: function () {\n                                _this.SUBRULE1(_this.EmbeddedPropertyList);\n                                _this.SUBRULE1(_this.Object);\n                            },\n                        },\n                    ]);\n                });\n            });\n        });\n        // NOTE: Intentionally does not conform to the SPARQL* spec.\n        // Stardog does not allow nesting of embedded triples.\n        _this.EmbeddedPropertyList = _this.RULE('EmbeddedPropertyList', function () {\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.SUBRULE(_this.PropertyListNotEmpty, { ARGS: [true] });\n            _this.CONSUME(sparqlTokenMap.RCurly);\n        });\n        _this.Object = _this.OVERRIDE_RULE('Object', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.GraphNode); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.EmbeddedTriplePattern); },\n                },\n            ]);\n        });\n        _this.TriplesSameSubjectPath = _this.OVERRIDE_RULE('TriplesSameSubjectPath', function () {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.VarOrTerm);\n                        _this.SUBRULE(_this.PropertyListPathNotEmpty);\n                    },\n                },\n                {\n                    ALT: function () {\n                        // NOTE: Intentionally does not conform to the SPARQL* spec.\n                        // Stardog does not allow nesting of embedded triples.\n                        _this.SUBRULE(_this.EmbeddedTriplePattern);\n                        _this.SUBRULE1(_this.PropertyListPathNotEmpty, { ARGS: [true] });\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.TriplesNodePath);\n                        _this.SUBRULE(_this.PropertyListPath);\n                    },\n                },\n            ]);\n        });\n        // NOTE: Intentionally does not conform to the SPARQL* spec.\n        // Stardog does not allow embedded triples with paths or object lists.\n        _this.PropertyListPathNotEmpty = _this.OVERRIDE_RULE('PropertyListPathNotEmpty', function (disallowEdgeProperties) {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.OR1([\n                            { ALT: function () { return _this.SUBRULE(_this.VerbPath); } },\n                            { ALT: function () { return _this.SUBRULE1(_this.VerbSimple); } },\n                        ]);\n                        _this.SUBRULE(_this.ObjectListPath);\n                    },\n                },\n                {\n                    GATE: function () { return !disallowEdgeProperties; },\n                    ALT: function () {\n                        _this.SUBRULE(_this.Verb);\n                        _this.SUBRULE(_this.EmbeddedPropertyListPath);\n                        _this.SUBRULE(_this.ObjectPath);\n                    },\n                },\n            ]);\n            _this.MANY(function () {\n                _this.CONSUME(sparqlTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.OR2([\n                        {\n                            ALT: function () {\n                                _this.OR3([\n                                    { ALT: function () { return _this.SUBRULE1(_this.VerbPath); } },\n                                    { ALT: function () { return _this.SUBRULE2(_this.VerbSimple); } },\n                                ]);\n                                _this.SUBRULE1(_this.ObjectListPath);\n                            },\n                        },\n                        {\n                            GATE: function () { return !disallowEdgeProperties; },\n                            ALT: function () {\n                                _this.SUBRULE1(_this.Verb);\n                                _this.SUBRULE1(_this.EmbeddedPropertyListPath);\n                                _this.SUBRULE1(_this.ObjectPath);\n                            },\n                        },\n                    ]);\n                });\n            });\n        });\n        // NOTE: Intentionally does not conform to the SPARQL* spec.\n        // Stardog does not allow nesting of embedded triples.\n        _this.EmbeddedPropertyListPath = _this.RULE('EmbeddedPropertyListPath', function () {\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.SUBRULE(_this.PropertyListPathNotEmpty, { ARGS: [true] });\n            _this.CONSUME(sparqlTokenMap.RCurly);\n        });\n        _this.GraphNodePath = _this.OVERRIDE_RULE('GraphNodePath', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.VarOrTermOrEmbeddedTriplePattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.TriplesNodePath); } },\n            ]);\n        });\n        // NOTE: Intentionally does not conform to the SPARQL* spec. Stardog does not\n        // allow nesting of embedded triples.\n        _this.EmbeddedTriplePattern = _this.RULE('EmbeddedTriplePattern', function () {\n            _this.CONSUME(sparqlTokenMap.LEmbed);\n            _this.SUBRULE(_this.VarOrBlankNodeOrIriOrLit);\n            _this.SUBRULE(_this.Verb);\n            _this.SUBRULE1(_this.VarOrBlankNodeOrIriOrLit);\n            _this.CONSUME(sparqlTokenMap.REmbed);\n        });\n        _this.VarOrTermOrEmbeddedTriplePattern = _this.RULE('VarOrTermOrEmbeddedTriplePattern', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.Var); } },\n                { ALT: function () { return _this.SUBRULE(_this.GraphTerm); } },\n                { ALT: function () { return _this.SUBRULE(_this.EmbeddedTriplePattern); } },\n            ]);\n        });\n        _this.Bind = _this.OVERRIDE_RULE('Bind', function () {\n            _this.CONSUME(sparqlTokenMap.BIND);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.ExpressionOrEmbeddedTriplePattern);\n            _this.CONSUME(sparqlTokenMap.AS);\n            _this.SUBRULE(_this.Var);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.ExpressionOrEmbeddedTriplePattern = _this.RULE('ExpressionOrEmbeddedTriplePattern', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.Expression); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.EmbeddedTriplePattern); },\n                },\n            ]);\n        });\n        // NOTE: This is nearly equivalent to VarOrTerm, but excludes NIL.\n        _this.VarOrBlankNodeOrIriOrLit = _this.RULE('VarOrBlankNodeOrIriOrLit', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.Var); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNode); } },\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.RDFLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.BooleanLiteral); } },\n            ]);\n        });\n        _this.Unnest = _this.RULE('Unnest', function () {\n            _this.CONSUME(sparqlTokenMap.UNNEST);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.AS);\n            _this.SUBRULE(_this.Var);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall = _this.OVERRIDE_RULE('BuiltInCall', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.Aggregate); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STR); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_LANG); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_LANGMATCHES); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_DATATYPE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_BOUND); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_IRI); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_URI); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_BNODE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_RAND); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_ABS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_CEIL); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_FLOOR); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_ROUND); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_CONCAT); } },\n                { ALT: function () { return _this.SUBRULE(_this.SubstringExpression); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRLEN); } },\n                { ALT: function () { return _this.SUBRULE(_this.StrReplaceExpression); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_UCASE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_LCASE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_ENCODE_FOR_URI); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_CONTAINS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRSTARTS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRENDS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRBEFORE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRAFTER); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_YEAR); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_MONTH); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_DAY); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_HOURS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_MINUTES); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_SECONDS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_TIMEZONE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_TZ); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_NOW); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_UUID); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRUUID); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_MD5); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_SHA1); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_SHA256); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_SHA384); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_SHA512); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_COALESCE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_IF); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRLANG); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRDT); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_sameTerm); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_isIRI); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_isURI); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_isBLANK); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_isLITERAL); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_isNUMERIC); } },\n                { ALT: function () { return _this.SUBRULE(_this.RegexExpression); } },\n                { ALT: function () { return _this.SUBRULE(_this.ExistsFunction); } },\n                { ALT: function () { return _this.SUBRULE(_this.NotExistsFunction); } },\n                // Stardog has some additional built-in functions, and supports user-defined custom functions\n                { ALT: function () { return _this.SUBRULE(_this.StardogOrCustomFunction); } },\n            ]);\n        });\n        _this.StardogOrCustomFunction = _this.RULE('StardogOrCustomFunction', function () {\n            _this.CONSUME(sparqlTokenMap.Unknown);\n            _this.SUBRULE(_this.ExpressionList);\n        });\n        _this.ConstructTemplate = _this.OVERRIDE_RULE('ConstructTemplate', function () {\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.OPTION(function () {\n                // Stardog supports the request of Quads in a Construct template. See Stardog issue #675\n                return _this.SUBRULE(_this.Quads);\n            });\n            _this.CONSUME(sparqlTokenMap.RCurly);\n        });\n        Parser.performSelfAnalysis(_this);\n        return _this;\n    }\n    return StardogSparqlParser;\n}(BaseSparqlParser));\nexport { StardogSparqlParser };\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar baseTokens = require('./tokens').baseTokens;\nimport { BaseSparqlParser } from './BaseSparqlParser';\nimport { Parser } from 'chevrotain';\nvar W3SpecSparqlParser = /** @class */ (function (_super) {\n    __extends(W3SpecSparqlParser, _super);\n    function W3SpecSparqlParser(options) {\n        var _this = _super.call(this, options, baseTokens) || this;\n        Parser.performSelfAnalysis(_this);\n        return _this;\n    }\n    return W3SpecSparqlParser;\n}(BaseSparqlParser));\nexport { W3SpecSparqlParser };\n","export * from './BaseSparqlParser';\nexport * from './W3SpecSparqlParser';\nexport * from './StardogSparqlParser';\n// Convenience imports/exports that aren't core functionality:\n// NOTE: Tokens MUST be imported using CommonJS syntax; see here: https://github.com/SAP/chevrotain/issues/345\nexport var sparqlTokens = require('./tokens');\nexport var keywords = require('./keywords').keywords;\nexport var terminals = require('./terminals').terminals;\n","var _a;\nvar _b = require('../turtle/tokens'), turtleTokenTypes = _b.turtleTokenTypes, turtleTokenMap = _b.turtleTokenMap;\nvar sparqlTokenMap = require('../sparql/tokens').sparqlTokenMap;\nimport { createToken } from 'chevrotain';\nimport { CATCH_ALL_AT_LEAST_ONE } from '../helpers/matchers';\nvar LexerMode;\n(function (LexerMode) {\n    LexerMode[\"TURTLE\"] = \"turtle\";\n    LexerMode[\"IFCLAUSE\"] = \"ifclause\";\n    LexerMode[\"THENCLAUSE\"] = \"thenclause\";\n})(LexerMode || (LexerMode = {}));\nvar Rule = createToken({\n    name: 'Rule',\n    pattern: /rule/i,\n});\nvar If = createToken({\n    name: 'If',\n    pattern: /if/i,\n    push_mode: LexerMode.IFCLAUSE,\n});\nvar Then = createToken({\n    name: 'Then',\n    pattern: /then/i,\n    push_mode: LexerMode.THENCLAUSE,\n});\nvar EndThen = createToken({\n    name: 'EndThen',\n    pattern: '}',\n    pop_mode: true,\n});\n// NOTE: Not a SPARQL GroupGraphPattern. Rather, a placeholder for one. We have\n// to let the SRS parser create this token, then replace with a token returned\n// by the SPARQL sub-parser.\nvar GroupGraphPattern = createToken({\n    name: 'GroupGraphPattern',\n    pattern: function (text, startOffset) {\n        if (startOffset === void 0) { startOffset = 0; }\n        // Capture a single brace and then anything up to its closing brace.\n        if (text[startOffset] !== '{') {\n            return null;\n        }\n        var unclosedBraceCount = 1;\n        var cursor;\n        for (cursor = startOffset + 1; cursor < text.length && unclosedBraceCount > 0; cursor++) {\n            if (text[cursor] === '{') {\n                unclosedBraceCount++;\n            }\n            else if (text[cursor] === '}') {\n                unclosedBraceCount--;\n            }\n        }\n        if (unclosedBraceCount > 0) {\n            return null;\n        }\n        return CATCH_ALL_AT_LEAST_ONE.exec(text.slice(startOffset, cursor));\n    },\n    line_breaks: true,\n    pop_mode: true,\n});\n// NOTE: Not a SPARQL TriplesBlock. Rather, a placeholder for one. We have\n// to let the SRS parser create this token, then replace with a token returned\n// by the SPARQL sub-parser.\nvar TriplesBlock = createToken({\n    name: 'TriplesBlock',\n    pattern: /[^{}]+/,\n    line_breaks: true,\n});\nvar indexOfIriRef = turtleTokenTypes.indexOf(turtleTokenMap.IRIREF);\nexport var multiModeLexerDefinition = {\n    modes: (_a = {},\n        _a[LexerMode.TURTLE] = turtleTokenTypes.slice(0, indexOfIriRef + 1).concat([\n            Rule,\n            If,\n            Then\n        ], turtleTokenTypes.slice(indexOfIriRef + 1)),\n        _a[LexerMode.IFCLAUSE] = [turtleTokenMap.WhiteSpace, GroupGraphPattern],\n        _a[LexerMode.THENCLAUSE] = [\n            turtleTokenMap.WhiteSpace,\n            sparqlTokenMap.LCurly,\n            EndThen,\n            TriplesBlock,\n        ],\n        _a),\n    defaultMode: LexerMode.TURTLE,\n};\nexport var srsTokenMap = {\n    Rule: Rule,\n    If: If,\n    Then: Then,\n    EndThen: EndThen,\n    GroupGraphPattern: GroupGraphPattern,\n    TriplesBlock: TriplesBlock,\n};\nexport var srsTokenTypes = [\n    Rule,\n    If,\n    Then,\n    EndThen,\n    sparqlTokenMap.LCurly\n].concat(turtleTokenTypes, [\n    GroupGraphPattern,\n    TriplesBlock,\n]);\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { StardogSparqlParser } from '../sparql';\n// Returns a custom visitor that extends the BaseVisitor for the SRS parser.\n// When the visitor encounters an SRS `IfClause` or an SRS `ThenClause`, it\n// delegates parsing of the block to the existing SPARQL parser's relevant\n// sub-rule (GroupGraphPattern or TriplesBlock).\nexport var getSparqlSrsVisitor = function (BaseVisitor) {\n    var SparqlSrsVisitor = /** @class */ (function (_super) {\n        __extends(SparqlSrsVisitor, _super);\n        function SparqlSrsVisitor() {\n            var _this = _super.call(this) || this;\n            _this.groupGraphPatterns = [];\n            _this.triplesBlocks = [];\n            // Get and store the SPARQL `GroupGraphPattern` that should replace the\n            // SRS placeholder `GroupGraphPattern` token inside of an SRS `IfClause`.\n            _this.IfClause = function (ctx, cstInputTokens) {\n                var GroupGraphPattern = ctx.GroupGraphPattern;\n                _this.$storePlaceholderTokenReplacement({\n                    tokenStore: _this.groupGraphPatterns,\n                    originalTokenContext: GroupGraphPattern,\n                    subParserRule: _this.sparqlParser.parseGroupGraphPattern.bind(_this.sparqlParser),\n                    cstInputTokens: cstInputTokens,\n                });\n            };\n            // Get and store the SPARQL `TriplesBlock` that should replace the\n            // SRS placeholder `TriplesBlock` token inside of an SRS `ThenClause`.\n            _this.ThenClause = function (ctx, cstInputTokens) {\n                var TriplesBlock = ctx.TriplesBlock;\n                _this.$storePlaceholderTokenReplacement({\n                    tokenStore: _this.triplesBlocks,\n                    originalTokenContext: TriplesBlock,\n                    subParserRule: _this.sparqlParser.parseTriplesBlock.bind(_this.sparqlParser),\n                    cstInputTokens: cstInputTokens,\n                });\n            };\n            // Utility methods ('$' prefix is necessary to prevent chevrotain's\n            // `validateVisitor` method from complaining that these are not grammar\n            // rules):\n            _this.$storePlaceholderTokenReplacement = function (_a) {\n                var tokenStore = _a.tokenStore, _b = _a.originalTokenContext, originalTokenContext = _b === void 0 ? [] : _b, subParserRule = _a.subParserRule, cstInputTokens = _a.cstInputTokens, stripWrappers = _a.stripWrappers;\n                var originalToken = originalTokenContext[0];\n                if (!originalToken || typeof originalToken.image !== 'string') {\n                    return;\n                }\n                var replacement = _this.$getPlaceholderTokenReplacement(originalToken, subParserRule, cstInputTokens, stripWrappers);\n                tokenStore.push({\n                    parseResult: replacement,\n                    originalToken: originalToken,\n                });\n            };\n            _this.$getPlaceholderTokenReplacement = function (originalToken, subParserRule, cstInputTokens, stripWrappers) {\n                if (stripWrappers === void 0) { stripWrappers = false; }\n                // Because we are replacing tokens by delegating the parsing of parts\n                // of the original document to sub-parsers, we add some empty padding to\n                // the part that is passed to the sub-parser, where the amount of padding\n                // matches the start line and offset of the token we are replacing. This\n                // ensures that all tokens have the right positions in the resulting CST\n                // (otherwise, the sub-parsers assume that the text starts at offset 0).\n                var image = originalToken.image;\n                var frontPadding = '';\n                var latestEndOffset = 0;\n                var latestEndLine = 0;\n                // Traditional `for` loop because we need to `break`.\n                for (var i = 0; i < cstInputTokens.length; i++) {\n                    var token = cstInputTokens[i];\n                    if (i > 0) {\n                        // Account for whitespace between this token and the previous one.\n                        var linesBetweenTokens = token.startLine - latestEndLine;\n                        var untokenizedSpaceBetweenTokens = token.startOffset - 1 - latestEndOffset - linesBetweenTokens;\n                        if (linesBetweenTokens > 0) {\n                            frontPadding += '\\n'.repeat(linesBetweenTokens - 1);\n                            frontPadding +=\n                                ' '.repeat(Math.max(untokenizedSpaceBetweenTokens, 0)) + '\\n';\n                        }\n                        else {\n                            frontPadding += ' '.repeat(Math.max(untokenizedSpaceBetweenTokens, 0));\n                        }\n                    }\n                    if (token === originalToken) {\n                        break;\n                    }\n                    // We haven't hit the token we're replacing yet, so we need to continue\n                    // accumulating padding by adding the newlines _inside_ the current\n                    // token, and replacing all non-newline characters inside the current\n                    // token with spaces.\n                    var newlinesInToken = token.image.split('\\n');\n                    newlinesInToken.forEach(function (line, idx) {\n                        if (idx > 0) {\n                            frontPadding += '\\n';\n                        }\n                        frontPadding += ' '.repeat(line.length);\n                    });\n                    // Track where the current token ends, in case the next token starts\n                    // much later (meaning that there was untokenized stuff (e.g.,\n                    // whitespace) in between) that needs to be accounted for.\n                    latestEndOffset = token.endOffset;\n                    latestEndLine = token.endLine;\n                }\n                // Finally, if we're stripping the wrappers (e.g., braces), replace them\n                // with whitespace.\n                var parseImage = stripWrappers ? \" \" + image.slice(1, -1) + \" \" : image;\n                return subParserRule(\"\" + frontPadding + parseImage);\n            };\n            _this.$getGroupGraphPatterns = function () { return _this.groupGraphPatterns; };\n            _this.$getTriplesBlocks = function () { return _this.triplesBlocks; };\n            _this.$resetState = function () {\n                _this.groupGraphPatterns = [];\n                _this.triplesBlocks = [];\n            };\n            _this.sparqlParser = new StardogSparqlParser();\n            _this.validateVisitor();\n            return _this;\n        }\n        return SparqlSrsVisitor;\n    }(BaseVisitor));\n    return new SparqlSrsVisitor();\n};\nexport function reduceVisitorItemErrors(acc, item) {\n    return acc.concat(item.parseResult.errors);\n}\n// The SRS cst contains placeholder tokens for unparsed blocks of SPARQL\n// inside of an SRS `IfClause` or `ThenClause`. This method swaps out those\n// placeholders with the actual SPARQL CST created by the SparqlSrsVisitor.\nexport function findAndSwapPlaceholders(node, parentNode, visitorItems, key) {\n    var matchingVisitorItem = visitorItems.find(function (visitorItem) { return visitorItem.originalToken === node; });\n    if (matchingVisitorItem) {\n        parentNode.children[key] = [matchingVisitorItem.parseResult.cst];\n    }\n    return matchingVisitorItem;\n}\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexport var defaultNamespacesMap = Object.freeze(['', 'rdf', 'rdfs', 'xsd', 'owl', 'stardog'].reduce(function (namespacesMap, prefix) {\n    var _a;\n    return (__assign({}, namespacesMap, (_a = {}, _a[prefix] = true, _a)));\n}, {}));\n","var _a;\nimport { isCstNode, traverse } from '../helpers/cst';\nimport { sparqlTokenMap } from '../sparql/tokens';\n// RegEx for matching any relevant children of `Expression` inside of `Bind`;\n// used to avoid false negatives in the check for disallowed literals inside of\n// `Bind`.\nvar subExpressionMatcher = /(?:[A-Z]+Expression|ValueLogical)$/i;\n// Default: just don't abort early at all. Used in the stack unwinding process\n// that creates an error rule stack.\nvar defaultEarlyAbortTest = function () { return false; };\n// Tokens that are allowed in SPARQL but not inside the `IfClause` of SRS.\nvar disallowedSparqlTokenNameToRuleMap = (_a = {},\n    _a[sparqlTokenMap.EXISTS.tokenName] = 'ExistsFunction',\n    _a[sparqlTokenMap.NOT_EXISTS.tokenName] = 'NotExistsFunction',\n    _a[sparqlTokenMap.NOW.tokenName] = 'BuiltInCall_NOW',\n    _a[sparqlTokenMap.LEmbed.tokenName] = 'LeftEmbed',\n    _a[sparqlTokenMap.REmbed.tokenName] = 'RightEmbed',\n    _a);\nvar disallowedSparqlTokenNames = Object.keys(disallowedSparqlTokenNameToRuleMap);\n// Token names for literals; these are not allowed in the subject position of\n// certain patterns in SRS.\nvar disallowedSparqlLiteralTokenNames = [\n    sparqlTokenMap.DOUBLE,\n    sparqlTokenMap.DECIMAL,\n    sparqlTokenMap.INTEGER,\n    sparqlTokenMap.DOUBLE_POSITIVE,\n    sparqlTokenMap.DECIMAL_POSITIVE,\n    sparqlTokenMap.INTEGER_POSITIVE,\n    sparqlTokenMap.DOUBLE_NEGATIVE,\n    sparqlTokenMap.DECIMAL_NEGATIVE,\n    sparqlTokenMap.INTEGER_NEGATIVE,\n    sparqlTokenMap.STRING_LITERAL1,\n    sparqlTokenMap.STRING_LITERAL2,\n    sparqlTokenMap.STRING_LITERAL_LONG1,\n    sparqlTokenMap.STRING_LITERAL_LONG2,\n].map(function (token) { return token.tokenName; });\n// Helper functions for more \"literate\" code.\nvar isCstNodeTraverseContext = function (ctx) {\n    return Boolean(ctx && ctx.node);\n};\n// Is the parent node an Expression child of a Bind node or an Expression\n// child of an ExpressionOrEmbeddedTriplePattern node that is itself a child\n// of a Bind node? The former accounts for standard SPARQL; the latter accounts\n// for Stardog SPARQL with edge properties. This lets certain custom errors\n// work with the output of either the W3CSpecSparqlParser or the\n// StardogSparqlParser.\nvar isParentBindOrBoundExpressionOrEmbeddedTriplePattern = function (parentCtx) {\n    if (!isCstNodeTraverseContext(parentCtx)) {\n        return false;\n    }\n    var parentNodeName = parentCtx.node.name;\n    return (parentNodeName === 'Bind' ||\n        (parentNodeName === 'ExpressionOrEmbeddedTriplePattern' &&\n            isCstNodeTraverseContext(parentCtx.parentCtx) &&\n            parentCtx.parentCtx.node.name === 'Bind'));\n};\n// Walks back up the tree to construct the rule stack, first going upward\n// through the provided `traverseCtx`, and then continuing up through the\n// `fullCtx`. `traverseCtx` is intended to be the \"inner\" ITraverseContext\n// representing the results of the SPARQL sub-parser used by the\n// SparqlSrsVisitor. `fullCtx` is intended to be the \"outer\" ITraverseContext\n// representing the results of the SRS parser itself. The SRS parser delegates\n// blocks of SPARQL to a SPARQL sub-parser, so, by combinging the two contexts,\n// we get the full parser stack. The traversal adds rules to the stack only\n// once a rule matching one of the `startRuleNames` is hit.\n//\n// At the point where the traversal of `traverseCtx` ends and the traversal of\n// `fullCtx` begins, you may need to insert a rule into the stack (e.g.,\n// because the `traverseCtx` doesn't include the top-level rule for that\n// parse). If so, use `topLevelSubParserRuleName`.\n//\n// In some cases, there is a need to track nodes and potentially bail out early\n// at certain points while constructing the rule stack. For that, use\n// `earlyAbortTest`. If that method returns true, the rule stack construction\n// will abort.\nfunction getCustomErrorRuleStack(traverseCtx, fullCtx, startRuleNames, topLevelSubParserRuleName, earlyAbortTest) {\n    if (earlyAbortTest === void 0) { earlyAbortTest = defaultEarlyAbortTest; }\n    if (!traverseCtx) {\n        return []; // forced early exit\n    }\n    var ruleStack = [];\n    var stackUnwindingPointer = traverseCtx;\n    // Move up from current context to the first rule that should \"start\" the stack.\n    while (isCstNode(stackUnwindingPointer.node) &&\n        !startRuleNames.includes(stackUnwindingPointer.node.name)) {\n        if (earlyAbortTest(stackUnwindingPointer)) {\n            return [];\n        }\n        stackUnwindingPointer = stackUnwindingPointer.parentCtx;\n    }\n    // Now start adding all found rules to the stack as we move upward.\n    while (isCstNode(stackUnwindingPointer.node)) {\n        ruleStack.unshift(stackUnwindingPointer.node.name);\n        if (earlyAbortTest(stackUnwindingPointer)) {\n            return [];\n        }\n        stackUnwindingPointer = stackUnwindingPointer.parentCtx;\n    }\n    // If the rule stack of the sub-parser doesn't get all the way up to the\n    // relevant top-level rule, this will force the top-level rule to be put onto\n    // the stack before proceeding.\n    if (typeof topLevelSubParserRuleName === 'string') {\n        ruleStack.unshift(topLevelSubParserRuleName);\n    }\n    // Now that we've got the sub-parser's rule stack, we trace the remaining\n    // outer parser's stack to get to the true bottom of the stack.\n    stackUnwindingPointer = fullCtx;\n    while (stackUnwindingPointer) {\n        if (isCstNode(stackUnwindingPointer.node)) {\n            ruleStack.unshift(stackUnwindingPointer.node.name);\n            if (earlyAbortTest(stackUnwindingPointer)) {\n                return [];\n            }\n        }\n        stackUnwindingPointer = stackUnwindingPointer.parentCtx;\n    }\n    return ['SrsDoc'].concat(ruleStack);\n}\nvar getCustomIRecognitionException = function (_a) {\n    var name = _a.name, message = _a.message, node = _a.node, ruleStack = _a.ruleStack;\n    return ({\n        name: name,\n        message: message,\n        token: node,\n        context: {\n            ruleStack: ruleStack,\n            // `ruleOccurrenceStack` is meaningless to us as it just\n            // records the number used when the chevrotain rule is\n            // created (e.g., SUBRULE1 vs SUBRULE2); we can't know that\n            // or care about that here\n            ruleOccurrenceStack: [],\n        },\n        resyncedTokens: [],\n    });\n};\nvar getNoPrefixError = function (node, parentCtx, fullCtx, subParserRuleName) {\n    return getCustomIRecognitionException({\n        name: 'NoNamespacePrefixError',\n        message: \"A prefix (\\\"\" + node.image + \"\\\") was used for which there was no namespace defined.\",\n        node: node,\n        ruleStack: getCustomErrorRuleStack(parentCtx, fullCtx, ['PrefixedName'], subParserRuleName),\n    });\n};\nvar getDisallowedTokenError = function (node, parentCtx, fullCtx, subParserRuleName) {\n    if (subParserRuleName === void 0) { subParserRuleName = 'GroupGraphPattern'; }\n    return getCustomIRecognitionException({\n        name: 'DisallowedTokenError',\n        message: \"Token \" + node.tokenType.tokenName + \" cannot be used in Stardog Rules.\",\n        node: node,\n        ruleStack: getCustomErrorRuleStack(parentCtx, fullCtx, [disallowedSparqlTokenNameToRuleMap[node.tokenType.tokenName]], subParserRuleName),\n    });\n};\nvar getDisallowedLiteralError = function (node, parentCtx, fullCtx, subParserRuleName) {\n    var foundPropertyListPathNotEmptyCtx = null;\n    var didFindSubExpressionWithMultipleChildren = false;\n    var errorContext = null;\n    var errorRuleStack = getCustomErrorRuleStack(parentCtx, fullCtx, ['Expression', 'TriplesSameSubjectPath'], subParserRuleName, function (stackCtx) {\n        var node = stackCtx.node, parentCtx = stackCtx.parentCtx;\n        var nodeName = node.name;\n        if (nodeName === 'PropertyListPathNotEmpty') {\n            // Track the found `PropertyListPathNotEmmpty` node and keep going.\n            foundPropertyListPathNotEmptyCtx = stackCtx;\n            return false;\n        }\n        if (!didFindSubExpressionWithMultipleChildren &&\n            subExpressionMatcher.test(nodeName)) {\n            // Track that we found a sub-expression with multiple children, then\n            // keep going.\n            didFindSubExpressionWithMultipleChildren =\n                parentCtx.node.children[nodeName].length > 1;\n            return false;\n        }\n        var isExpression = nodeName === 'Expression';\n        var isTriplesBlock = nodeName === 'TriplesSameSubjectPath';\n        if (!isExpression && !isTriplesBlock) {\n            return false;\n        }\n        var isBoundExpressionWithLiteralSubject = isExpression &&\n            // If we've found a sub-expression with multiple children, it's highly\n            // likely (maybe definite?) that this `Bind` does not include an invalid\n            // literal as a subject, so we don't count this as an error. This _may_\n            // allow rare false positives, but it definitely prevents false\n            // negatives of the sort described in https://github.com/stardog-union/millan/issues/22\n            !didFindSubExpressionWithMultipleChildren &&\n            isParentBindOrBoundExpressionOrEmbeddedTriplePattern(parentCtx);\n        var isTriplesBlockSubject = isTriplesBlock &&\n            (!foundPropertyListPathNotEmptyCtx ||\n                foundPropertyListPathNotEmptyCtx.parentCtx.node.name !==\n                    'TriplesSameSubjectPath');\n        if (isBoundExpressionWithLiteralSubject || isTriplesBlockSubject) {\n            errorContext = isBoundExpressionWithLiteralSubject\n                ? 'Bind'\n                : 'TriplesBlock';\n            return false;\n        }\n        // We got to the Expression or TriplesBlock containing the literal, but\n        // the literal wasn't in the subject position (i.e., was not the lead\n        // Expression inside of Bind and was not the subject of\n        // TriplesSameSubjectPath), so we can bail early here.\n        return true;\n    });\n    if (errorRuleStack.length === 0) {\n        return;\n    }\n    return getCustomIRecognitionException({\n        name: 'DisallowedLiteralError',\n        message: \"Token \" + node.tokenType.tokenName + \" (\" + node.image + \") cannot be used as a subject inside of a \" + errorContext + \" in Stardog Rules Syntax.\",\n        node: node,\n        ruleStack: errorRuleStack,\n    });\n};\n// Since the SRS parser delegates to the SPARQL parser inside of\n// an SRS `IfClause`, and SPARQL allows certain constructs that SRS does not,\n// we need to create our own errors for SRS-specific restrictions here.\nexport function addIfClauseErrorsToErrors(_a) {\n    var cst = _a.cst, namespacesMap = _a.namespacesMap, fullCtx = _a.fullCtx, errors = _a.errors, semanticErrors = _a.semanticErrors;\n    traverse(cst, function (ctx, next) {\n        var node = ctx.node, parentCtx = ctx.parentCtx;\n        if (isCstNode(node)) {\n            return next();\n        }\n        var tokenName = node.tokenType.tokenName;\n        if (disallowedSparqlTokenNames.some(function (name) { return name === tokenName; })) {\n            errors.push(getDisallowedTokenError(node, parentCtx, fullCtx));\n        }\n        if (disallowedSparqlLiteralTokenNames.some(function (tokenName) { return tokenName === node.tokenType.tokenName; })) {\n            var error = getDisallowedLiteralError(node, parentCtx, fullCtx, 'GroupGraphPattern');\n            if (error) {\n                errors.push(error);\n            }\n        }\n        if (tokenName === 'PNAME_NS' || tokenName === 'PNAME_LN') {\n            var prefix = node.image.split(':').shift();\n            if (!namespacesMap[prefix]) {\n                semanticErrors.push(getNoPrefixError(node, parentCtx, fullCtx, 'GroupGraphPattern'));\n            }\n        }\n    });\n    return {\n        errors: errors,\n        semanticErrors: semanticErrors,\n    };\n}\nexport function addThenClauseErrorsToErrors(_a) {\n    var cst = _a.cst, namespacesMap = _a.namespacesMap, errors = _a.errors, semanticErrors = _a.semanticErrors, fullCtx = _a.fullCtx;\n    traverse(cst, function (ctx, next) {\n        var node = ctx.node, parentCtx = ctx.parentCtx;\n        if (isCstNode(node)) {\n            return next();\n        }\n        var tokenName = node.tokenType.tokenName;\n        if (disallowedSparqlLiteralTokenNames.some(function (tokenName) { return tokenName === node.tokenType.tokenName; })) {\n            var error = getDisallowedLiteralError(node, parentCtx, fullCtx, 'GroupGraphPattern');\n            if (error) {\n                errors.push(error);\n            }\n        }\n        // No embedded triple patterns in SRS THEN clauses.\n        if (tokenName === sparqlTokenMap.LEmbed.name ||\n            tokenName === sparqlTokenMap.REmbed.name) {\n            errors.push(getDisallowedTokenError(node, parentCtx, fullCtx, 'TriplesBlock'));\n        }\n        if (tokenName === 'PNAME_NS' || tokenName === 'PNAME_LN') {\n            var prefix = node.image.split(':').shift();\n            if (!namespacesMap[prefix]) {\n                semanticErrors.push(getNoPrefixError(node, parentCtx, fullCtx, 'TriplesBlock'));\n            }\n        }\n    });\n    return {\n        errors: errors,\n        semanticErrors: semanticErrors,\n    };\n}\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n// tslint:disable:function-name\nvar sparqlTokenMap = require('../sparql/tokens').sparqlTokenMap;\nvar _a = require('./tokens'), srsTokenMap = _a.srsTokenMap, srsTokenTypes = _a.srsTokenTypes, multiModeLexerDefinition = _a.multiModeLexerDefinition;\nimport { Parser, Lexer, } from 'chevrotain';\nimport { TurtleParser } from '../turtle/TurtleParser';\nimport { isCstNode, unsafeTraverse } from '../helpers/cst';\nimport { defaultNamespacesMap } from 'turtle/defaultNamespaces';\nimport { getSparqlSrsVisitor, reduceVisitorItemErrors, findAndSwapPlaceholders, } from './visitor';\nimport { addThenClauseErrorsToErrors, addIfClauseErrorsToErrors, } from './customErrors';\nvar SrsParser = /** @class */ (function (_super) {\n    __extends(SrsParser, _super);\n    function SrsParser(config) {\n        var _this = _super.call(this, __assign({ outputCst: true, recoveryEnabled: true }, config), srsTokenTypes, multiModeLexerDefinition, false) || this;\n        _this.baseNamespacesMap = Object.freeze(__assign({}, defaultNamespacesMap));\n        _this.namespacesMap = {};\n        _this.visitCst = function (cst) {\n            // To save resources while parsing, the sparqlSrsVisitor is a singleton.\n            if (!_this.sparqlSrsVisitor) {\n                var BaseSrsVisitor = _this.getBaseCstVisitorConstructorWithDefaults();\n                _this.sparqlSrsVisitor = getSparqlSrsVisitor(BaseSrsVisitor);\n            }\n            else {\n                _this.sparqlSrsVisitor.$resetState();\n            }\n            _this.sparqlSrsVisitor.visit(cst, _this.input);\n        };\n        _this.getSparqlRulesFromVisitor = function (cst) {\n            _this.visitCst(cst);\n            return {\n                groupGraphPatterns: _this.sparqlSrsVisitor.$getGroupGraphPatterns(),\n                triplesBlocks: _this.sparqlSrsVisitor.$getTriplesBlocks(),\n            };\n        };\n        _this.resetManagedState = function () {\n            _this.namespacesMap = __assign({}, defaultNamespacesMap);\n            _this.semanticErrors = [];\n        };\n        _this.setBaseNamespaces = function (newBaseNamespaces) {\n            _this.baseNamespacesMap = __assign({}, newBaseNamespaces);\n        };\n        _this.tokenize = function (document) {\n            return _this.lexer.tokenize(document).tokens;\n        };\n        _this.parse = function (document, mode) {\n            if (mode === void 0) { mode = 'standard'; }\n            _this.resetManagedState();\n            _this.input = _this.lexer.tokenize(document).tokens;\n            var cst = _this.SrsDoc(0, [mode]);\n            var _a = _this.getSparqlRulesFromVisitor(cst), groupGraphPatterns = _a.groupGraphPatterns, triplesBlocks = _a.triplesBlocks;\n            // Pull visitor errors\n            var errors = _this.errors.concat(groupGraphPatterns.reduce(reduceVisitorItemErrors, []), triplesBlocks.reduce(reduceVisitorItemErrors, []));\n            var semanticErrors = _this.semanticErrors.slice();\n            // Replace placeholder CST nodes created by the SRS parser with CST nodes\n            // returned by the visitor sub-parsers.\n            unsafeTraverse(cst, function (ctx, next) {\n                var node = ctx.node, parentCtx = ctx.parentCtx;\n                if (isCstNode(node)) {\n                    return next();\n                }\n                var currentTokenName = node.tokenType.tokenName;\n                if (currentTokenName !== 'GroupGraphPattern' &&\n                    currentTokenName !== 'TriplesBlock') {\n                    return;\n                }\n                var parentNode = parentCtx.node;\n                // The SRS parser parses only Turtle and SRS-specific content (RULE, IF,\n                // THEN), and creates placeholder tokens for the blocks where SPARQL is\n                // valid. The SparqlSrsVisitor visits these nodes and delegates their\n                // parsing to a SPARQL parser. Here, we replace the placeholder nodes\n                // (`GroupGraphPattern` and `TriplesBlock`) with the real ones from the\n                // SPARQL parser, collecting some custom SRS-specific errors along the\n                // way.\n                if (parentNode.name === 'IfClause') {\n                    var matchingVisitorItem = findAndSwapPlaceholders(node, parentNode, groupGraphPatterns, 'GroupGraphPattern');\n                    if (matchingVisitorItem) {\n                        addIfClauseErrorsToErrors({\n                            fullCtx: ctx,\n                            namespacesMap: __assign({}, _this.baseNamespacesMap, _this.namespacesMap),\n                            cst: matchingVisitorItem.parseResult.cst,\n                            errors: errors,\n                            semanticErrors: semanticErrors,\n                        });\n                    }\n                }\n                else if (parentNode.name === 'ThenClause') {\n                    var matchingVisitorItem = findAndSwapPlaceholders(node, parentNode, triplesBlocks, 'TriplesBlock');\n                    if (matchingVisitorItem) {\n                        addThenClauseErrorsToErrors({\n                            fullCtx: ctx,\n                            namespacesMap: __assign({}, _this.baseNamespacesMap, _this.namespacesMap),\n                            cst: matchingVisitorItem.parseResult.cst,\n                            errors: errors,\n                            semanticErrors: semanticErrors,\n                        });\n                    }\n                }\n            });\n            return {\n                semanticErrors: semanticErrors,\n                errors: errors,\n                cst: cst,\n            };\n        };\n        _this.SrsDoc = _this.RULE('SrsDoc', function (mode) {\n            var allowEdgeProperties = mode === 'stardog';\n            _this.SUBRULE(_this.turtleDoc, { ARGS: [mode] });\n            _this.MANY(function () {\n                _this.SUBRULE(_this.RuleDoc);\n                _this.MANY1(function () {\n                    _this.SUBRULE(_this.triples, { ARGS: [allowEdgeProperties] });\n                    _this.CONSUME(sparqlTokenMap.Period);\n                });\n            });\n        });\n        _this.RuleDoc = _this.RULE('RuleDoc', function () {\n            _this.OPTION(function () { return _this.SUBRULE(_this.RuleClause); });\n            _this.SUBRULE(_this.IfClause);\n            _this.SUBRULE(_this.ThenClause);\n        });\n        _this.RuleClause = _this.RULE('RuleClause', function () {\n            _this.CONSUME(srsTokenMap.Rule);\n            _this.SUBRULE(_this.iri);\n        });\n        _this.IfClause = _this.RULE('IfClause', function () {\n            _this.CONSUME(srsTokenMap.If);\n            _this.CONSUME(srsTokenMap.GroupGraphPattern);\n        });\n        _this.ThenClause = _this.RULE('ThenClause', function () {\n            _this.CONSUME(srsTokenMap.Then);\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.CONSUME(srsTokenMap.TriplesBlock);\n            _this.CONSUME(srsTokenMap.EndThen);\n        });\n        _this.lexer = new Lexer(multiModeLexerDefinition);\n        Parser.performSelfAnalysis(_this);\n        return _this;\n    }\n    return SrsParser;\n}(TurtleParser));\nexport { SrsParser };\n","export * from './SrsParser';\n// Convenience imports/exports that aren't core functionality:\n// NOTE: Tokens MUST be imported using CommonJS syntax; see here: https://github.com/SAP/chevrotain/issues/345\nexport var srsTokens = require('./tokens');\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar sparqlTokenMap = require('./tokens').sparqlTokenMap;\nimport { Parser, Lexer, } from 'chevrotain';\n// @ts-ignore: debug logging\nfunction log() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    // console.log(...args);\n}\nvar BaseSparqlParser = /** @class */ (function (_super) {\n    __extends(BaseSparqlParser, _super);\n    function BaseSparqlParser(options, tokenVocab) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, tokenVocab, __assign({ recoveryEnabled: true, outputCst: true }, options.config)) || this;\n        _this.tokenize = function (document) {\n            return _this.lexer.tokenize(document).tokens;\n        };\n        _this.parse = function (document, entryRule) {\n            if (entryRule === void 0) { entryRule = _this.SparqlDoc; }\n            _this.input = _this.lexer.tokenize(document).tokens;\n            var cst = entryRule.call(_this);\n            var errors = _this.errors;\n            return {\n                errors: errors,\n                cst: cst,\n            };\n        };\n        _this.parseGroupGraphPattern = function (document) {\n            return _this.parse(document, _this.GroupGraphPattern);\n        };\n        _this.parseTriplesBlock = function (document) {\n            return _this.parse(document, _this.TriplesBlock);\n        };\n        // NOTE: For the sake of usability in text editors/IDEs, this parser encodes\n        // a grammar that is slightly different from the official SPARQL spec. The\n        // main differences are in the `SparqlDoc`, rule, the `Prologue` rule, and\n        // the `Update` rule. Essentially, the grammar encoded by this parser should\n        // allow any number of interspered Prologues (PREFIX/BASE), QueryUnits, and\n        // UpdateUnits, so that, e.g., this is valid:\n        //\n        //  select * { ?s ?p ?o }\n        //  prefix foo: <bar>\n        //  clear all\n        //  prefix x: <y>\n        //  construct { ?s ?p ?o }\n        //  ask { ?s ?p ?o }\n        //\n        // This is not valid according to the official spec. However, line 1 is\n        // valid, lines 2-3 are valid, lines 4-5 are valid, and line 6 is valid. In a\n        // text editor, a user might want to select and execute only those lines.\n        _this.SparqlDoc = _this.RULE('SparqlDoc', function () {\n            log('SparqlDoc');\n            _this.MANY(function () {\n                return _this.OR([\n                    { ALT: function () { return _this.SUBRULE(_this.Prologue); } },\n                    { ALT: function () { return _this.SUBRULE(_this.QueryUnit); } },\n                    { ALT: function () { return _this.SUBRULE(_this.UpdateUnit); } },\n                ]);\n            });\n        });\n        _this.QueryUnit = _this.RULE('QueryUnit', function () {\n            log('QueryUnit');\n            _this.SUBRULE(_this.Query);\n        });\n        _this.Query = _this.RULE('Query', function () {\n            log('Query');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.SelectQuery); } },\n                { ALT: function () { return _this.SUBRULE(_this.ConstructQuery); } },\n                { ALT: function () { return _this.SUBRULE(_this.DescribeQuery); } },\n                { ALT: function () { return _this.SUBRULE(_this.AskQuery); } },\n            ]);\n            _this.SUBRULE(_this.ValuesClause);\n        });\n        _this.Constant = _this.RULE('Constant', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.RDFLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.BooleanLiteral); } },\n            ]);\n        });\n        _this.MaxLength = _this.RULE('MaxLength', function () {\n            _this.CONSUME(sparqlTokenMap.MAX_LENGTH);\n            _this.CONSUME(sparqlTokenMap.INTEGER);\n        });\n        _this.UpdateUnit = _this.RULE('UpdateUnit', function () {\n            log('UpdateUnit');\n            _this.SUBRULE(_this.Update);\n        });\n        _this.Prologue = _this.RULE('Prologue', function () {\n            log('Prologue');\n            _this.AT_LEAST_ONE(function () {\n                return _this.OR([\n                    { ALT: function () { return _this.SUBRULE(_this.BaseDecl); } },\n                    { ALT: function () { return _this.SUBRULE(_this.PrefixDecl); } },\n                ]);\n            });\n        });\n        _this.BaseDecl = _this.RULE('BaseDecl', function () {\n            log('BaseDecl');\n            _this.CONSUME(sparqlTokenMap.BASE);\n            _this.CONSUME(sparqlTokenMap.IRIREF);\n        });\n        _this.PrefixDecl = _this.RULE('PrefixDecl', function () {\n            log('PrefixDecl');\n            _this.CONSUME(sparqlTokenMap.PREFIX);\n            _this.CONSUME(sparqlTokenMap.PNAME_NS);\n            _this.CONSUME(sparqlTokenMap.IRIREF);\n        });\n        _this.SelectQuery = _this.RULE('SelectQuery', function () {\n            log('SelectQuery');\n            _this.SUBRULE(_this.SelectClause);\n            _this.MANY(function () { return _this.SUBRULE(_this.DatasetClause); });\n            _this.SUBRULE(_this.WhereClause);\n            _this.SUBRULE(_this.SolutionModifier);\n        });\n        _this.SubSelect = _this.RULE('SubSelect', function () {\n            log('SubSelect');\n            _this.SUBRULE(_this.SelectClause);\n            _this.SUBRULE(_this.WhereClause);\n            _this.SUBRULE(_this.SolutionModifier);\n            _this.SUBRULE(_this.ValuesClause);\n        });\n        _this.SelectClause = _this.RULE('SelectClause', function () {\n            log('SelectClause');\n            _this.CONSUME(sparqlTokenMap.SELECT);\n            _this.OPTION(function () {\n                return _this.OR([\n                    { ALT: function () { return _this.CONSUME(sparqlTokenMap.DISTINCT); } },\n                    { ALT: function () { return _this.CONSUME(sparqlTokenMap.REDUCED); } },\n                ]);\n            });\n            _this.OR1([\n                {\n                    ALT: function () {\n                        _this.AT_LEAST_ONE(function () {\n                            return _this.OR2([\n                                { ALT: function () { return _this.SUBRULE(_this.Var); } },\n                                {\n                                    ALT: function () {\n                                        _this.CONSUME(sparqlTokenMap.LParen);\n                                        _this.SUBRULE(_this.Expression);\n                                        _this.CONSUME(sparqlTokenMap.AS);\n                                        _this.SUBRULE1(_this.Var);\n                                        _this.CONSUME(sparqlTokenMap.RParen);\n                                    },\n                                },\n                            ]);\n                        });\n                    },\n                },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.Star); } },\n            ]);\n        });\n        _this.ConstructQuery = _this.RULE('ConstructQuery', function () {\n            _this.CONSUME(sparqlTokenMap.CONSTRUCT);\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.ConstructTemplate);\n                        _this.MANY(function () { return _this.SUBRULE(_this.DatasetClause); });\n                        _this.SUBRULE(_this.WhereClause);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.MANY1(function () { return _this.SUBRULE1(_this.DatasetClause); });\n                        _this.CONSUME(sparqlTokenMap.WHERE);\n                        _this.CONSUME(sparqlTokenMap.LCurly);\n                        _this.OPTION(function () { return _this.SUBRULE(_this.TriplesTemplate); });\n                        _this.CONSUME(sparqlTokenMap.RCurly);\n                    },\n                },\n            ]);\n            _this.SUBRULE(_this.SolutionModifier);\n        });\n        _this.DescribeQuery = _this.RULE('DescribeQuery', function () {\n            log('DescribeQuery');\n            _this.CONSUME(sparqlTokenMap.DESCRIBE);\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.AT_LEAST_ONE(function () { return _this.SUBRULE(_this.VarOrIri); });\n                    },\n                },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.Star); } },\n            ]);\n            _this.MANY(function () { return _this.SUBRULE(_this.DatasetClause); });\n            _this.OPTION(function () { return _this.SUBRULE(_this.WhereClause); });\n            _this.SUBRULE(_this.SolutionModifier);\n        });\n        _this.AskQuery = _this.RULE('AskQuery', function () {\n            log('AskQuery');\n            _this.CONSUME(sparqlTokenMap.ASK);\n            _this.MANY(function () { return _this.SUBRULE(_this.DatasetClause); });\n            _this.SUBRULE(_this.WhereClause);\n            _this.SUBRULE(_this.SolutionModifier);\n        });\n        _this.DatasetClause = _this.RULE('DatasetClause', function () {\n            log('DatasetClause');\n            _this.CONSUME(sparqlTokenMap.FROM);\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.DefaultGraphClause); } },\n                { ALT: function () { return _this.SUBRULE(_this.NamedGraphClause); } },\n            ]);\n        });\n        _this.DefaultGraphClause = _this.RULE('DefaultGraphClause', function () {\n            log('DefaultGraphClause');\n            _this.SUBRULE(_this.SourceSelector);\n        });\n        _this.NamedGraphClause = _this.RULE('NamedGraphClause', function () {\n            log('NamedGraphClause');\n            _this.CONSUME(sparqlTokenMap.NAMED);\n            _this.SUBRULE(_this.SourceSelector);\n        });\n        _this.SourceSelector = _this.RULE('SourceSelector', function () {\n            log('SourceSelector');\n            _this.SUBRULE(_this.iri);\n        });\n        _this.WhereClause = _this.RULE('WhereClause', function () {\n            log('WhereClause');\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.WHERE); });\n            _this.SUBRULE(_this.GroupGraphPattern);\n        });\n        _this.SolutionModifier = _this.RULE('SolutionModifier', function () {\n            log('SolutionModifier');\n            _this.OPTION(function () { return _this.SUBRULE(_this.GroupClause); });\n            _this.OPTION1(function () { return _this.SUBRULE(_this.HavingClause); });\n            _this.OPTION2(function () { return _this.SUBRULE(_this.OrderClause); });\n            _this.OPTION3(function () { return _this.SUBRULE(_this.LimitOffsetClause); });\n        });\n        _this.GroupClause = _this.RULE('GroupClause', function () {\n            log('GroupClause');\n            _this.CONSUME(sparqlTokenMap.GROUP_BY);\n            _this.AT_LEAST_ONE(function () { return _this.SUBRULE(_this.GroupCondition); });\n        });\n        _this.GroupCondition = _this.RULE('GroupCondition', function () {\n            log('GroupCondition');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall); } },\n                { ALT: function () { return _this.SUBRULE(_this.FunctionCall); } },\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.LParen);\n                        _this.SUBRULE(_this.Expression);\n                        _this.OPTION(function () {\n                            _this.CONSUME(sparqlTokenMap.AS);\n                            _this.SUBRULE(_this.Var);\n                        });\n                        _this.CONSUME(sparqlTokenMap.RParen);\n                    },\n                },\n                { ALT: function () { return _this.SUBRULE1(_this.Var); } },\n            ]);\n        });\n        _this.HavingClause = _this.RULE('HavingClause', function () {\n            log('HavingClause');\n            _this.CONSUME(sparqlTokenMap.HAVING);\n            _this.SUBRULE(_this.HavingCondition);\n        });\n        _this.HavingCondition = _this.RULE('HavingCondition', function () {\n            log('HavingCondition');\n            _this.SUBRULE(_this.Constraint);\n        });\n        _this.OrderClause = _this.RULE('OrderClause', function () {\n            log('OrderClause');\n            _this.CONSUME(sparqlTokenMap.ORDER_BY);\n            _this.AT_LEAST_ONE(function () { return _this.SUBRULE(_this.OrderCondition); });\n        });\n        _this.OrderCondition = _this.RULE('OrderCondition', function () {\n            log('OrderCondition');\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.OR1([\n                            { ALT: function () { return _this.CONSUME(sparqlTokenMap.ASC); } },\n                            { ALT: function () { return _this.CONSUME(sparqlTokenMap.DESC); } },\n                        ]);\n                        _this.SUBRULE(_this.BrackettedExpression);\n                    },\n                },\n                { ALT: function () { return _this.SUBRULE(_this.Constraint); } },\n                { ALT: function () { return _this.SUBRULE(_this.Var); } },\n            ]);\n        });\n        _this.LimitOffsetClause = _this.RULE('LimitOffsetClause', function () {\n            log('LimitOffsetClause');\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.LimitClause);\n                        _this.OPTION(function () { return _this.SUBRULE(_this.OffsetClause); });\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE1(_this.OffsetClause);\n                        _this.OPTION1(function () { return _this.SUBRULE1(_this.LimitClause); });\n                    },\n                },\n            ]);\n        });\n        _this.OffsetClause = _this.RULE('OffsetClause', function () {\n            log('OffsetClause');\n            _this.CONSUME(sparqlTokenMap.OFFSET);\n            _this.CONSUME(sparqlTokenMap.INTEGER);\n        });\n        _this.LimitClause = _this.RULE('LimitClause', function () {\n            log('LimitClause');\n            _this.CONSUME(sparqlTokenMap.LIMIT);\n            _this.CONSUME(sparqlTokenMap.INTEGER);\n        });\n        _this.ValuesClause = _this.RULE('ValuesClause', function () {\n            log('ValuesClause');\n            _this.OPTION(function () {\n                _this.CONSUME(sparqlTokenMap.VALUES);\n                _this.SUBRULE(_this.DataBlock);\n            });\n        });\n        _this.Update = _this.RULE('Update', function () {\n            log('Update');\n            _this.SUBRULE(_this.Update1);\n            _this.OPTION(function () {\n                _this.CONSUME(sparqlTokenMap.Semicolon);\n                _this.SUBRULE(_this.Update);\n            });\n        });\n        _this.Update1 = _this.RULE('Update1', function () {\n            log('Update1');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.Load); } },\n                { ALT: function () { return _this.SUBRULE(_this.Clear); } },\n                { ALT: function () { return _this.SUBRULE(_this.Drop); } },\n                { ALT: function () { return _this.SUBRULE(_this.Add); } },\n                { ALT: function () { return _this.SUBRULE(_this.Move); } },\n                { ALT: function () { return _this.SUBRULE(_this.Copy); } },\n                { ALT: function () { return _this.SUBRULE(_this.Create); } },\n                { ALT: function () { return _this.SUBRULE(_this.InsertData); } },\n                { ALT: function () { return _this.SUBRULE(_this.DeleteData); } },\n                { ALT: function () { return _this.SUBRULE(_this.DeleteWhere); } },\n                { ALT: function () { return _this.SUBRULE(_this.Modify); } },\n            ]);\n        });\n        _this.Load = _this.RULE('Load', function () {\n            log('Load');\n            _this.CONSUME(sparqlTokenMap.LOAD);\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.SILENT); });\n            _this.SUBRULE(_this.iri);\n            _this.OPTION1(function () {\n                _this.CONSUME(sparqlTokenMap.INTO);\n                _this.SUBRULE(_this.GraphRef);\n            });\n        });\n        _this.Clear = _this.RULE('Clear', function () {\n            log('Clear');\n            _this.CONSUME(sparqlTokenMap.CLEAR);\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.SILENT); });\n            _this.SUBRULE(_this.GraphRefAll);\n        });\n        _this.Drop = _this.RULE('Drop', function () {\n            log('Drop');\n            _this.CONSUME(sparqlTokenMap.DROP);\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.SILENT); });\n            _this.SUBRULE(_this.GraphRefAll);\n        });\n        _this.Create = _this.RULE('Create', function () {\n            log('Create');\n            _this.CONSUME(sparqlTokenMap.CREATE);\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.SILENT); });\n            _this.SUBRULE(_this.GraphRefAll);\n        });\n        _this.Add = _this.RULE('Add', function () {\n            log('Add');\n            _this.CONSUME(sparqlTokenMap.ADD);\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.SILENT); });\n            _this.SUBRULE(_this.GraphOrDefault);\n            _this.CONSUME(sparqlTokenMap.TO);\n            _this.SUBRULE1(_this.GraphOrDefault);\n        });\n        _this.Move = _this.RULE('Move', function () {\n            log('Move');\n            _this.CONSUME(sparqlTokenMap.MOVE);\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.SILENT); });\n            _this.SUBRULE(_this.GraphOrDefault);\n            _this.CONSUME(sparqlTokenMap.TO);\n            _this.SUBRULE1(_this.GraphOrDefault);\n        });\n        _this.Copy = _this.RULE('Copy', function () {\n            log('Copy');\n            _this.CONSUME(sparqlTokenMap.COPY);\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.SILENT); });\n            _this.SUBRULE(_this.GraphOrDefault);\n            _this.CONSUME(sparqlTokenMap.TO);\n            _this.SUBRULE1(_this.GraphOrDefault);\n        });\n        _this.InsertData = _this.RULE('InsertData', function () {\n            log('InsertData');\n            _this.CONSUME(sparqlTokenMap.INSERT_DATA);\n            _this.SUBRULE(_this.QuadData);\n        });\n        _this.DeleteData = _this.RULE('DeleteData', function () {\n            log('DeleteData');\n            _this.CONSUME(sparqlTokenMap.DELETE_DATA);\n            _this.SUBRULE(_this.QuadData);\n        });\n        _this.DeleteWhere = _this.RULE('DeleteWhere', function () {\n            log('DeleteWhere');\n            _this.CONSUME(sparqlTokenMap.DELETE_WHERE);\n            _this.SUBRULE(_this.QuadPattern);\n        });\n        _this.Modify = _this.RULE('Modify', function () {\n            log('Modify');\n            _this.OPTION(function () {\n                _this.CONSUME(sparqlTokenMap.WITH);\n                _this.SUBRULE(_this.iri);\n            });\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.DeleteClause);\n                        _this.OPTION1(function () { return _this.SUBRULE(_this.InsertClause); });\n                    },\n                },\n                { ALT: function () { return _this.SUBRULE1(_this.InsertClause); } },\n            ]);\n            _this.MANY(function () { return _this.SUBRULE(_this.UsingClause); });\n            _this.CONSUME(sparqlTokenMap.WHERE);\n            _this.SUBRULE(_this.GroupGraphPattern);\n        });\n        _this.DeleteClause = _this.RULE('DeleteClause', function () {\n            log('DeleteClause');\n            _this.CONSUME(sparqlTokenMap.DELETE);\n            _this.SUBRULE(_this.QuadPattern);\n        });\n        _this.InsertClause = _this.RULE('InsertClause', function () {\n            log('InsertClause');\n            _this.CONSUME(sparqlTokenMap.INSERT);\n            _this.SUBRULE(_this.QuadPattern);\n        });\n        _this.UsingClause = _this.RULE('UsingClause', function () {\n            log('UsingClause');\n            _this.CONSUME(sparqlTokenMap.USING);\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.NAMED);\n                        _this.SUBRULE1(_this.iri);\n                    },\n                },\n            ]);\n        });\n        _this.GraphOrDefault = _this.RULE('GraphOrDefault', function () {\n            log('GraphOrDefault');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.DEFAULT); } },\n                {\n                    ALT: function () {\n                        _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.GRAPH); });\n                        _this.SUBRULE(_this.iri);\n                    },\n                },\n            ]);\n        });\n        _this.GraphRef = _this.RULE('GraphRef', function () {\n            log('GraphRef');\n            _this.CONSUME(sparqlTokenMap.GRAPH);\n            _this.SUBRULE(_this.iri);\n        });\n        _this.GraphRefAll = _this.RULE('GraphRefAll', function () {\n            log('GraphRefAll');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.GraphRef); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.DEFAULT); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.NAMED); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.ALL); } },\n            ]);\n        });\n        _this.QuadPattern = _this.RULE('QuadPattern', function () {\n            log('QuadPattern');\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.SUBRULE(_this.Quads);\n            _this.CONSUME(sparqlTokenMap.RCurly);\n        });\n        _this.QuadData = _this.RULE('QuadData', function () {\n            log('QuadData');\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.SUBRULE(_this.Quads);\n            _this.CONSUME(sparqlTokenMap.RCurly);\n        });\n        _this.Quads = _this.RULE('Quads', function () {\n            log('Quads');\n            _this.OPTION(function () { return _this.SUBRULE(_this.TriplesTemplate); });\n            _this.MANY(function () {\n                _this.SUBRULE(_this.QuadsNotTriples);\n                _this.OPTION1(function () { return _this.CONSUME(sparqlTokenMap.Period); });\n                _this.OPTION2(function () { return _this.SUBRULE1(_this.TriplesTemplate); });\n            });\n        });\n        _this.QuadsNotTriples = _this.RULE('QuadsNotTriples', function () {\n            log('QuadsNotTriples');\n            _this.CONSUME(sparqlTokenMap.GRAPH);\n            _this.SUBRULE(_this.VarOrIri);\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.OPTION(function () { return _this.SUBRULE(_this.TriplesTemplate); });\n            _this.CONSUME(sparqlTokenMap.RCurly);\n        });\n        _this.TriplesTemplate = _this.RULE('TriplesTemplate', function () {\n            log('TriplesTemplate');\n            _this.SUBRULE(_this.TriplesSameSubject);\n            _this.OPTION(function () {\n                _this.CONSUME(sparqlTokenMap.Period);\n                _this.OPTION1(function () { return _this.SUBRULE(_this.TriplesTemplate); });\n            });\n        });\n        _this.GroupGraphPattern = _this.RULE('GroupGraphPattern', function () {\n            log('GroupGraphPattern');\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.SubSelect); } },\n                { ALT: function () { return _this.SUBRULE(_this.GroupGraphPatternSub); } },\n            ]);\n            _this.CONSUME(sparqlTokenMap.RCurly);\n        });\n        _this.GroupGraphPatternSub = _this.RULE('GroupGraphPatternSub', function () {\n            log('GroupGraphPatternSub');\n            _this.OPTION(function () { return _this.SUBRULE(_this.TriplesBlock); });\n            _this.MANY(function () {\n                _this.SUBRULE(_this.GraphPatternNotTriples);\n                _this.OPTION1(function () { return _this.CONSUME(sparqlTokenMap.Period); });\n                _this.OPTION2(function () { return _this.SUBRULE1(_this.TriplesBlock); });\n            });\n        });\n        _this.TriplesBlock = _this.RULE('TriplesBlock', function () {\n            log('TriplesBlock');\n            _this.SUBRULE(_this.TriplesSameSubjectPath);\n            _this.OPTION(function () {\n                _this.CONSUME(sparqlTokenMap.Period);\n                _this.OPTION1(function () { return _this.SUBRULE(_this.TriplesBlock); });\n            });\n        });\n        _this.GraphPatternNotTriples = _this.RULE('GraphPatternNotTriples', function () {\n            log('GraphPatternNotTriples');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.GroupOrUnionGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.OptionalGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.MinusGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.GraphGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.ServiceGraphPattern); } },\n                { ALT: function () { return _this.SUBRULE(_this.Filter); } },\n                { ALT: function () { return _this.SUBRULE(_this.Bind); } },\n                { ALT: function () { return _this.SUBRULE(_this.InlineData); } },\n            ]);\n        });\n        _this.OptionalGraphPattern = _this.RULE('OptionalGraphPattern', function () {\n            log('OptionalGraphPattern');\n            _this.CONSUME(sparqlTokenMap.OPTIONAL);\n            _this.SUBRULE(_this.GroupGraphPattern);\n        });\n        _this.GraphGraphPattern = _this.RULE('GraphGraphPattern', function () {\n            log('GraphGraphPattern');\n            _this.CONSUME(sparqlTokenMap.GRAPH);\n            _this.SUBRULE(_this.VarOrIri);\n            _this.SUBRULE(_this.GroupGraphPattern);\n        });\n        _this.ServiceGraphPattern = _this.RULE('ServiceGraphPattern', function () {\n            log('ServiceGraphPattern');\n            _this.CONSUME(sparqlTokenMap.SERVICE);\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.SILENT); });\n            _this.SUBRULE(_this.VarOrIri);\n            _this.SUBRULE(_this.GroupGraphPattern);\n        });\n        _this.Bind = _this.RULE('Bind', function () {\n            log('Bind');\n            _this.CONSUME(sparqlTokenMap.BIND);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.AS);\n            _this.SUBRULE(_this.Var);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.InlineData = _this.RULE('InlineData', function () {\n            log('InlineData');\n            _this.CONSUME(sparqlTokenMap.VALUES);\n            _this.SUBRULE(_this.DataBlock);\n        });\n        _this.DataBlock = _this.RULE('DataBlock', function () {\n            log('DataBlock');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.InlineDataOneVar); } },\n                { ALT: function () { return _this.SUBRULE(_this.InlineDataFull); } },\n            ]);\n        });\n        _this.InlineDataOneVar = _this.RULE('InlineDataOneVar', function () {\n            log('InlineDataOneVar');\n            _this.SUBRULE(_this.Var);\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.MANY(function () { return _this.SUBRULE(_this.DataBlockValue); });\n            _this.CONSUME(sparqlTokenMap.RCurly);\n        });\n        _this.InlineDataFull = _this.RULE('InlineDataFull', function () {\n            log('InlineDataFull');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.NIL); } },\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.LParen);\n                        _this.MANY(function () { return _this.SUBRULE(_this.Var); });\n                        _this.CONSUME(sparqlTokenMap.RParen);\n                    },\n                },\n            ]);\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.MANY1(function () {\n                return _this.OR1([\n                    {\n                        ALT: function () {\n                            _this.CONSUME1(sparqlTokenMap.LParen);\n                            _this.MANY2(function () { return _this.SUBRULE(_this.DataBlockValue); });\n                            _this.CONSUME1(sparqlTokenMap.RParen);\n                        },\n                    },\n                    { ALT: function () { return _this.CONSUME1(sparqlTokenMap.NIL); } },\n                ]);\n            });\n            _this.CONSUME(sparqlTokenMap.RCurly);\n        });\n        _this.DataBlockValue = _this.RULE('DataBlockValue', function () {\n            log('DataBlockValue');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.RDFLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.BooleanLiteral); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.UNDEF); } },\n            ]);\n        });\n        _this.MinusGraphPattern = _this.RULE('MinusGraphPattern', function () {\n            log('MinusGraphPattern');\n            _this.CONSUME(sparqlTokenMap.MINUS);\n            _this.SUBRULE(_this.GroupGraphPattern);\n        });\n        _this.GroupOrUnionGraphPattern = _this.RULE('GroupOrUnionGraphPattern', function () {\n            log('GroupOrUnionGraphPattern');\n            _this.SUBRULE(_this.GroupGraphPattern);\n            _this.MANY(function () {\n                _this.CONSUME(sparqlTokenMap.UNION);\n                _this.SUBRULE1(_this.GroupGraphPattern);\n            });\n        });\n        _this.Filter = _this.RULE('Filter', function () {\n            log('Filter');\n            _this.CONSUME(sparqlTokenMap.FILTER);\n            _this.SUBRULE(_this.Constraint);\n        });\n        _this.Constraint = _this.RULE('Constraint', function () {\n            log('Constraint');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.BrackettedExpression); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall); } },\n                { ALT: function () { return _this.SUBRULE(_this.FunctionCall); } },\n            ]);\n        });\n        _this.FunctionCall = _this.RULE('FunctionCall', function () {\n            log('FunctionCall');\n            _this.SUBRULE(_this.iri);\n            _this.SUBRULE(_this.ArgList);\n        });\n        _this.ArgList = _this.RULE('ArgList', function () {\n            log('ArgList');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.NIL); } },\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.LParen);\n                        _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.DISTINCT); });\n                        _this.SUBRULE(_this.Expression);\n                        _this.MANY(function () {\n                            _this.CONSUME(sparqlTokenMap.Comma);\n                            _this.SUBRULE1(_this.Expression);\n                        });\n                        _this.CONSUME(sparqlTokenMap.RParen);\n                    },\n                },\n            ]);\n        });\n        _this.ExpressionList = _this.RULE('ExpressionList', function () {\n            log('ExpressionList');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.NIL); } },\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.LParen);\n                        _this.SUBRULE(_this.Expression);\n                        _this.MANY(function () {\n                            _this.CONSUME(sparqlTokenMap.Comma);\n                            _this.SUBRULE1(_this.Expression);\n                        });\n                        _this.CONSUME(sparqlTokenMap.RParen);\n                    },\n                },\n            ]);\n        });\n        _this.ConstructTemplate = _this.RULE('ConstructTemplate', function () {\n            log('ConstructTemplate');\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.OPTION(function () { return _this.SUBRULE(_this.ConstructTriples); });\n            _this.CONSUME(sparqlTokenMap.RCurly);\n        });\n        _this.ConstructTriples = _this.RULE('ConstructTriples', function () {\n            log('ConstructTriples');\n            _this.SUBRULE(_this.TriplesSameSubject);\n            _this.OPTION(function () {\n                _this.CONSUME(sparqlTokenMap.Period);\n                _this.OPTION1(function () { return _this.SUBRULE(_this.ConstructTriples); });\n            });\n        });\n        _this.TriplesSameSubject = _this.RULE('TriplesSameSubject', function () {\n            log('TriplesSameSubject');\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.VarOrTerm);\n                        _this.SUBRULE(_this.PropertyListNotEmpty);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.TriplesNode);\n                        _this.SUBRULE(_this.PropertyList);\n                    },\n                },\n            ]);\n        });\n        _this.PropertyList = _this.RULE('PropertyList', function () {\n            log('PropertyList');\n            _this.OPTION(function () { return _this.SUBRULE(_this.PropertyListNotEmpty); });\n        });\n        _this.PropertyListNotEmpty = _this.RULE('PropertyListNotEmpty', function () {\n            log('PropertyListNotEmpty');\n            _this.SUBRULE(_this.Verb);\n            _this.SUBRULE(_this.ObjectList);\n            _this.MANY(function () {\n                _this.CONSUME(sparqlTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.SUBRULE1(_this.Verb);\n                    _this.SUBRULE1(_this.ObjectList);\n                });\n            });\n        });\n        _this.Verb = _this.RULE('Verb', function () {\n            log('Verb');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.VarOrIri); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.A); } },\n            ]);\n        });\n        _this.ObjectList = _this.RULE('ObjectList', function () {\n            log('ObjectList');\n            _this.AT_LEAST_ONE_SEP({\n                SEP: sparqlTokenMap.Comma,\n                DEF: function () { return _this.SUBRULE(_this.Object); },\n            });\n        });\n        _this.Object = _this.RULE('Object', function () {\n            log('Object');\n            _this.SUBRULE(_this.GraphNode);\n        });\n        _this.TriplesSameSubjectPath = _this.RULE('TriplesSameSubjectPath', function () {\n            log('TriplesSameSubjectPath');\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.VarOrTerm);\n                        _this.SUBRULE(_this.PropertyListPathNotEmpty);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.TriplesNodePath);\n                        _this.SUBRULE(_this.PropertyListPath);\n                    },\n                },\n            ]);\n        });\n        _this.PropertyListPath = _this.RULE('PropertyListPath', function () {\n            log('PropertyListPath');\n            _this.OPTION(function () { return _this.SUBRULE(_this.PropertyListPathNotEmpty); });\n        });\n        _this.PropertyListPathNotEmpty = _this.RULE('PropertyListPathNotEmpty', function () {\n            log('PropertyListPathNotEmpty');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.VerbPath); } },\n                { ALT: function () { return _this.SUBRULE(_this.VerbSimple); } },\n            ]);\n            _this.SUBRULE(_this.ObjectListPath);\n            _this.MANY(function () {\n                _this.CONSUME(sparqlTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.OR1([\n                        { ALT: function () { return _this.SUBRULE1(_this.VerbPath); } },\n                        { ALT: function () { return _this.SUBRULE1(_this.VerbSimple); } },\n                    ]);\n                    _this.SUBRULE1(_this.ObjectListPath);\n                });\n            });\n        });\n        _this.VerbPath = _this.RULE('VerbPath', function () {\n            log('VerbPath');\n            _this.SUBRULE(_this.Path);\n        });\n        _this.VerbSimple = _this.RULE('VerbSimple', function () {\n            log('VerbSimple');\n            _this.SUBRULE(_this.Var);\n        });\n        _this.ObjectListPath = _this.RULE('ObjectListPath', function () {\n            log('ObjectListPath');\n            _this.AT_LEAST_ONE_SEP({\n                SEP: sparqlTokenMap.Comma,\n                DEF: function () { return _this.SUBRULE(_this.ObjectPath); },\n            });\n        });\n        _this.ObjectPath = _this.RULE('ObjectPath', function () {\n            log('ObjectPath');\n            _this.SUBRULE(_this.GraphNodePath);\n        });\n        _this.Path = _this.RULE('Path', function () {\n            log('Path');\n            _this.SUBRULE(_this.PathAlternative);\n        });\n        _this.PathAlternative = _this.RULE('PathAlternative', function () {\n            log('PathAlternative');\n            _this.AT_LEAST_ONE_SEP({\n                SEP: sparqlTokenMap.Pipe,\n                DEF: function () { return _this.SUBRULE(_this.PathSequence); },\n            });\n        });\n        _this.PathSequence = _this.RULE('PathSequence', function () {\n            log('PathSequence');\n            _this.AT_LEAST_ONE_SEP({\n                SEP: sparqlTokenMap.ForwardSlash,\n                DEF: function () { return _this.SUBRULE(_this.PathEltOrInverse); },\n            });\n        });\n        _this.PathElt = _this.RULE('PathElt', function () {\n            log('PathElt');\n            _this.SUBRULE(_this.PathPrimary);\n            _this.OPTION(function () { return _this.SUBRULE(_this.PathMod); });\n        });\n        _this.PathEltOrInverse = _this.RULE('PathEltOrInverse', function () {\n            log('PathEltOrInverse');\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.Caret); });\n            _this.SUBRULE(_this.PathElt);\n        });\n        _this.PathMod = _this.RULE('PathMod', function () {\n            log('PathMod');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.QuestionMark); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.Star); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.Plus); } },\n            ]);\n        });\n        _this.PathPrimary = _this.RULE('PathPrimary', function () {\n            log('PathPrimary');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.A); } },\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.Bang);\n                        _this.SUBRULE(_this.PathNegatedPropertySet);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.LParen);\n                        _this.SUBRULE(_this.Path);\n                        _this.CONSUME(sparqlTokenMap.RParen);\n                    },\n                },\n            ]);\n        });\n        _this.PathNegatedPropertySet = _this.RULE('PathNegatedPropertySet', function () {\n            log('PathNegatedPropertySet');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.PathOneInPropertySet); } },\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.LParen);\n                        _this.MANY_SEP({\n                            SEP: sparqlTokenMap.Pipe,\n                            DEF: function () { return _this.SUBRULE1(_this.PathOneInPropertySet); },\n                        });\n                        _this.CONSUME(sparqlTokenMap.RParen);\n                    },\n                },\n            ]);\n        });\n        _this.PathOneInPropertySet = _this.RULE('PathOneInPropertySet', function () {\n            log('PathOneInPropertySet');\n            _this.OPTION(function () { return _this.CONSUME(sparqlTokenMap.Caret); });\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.A); } },\n            ]);\n        });\n        _this.Integer = _this.RULE('Integer', function () {\n            log('Integer');\n            _this.CONSUME(sparqlTokenMap.INTEGER);\n        });\n        _this.TriplesNode = _this.RULE('TriplesNode', function () {\n            log('TriplesNode');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.Collection); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNodePropertyList); } },\n            ]);\n        });\n        _this.BlankNodePropertyList = _this.RULE('BlankNodePropertyList', function () {\n            log('BlankNodePropertyList');\n            _this.CONSUME(sparqlTokenMap.LBracket);\n            _this.SUBRULE(_this.PropertyListNotEmpty);\n            _this.CONSUME(sparqlTokenMap.RBracket);\n        });\n        _this.TriplesNodePath = _this.RULE('TriplesNodePath', function () {\n            log('TriplesNodePath');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.CollectionPath); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNodePropertyListPath); } },\n            ]);\n        });\n        _this.BlankNodePropertyListPath = _this.RULE('BlankNodePropertyListPath', function () {\n            log('BlankNodePropertyListPath');\n            _this.CONSUME(sparqlTokenMap.LBracket);\n            _this.SUBRULE(_this.PropertyListPathNotEmpty);\n            _this.CONSUME(sparqlTokenMap.RBracket);\n        });\n        _this.Collection = _this.RULE('Collection', function () {\n            log('Collection');\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.AT_LEAST_ONE(function () { return _this.SUBRULE(_this.GraphNode); });\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.CollectionPath = _this.RULE('CollectionPath', function () {\n            log('CollectionPath');\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.AT_LEAST_ONE(function () { return _this.SUBRULE(_this.GraphNodePath); });\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.GraphNode = _this.RULE('GraphNode', function () {\n            log('GraphNode');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.VarOrTerm); } },\n                { ALT: function () { return _this.SUBRULE(_this.TriplesNode); } },\n            ]);\n        });\n        _this.GraphNodePath = _this.RULE('GraphNodePath', function () {\n            log('GraphNodePath');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.VarOrTerm); } },\n                { ALT: function () { return _this.SUBRULE(_this.TriplesNodePath); } },\n            ]);\n        });\n        _this.VarOrTerm = _this.RULE('VarOrTerm', function () {\n            log('VarOrTerm');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.Var); } },\n                { ALT: function () { return _this.SUBRULE(_this.GraphTerm); } },\n            ]);\n        });\n        _this.VarOrIri = _this.RULE('VarOrIri', function () {\n            log('VarOrIri');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.Var); } },\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n            ]);\n        });\n        _this.Var = _this.RULE('Var', function () {\n            log('Var');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.VAR1); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.VAR2); } },\n            ]);\n        });\n        _this.GraphTerm = _this.RULE('GraphTerm', function () {\n            log('GraphTerm');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.RDFLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.BooleanLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNode); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.NIL); } },\n            ]);\n        });\n        _this.Expression = _this.RULE('Expression', function () {\n            log('Expression');\n            _this.SUBRULE(_this.ConditionalOrExpression);\n        });\n        _this.ConditionalOrExpression = _this.RULE('ConditionalOrExpression', function () {\n            log('ConditionalOrExpression');\n            _this.AT_LEAST_ONE_SEP({\n                SEP: sparqlTokenMap.LogicalOr,\n                DEF: function () { return _this.SUBRULE(_this.ConditionalAndExpression); },\n            });\n        });\n        _this.ConditionalAndExpression = _this.RULE('ConditionalAndExpression', function () {\n            log('ConditionalAndExpression');\n            _this.AT_LEAST_ONE_SEP({\n                SEP: sparqlTokenMap.LogicalAnd,\n                DEF: function () { return _this.SUBRULE(_this.ValueLogical); },\n            });\n        });\n        _this.ValueLogical = _this.RULE('ValueLogical', function () {\n            log('ValueLogical');\n            _this.SUBRULE(_this.RelationalExpression);\n        });\n        _this.RelationalExpression = _this.RULE('RelationalExpression', function () {\n            log('RelationalExpression');\n            _this.SUBRULE(_this.NumericExpression);\n            _this.OPTION(function () {\n                return _this.OR([\n                    {\n                        ALT: function () {\n                            _this.OR1([\n                                { ALT: function () { return _this.CONSUME(sparqlTokenMap.Equals); } },\n                                { ALT: function () { return _this.CONSUME(sparqlTokenMap.NotEquals); } },\n                                { ALT: function () { return _this.CONSUME(sparqlTokenMap.LessThan); } },\n                                { ALT: function () { return _this.CONSUME(sparqlTokenMap.GreaterThan); } },\n                                { ALT: function () { return _this.CONSUME(sparqlTokenMap.LessThanEquals); } },\n                                { ALT: function () { return _this.CONSUME(sparqlTokenMap.GreaterThanEquals); } },\n                            ]);\n                            _this.SUBRULE1(_this.NumericExpression);\n                        },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(sparqlTokenMap.IN);\n                            _this.SUBRULE(_this.ExpressionList);\n                        },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(sparqlTokenMap.NOT_IN);\n                            _this.SUBRULE1(_this.ExpressionList);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.NumericExpression = _this.RULE('NumericExpression', function () {\n            log('NumericExpression');\n            _this.SUBRULE(_this.AdditiveExpression);\n        });\n        _this.AdditiveExpression = _this.RULE('AdditiveExpression', function () {\n            log('AdditiveExpression');\n            _this.SUBRULE(_this.MultiplicativeExpression);\n            _this.MANY(function () {\n                return _this.OR([\n                    {\n                        ALT: function () {\n                            _this.OR1([\n                                { ALT: function () { return _this.CONSUME(sparqlTokenMap.Plus); } },\n                                { ALT: function () { return _this.CONSUME(sparqlTokenMap.Minus); } },\n                            ]);\n                            _this.SUBRULE1(_this.MultiplicativeExpression);\n                        },\n                    },\n                    {\n                        ALT: function () {\n                            _this.OR2([\n                                { ALT: function () { return _this.SUBRULE(_this.NumericLiteralPositive); } },\n                                { ALT: function () { return _this.SUBRULE(_this.NumericLiteralNegative); } },\n                            ]);\n                            _this.MANY1(function () {\n                                return _this.OR3([\n                                    {\n                                        ALT: function () {\n                                            _this.OR4([\n                                                { ALT: function () { return _this.CONSUME(sparqlTokenMap.Star); } },\n                                                {\n                                                    ALT: function () { return _this.CONSUME(sparqlTokenMap.ForwardSlash); },\n                                                },\n                                            ]);\n                                            _this.SUBRULE1(_this.UnaryExpression);\n                                        },\n                                    },\n                                ]);\n                            });\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.MultiplicativeExpression = _this.RULE('MultiplicativeExpression', function () {\n            log('MultiplicativeExpression');\n            _this.SUBRULE(_this.UnaryExpression);\n            _this.MANY(function () {\n                return _this.OR([\n                    {\n                        ALT: function () {\n                            _this.CONSUME(sparqlTokenMap.Star);\n                            _this.SUBRULE1(_this.UnaryExpression);\n                        },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(sparqlTokenMap.ForwardSlash);\n                            _this.SUBRULE2(_this.UnaryExpression);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.UnaryExpression = _this.RULE('UnaryExpression', function () {\n            log('UnaryExpression');\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.Bang);\n                        _this.SUBRULE(_this.PrimaryExpression);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.Plus);\n                        _this.SUBRULE1(_this.PrimaryExpression);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.Minus);\n                        _this.SUBRULE2(_this.PrimaryExpression);\n                    },\n                },\n                { ALT: function () { return _this.SUBRULE3(_this.PrimaryExpression); } },\n            ]);\n        });\n        _this.PrimaryExpression = _this.RULE('PrimaryExpression', function () {\n            log('PrimaryExpression');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.BrackettedExpression); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall); } },\n                { ALT: function () { return _this.SUBRULE(_this.iriOrFunction); } },\n                { ALT: function () { return _this.SUBRULE(_this.RDFLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.BooleanLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.Var); } },\n            ]);\n        });\n        _this.BrackettedExpression = _this.RULE('BrackettedExpression', function () {\n            log('BrackettedExpression');\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_STR = _this.RULE('BuiltInCall_STR', function () {\n            log('BuiltInCall_STR');\n            _this.CONSUME(sparqlTokenMap.STR);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_LANG = _this.RULE('BuiltInCall_LANG', function () {\n            log('BuiltInCall_LANG');\n            _this.CONSUME(sparqlTokenMap.LANG);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_LANGMATCHES = _this.RULE('BuiltInCall_LANGMATCHES', function () {\n            log('BuiltInCall_LANGMATCHES');\n            _this.CONSUME(sparqlTokenMap.LANGMATCHES);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_DATATYPE = _this.RULE('BuiltInCall_DATATYPE', function () {\n            log('BuiltInCall_DATATYPE');\n            _this.CONSUME(sparqlTokenMap.DATATYPE);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_BOUND = _this.RULE('BuiltInCall_BOUND', function () {\n            log('BuiltInCall_BOUND');\n            _this.CONSUME(sparqlTokenMap.BOUND);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Var);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_IRI = _this.RULE('BuiltInCall_IRI', function () {\n            log('BuiltInCall_IRI');\n            _this.CONSUME(sparqlTokenMap.IRI);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_URI = _this.RULE('BuiltInCall_URI', function () {\n            log('BuiltInCall_URI');\n            _this.CONSUME(sparqlTokenMap.URI);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_BNODE = _this.RULE('BuiltInCall_BNODE', function () {\n            log('BuiltInCall_BNODE');\n            _this.CONSUME(sparqlTokenMap.BNODE);\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.CONSUME(sparqlTokenMap.LParen);\n                        _this.SUBRULE(_this.Expression);\n                        _this.CONSUME(sparqlTokenMap.RParen);\n                    },\n                },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.NIL); } },\n            ]);\n        });\n        _this.BuiltInCall_RAND = _this.RULE('BuiltInCall_RAND', function () {\n            log('BuiltInCall_RAND');\n            _this.CONSUME(sparqlTokenMap.RAND);\n            _this.CONSUME(sparqlTokenMap.NIL);\n        });\n        _this.BuiltInCall_ABS = _this.RULE('BuiltInCall_ABS', function () {\n            log('BuiltInCall_ABS');\n            _this.CONSUME(sparqlTokenMap.ABS);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_CEIL = _this.RULE('BuiltInCall_CEIL', function () {\n            log('BuiltInCall_CEIL');\n            _this.CONSUME(sparqlTokenMap.CEIL);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_FLOOR = _this.RULE('BuiltInCall_FLOOR', function () {\n            log('BuiltInCall_FLOOR');\n            _this.CONSUME(sparqlTokenMap.FLOOR);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_ROUND = _this.RULE('BuiltInCall_ROUND', function () {\n            log('BuiltInCall_ROUND');\n            _this.CONSUME(sparqlTokenMap.ROUND);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_CONCAT = _this.RULE('BuiltInCall_CONCAT', function () {\n            log('BuiltInCall_CONCAT');\n            _this.CONSUME(sparqlTokenMap.CONCAT);\n            _this.SUBRULE(_this.ExpressionList);\n        });\n        _this.BuiltInCall_STRLEN = _this.RULE('BuiltInCall_STRLEN', function () {\n            log('BuiltInCall_STRLEN');\n            _this.CONSUME(sparqlTokenMap.STRLEN);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_UCASE = _this.RULE('BuiltInCall_UCASE', function () {\n            log('BuiltInCall_UCASE');\n            _this.CONSUME(sparqlTokenMap.UCASE);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_LCASE = _this.RULE('BuiltInCall_LCASE', function () {\n            log('BuiltInCall_LCASE');\n            _this.CONSUME(sparqlTokenMap.LCASE);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_ENCODE_FOR_URI = _this.RULE('BuiltInCall_ENCODE_FOR_URI', function () {\n            log('BuiltInCall_ENCODE_FOR_URI');\n            _this.CONSUME(sparqlTokenMap.ENCODE_FOR_URI);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_CONTAINS = _this.RULE('BuiltInCall_CONTAINS', function () {\n            log('BuiltInCall_CONTAINS');\n            _this.CONSUME(sparqlTokenMap.CONTAINS);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_STRSTARTS = _this.RULE('BuiltInCall_STRSTARTS', function () {\n            log('BuiltInCall_STRSTARTS');\n            _this.CONSUME(sparqlTokenMap.STRSTARTS);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_STRENDS = _this.RULE('BuiltInCall_STRENDS', function () {\n            log('BuiltInCall_STRENDS');\n            _this.CONSUME(sparqlTokenMap.STRENDS);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_STRBEFORE = _this.RULE('BuiltInCall_STRBEFORE', function () {\n            log('BuiltInCall_STRBEFORE');\n            _this.CONSUME(sparqlTokenMap.STRBEFORE);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_STRAFTER = _this.RULE('BuiltInCall_STRAFTER', function () {\n            log('BuiltInCall_STRAFTER');\n            _this.CONSUME(sparqlTokenMap.STRAFTER);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_YEAR = _this.RULE('BuiltInCall_YEAR', function () {\n            log('BuiltInCall_YEAR');\n            _this.CONSUME(sparqlTokenMap.YEAR);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_MONTH = _this.RULE('BuiltInCall_MONTH', function () {\n            log('BuiltInCall_MONTH');\n            _this.CONSUME(sparqlTokenMap.MONTH);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_DAY = _this.RULE('BuiltInCall_DAY', function () {\n            log('BuiltInCall_DAY');\n            _this.CONSUME(sparqlTokenMap.DAY);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_HOURS = _this.RULE('BuiltInCall_HOURS', function () {\n            log('BuiltInCall_HOURS');\n            _this.CONSUME(sparqlTokenMap.HOURS);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_MINUTES = _this.RULE('BuiltInCall_MINUTES', function () {\n            log('BuiltInCall_MINUTES');\n            _this.CONSUME(sparqlTokenMap.MINUTES);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_SECONDS = _this.RULE('BuiltInCall_SECONDS', function () {\n            log('BuiltInCall_SECONDS');\n            _this.CONSUME(sparqlTokenMap.SECONDS);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_TIMEZONE = _this.RULE('BuiltInCall_TIMEZONE', function () {\n            log('BuiltInCall_TIMEZONE');\n            _this.CONSUME(sparqlTokenMap.TIMEZONE);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_TZ = _this.RULE('BuiltInCall_TZ', function () {\n            log('BuiltInCall_TZ');\n            _this.CONSUME(sparqlTokenMap.TZ);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_NOW = _this.RULE('BuiltInCall_NOW', function () {\n            log('BuiltInCall_NOW');\n            _this.CONSUME(sparqlTokenMap.NOW);\n            _this.CONSUME(sparqlTokenMap.NIL);\n        });\n        _this.BuiltInCall_UUID = _this.RULE('BuiltInCall_UUID', function () {\n            log('BuiltInCall_UUID');\n            _this.CONSUME(sparqlTokenMap.UUID);\n            _this.CONSUME(sparqlTokenMap.NIL);\n        });\n        _this.BuiltInCall_STRUUID = _this.RULE('BuiltInCall_STRUUID', function () {\n            log('BuiltInCall_STRUUID');\n            _this.CONSUME(sparqlTokenMap.STRUUID);\n            _this.CONSUME(sparqlTokenMap.NIL);\n        });\n        _this.BuiltInCall_MD5 = _this.RULE('BuiltInCall_MD5', function () {\n            log('BuiltInCall_MD5');\n            _this.CONSUME(sparqlTokenMap.MD5);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_SHA1 = _this.RULE('BuiltInCall_SHA1', function () {\n            log('BuiltInCall_SHA1');\n            _this.CONSUME(sparqlTokenMap.SHA1);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_SHA256 = _this.RULE('BuiltInCall_SHA256', function () {\n            log('BuiltInCall_SHA256');\n            _this.CONSUME(sparqlTokenMap.SHA256);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_SHA384 = _this.RULE('BuiltInCall_SHA384', function () {\n            log('BuiltInCall_SHA384');\n            _this.CONSUME(sparqlTokenMap.SHA384);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_SHA512 = _this.RULE('BuiltInCall_SHA512', function () {\n            log('BuiltInCall_SHA512');\n            _this.CONSUME(sparqlTokenMap.SHA512);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_COALESCE = _this.RULE('BuiltInCall_COALESCE', function () {\n            log('BuiltInCall_COALESCE');\n            _this.CONSUME(sparqlTokenMap.COALESCE);\n            _this.SUBRULE(_this.ExpressionList);\n        });\n        _this.BuiltInCall_IF = _this.RULE('BuiltInCall_IF', function () {\n            log('BuiltInCall_IF');\n            _this.CONSUME(sparqlTokenMap.IF);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME1(sparqlTokenMap.Comma);\n            _this.SUBRULE2(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_STRLANG = _this.RULE('BuiltInCall_STRLANG', function () {\n            log('BuiltInCall_STRLANG');\n            _this.CONSUME(sparqlTokenMap.STRLANG);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_STRDT = _this.RULE('BuiltInCall_STRDT', function () {\n            log('BuiltInCall_STRDT');\n            _this.CONSUME(sparqlTokenMap.STRDT);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_sameTerm = _this.RULE('BuiltInCall_sameTerm', function () {\n            log('BuiltInCall_sameTerm');\n            _this.CONSUME(sparqlTokenMap.sameTerm);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_isIRI = _this.RULE('BuiltInCall_isIRI', function () {\n            log('BuiltInCall_isIRI');\n            _this.CONSUME(sparqlTokenMap.isIRI);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_isURI = _this.RULE('BuiltInCall_isURI', function () {\n            log('BuiltInCall_isURI');\n            _this.CONSUME(sparqlTokenMap.isURI);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_isBLANK = _this.RULE('BuiltInCall_isBLANK', function () {\n            log('BuiltInCall_isBLANK');\n            _this.CONSUME(sparqlTokenMap.isBLANK);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_isLITERAL = _this.RULE('BuiltInCall_isLITERAL', function () {\n            log('BuiltInCall_isLITERAL');\n            _this.CONSUME(sparqlTokenMap.isLITERAL);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall_isNUMERIC = _this.RULE('BuiltInCall_isNUMERIC', function () {\n            log('BuiltInCall_isNUMERIC');\n            _this.CONSUME(sparqlTokenMap.isNUMERIC);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.BuiltInCall = _this.RULE('BuiltInCall', function () {\n            log('BuiltInCall');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.Aggregate); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STR); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_LANG); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_LANGMATCHES); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_DATATYPE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_BOUND); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_IRI); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_URI); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_BNODE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_RAND); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_ABS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_CEIL); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_FLOOR); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_ROUND); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_CONCAT); } },\n                { ALT: function () { return _this.SUBRULE(_this.SubstringExpression); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRLEN); } },\n                { ALT: function () { return _this.SUBRULE(_this.StrReplaceExpression); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_UCASE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_LCASE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_ENCODE_FOR_URI); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_CONTAINS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRSTARTS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRENDS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRBEFORE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRAFTER); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_YEAR); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_MONTH); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_DAY); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_HOURS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_MINUTES); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_SECONDS); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_TIMEZONE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_TZ); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_NOW); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_UUID); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRUUID); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_MD5); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_SHA1); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_SHA256); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_SHA384); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_SHA512); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_COALESCE); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_IF); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRLANG); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_STRDT); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_sameTerm); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_isIRI); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_isURI); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_isBLANK); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_isLITERAL); } },\n                { ALT: function () { return _this.SUBRULE(_this.BuiltInCall_isNUMERIC); } },\n                { ALT: function () { return _this.SUBRULE(_this.RegexExpression); } },\n                { ALT: function () { return _this.SUBRULE(_this.ExistsFunction); } },\n                { ALT: function () { return _this.SUBRULE(_this.NotExistsFunction); } },\n            ]);\n        });\n        _this.RegexExpression = _this.RULE('RegexExpression', function () {\n            log('RegexExpression');\n            _this.CONSUME(sparqlTokenMap.REGEX);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.OPTION(function () {\n                _this.CONSUME1(sparqlTokenMap.Comma);\n                _this.SUBRULE2(_this.Expression);\n            });\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.SubstringExpression = _this.RULE('SubstringExpression', function () {\n            log('SubstringExpression');\n            _this.CONSUME(sparqlTokenMap.SUBSTR);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.OPTION(function () {\n                _this.CONSUME1(sparqlTokenMap.Comma);\n                _this.SUBRULE2(_this.Expression);\n            });\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.StrReplaceExpression = _this.RULE('StrReplaceExpression', function () {\n            log('StrReplaceExpression');\n            _this.CONSUME(sparqlTokenMap.REPLACE);\n            _this.CONSUME(sparqlTokenMap.LParen);\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.Comma);\n            _this.SUBRULE1(_this.Expression);\n            _this.CONSUME1(sparqlTokenMap.Comma);\n            _this.SUBRULE2(_this.Expression);\n            _this.OPTION(function () {\n                _this.CONSUME2(sparqlTokenMap.Comma);\n                _this.SUBRULE3(_this.Expression);\n            });\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.ExistsFunction = _this.RULE('ExistsFunction', function () {\n            log('ExistsFunction');\n            _this.CONSUME(sparqlTokenMap.EXISTS);\n            _this.SUBRULE(_this.GroupGraphPattern);\n        });\n        _this.NotExistsFunction = _this.RULE('NotExistsFunction', function () {\n            log('NotExistsFunction');\n            _this.CONSUME(sparqlTokenMap.NOT_EXISTS);\n            _this.SUBRULE(_this.GroupGraphPattern);\n        });\n        _this.Count = _this.RULE('Count', function () {\n            log('Count');\n            _this.CONSUME(sparqlTokenMap.COUNT);\n            _this.CONSUME1(sparqlTokenMap.LParen);\n            _this.OPTION(function () { return _this.CONSUME2(sparqlTokenMap.DISTINCT); });\n            _this.OR([\n                { ALT: function () { return _this.CONSUME3(sparqlTokenMap.Star); } },\n                { ALT: function () { return _this.SUBRULE(_this.Expression); } },\n            ]);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.Sum = _this.RULE('Sum', function () {\n            log('Sum');\n            _this.CONSUME(sparqlTokenMap.SUM);\n            _this.CONSUME1(sparqlTokenMap.LParen);\n            _this.OPTION(function () { return _this.CONSUME2(sparqlTokenMap.DISTINCT); });\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.Min = _this.RULE('Min', function () {\n            log('Min');\n            _this.CONSUME(sparqlTokenMap.MIN);\n            _this.CONSUME1(sparqlTokenMap.LParen);\n            _this.OPTION(function () { return _this.CONSUME2(sparqlTokenMap.DISTINCT); });\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.Max = _this.RULE('Max', function () {\n            log('Max');\n            _this.CONSUME(sparqlTokenMap.MAX);\n            _this.CONSUME1(sparqlTokenMap.LParen);\n            _this.OPTION(function () { return _this.CONSUME2(sparqlTokenMap.DISTINCT); });\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.Avg = _this.RULE('Avg', function () {\n            log('Avg');\n            _this.CONSUME(sparqlTokenMap.AVG);\n            _this.CONSUME1(sparqlTokenMap.LParen);\n            _this.OPTION(function () { return _this.CONSUME2(sparqlTokenMap.DISTINCT); });\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.Sample = _this.RULE('Sample', function () {\n            log('Sample');\n            _this.CONSUME(sparqlTokenMap.SAMPLE);\n            _this.CONSUME1(sparqlTokenMap.LParen);\n            _this.OPTION(function () { return _this.CONSUME2(sparqlTokenMap.DISTINCT); });\n            _this.SUBRULE(_this.Expression);\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.GroupConcat = _this.RULE('GroupConcat', function () {\n            log('GroupConcat');\n            _this.CONSUME(sparqlTokenMap.GROUP_CONCAT);\n            _this.CONSUME1(sparqlTokenMap.LParen);\n            _this.OPTION(function () { return _this.CONSUME2(sparqlTokenMap.DISTINCT); });\n            _this.SUBRULE(_this.Expression);\n            _this.OPTION1(function () {\n                _this.CONSUME(sparqlTokenMap.Semicolon);\n                _this.CONSUME(sparqlTokenMap.SEPARATOR);\n                _this.CONSUME(sparqlTokenMap.Equals);\n                _this.SUBRULE(_this.String);\n            });\n            _this.CONSUME(sparqlTokenMap.RParen);\n        });\n        _this.Aggregate = _this.RULE('Aggregate', function () {\n            log('Aggregate');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.Count); } },\n                { ALT: function () { return _this.SUBRULE(_this.Sum); } },\n                { ALT: function () { return _this.SUBRULE(_this.Min); } },\n                { ALT: function () { return _this.SUBRULE(_this.Max); } },\n                { ALT: function () { return _this.SUBRULE(_this.Avg); } },\n                { ALT: function () { return _this.SUBRULE(_this.Sample); } },\n                { ALT: function () { return _this.SUBRULE(_this.GroupConcat); } },\n            ]);\n        });\n        _this.iriOrFunction = _this.RULE('iriOrFunction', function () {\n            log('iriOrFunction');\n            _this.SUBRULE(_this.iri);\n            _this.OPTION(function () { return _this.SUBRULE(_this.ArgList); });\n        });\n        _this.RDFLiteral = _this.RULE('RDFLiteral', function () {\n            log('RDFLiteral');\n            _this.SUBRULE(_this.String);\n            _this.OPTION(function () {\n                return _this.OR([\n                    { ALT: function () { return _this.CONSUME(sparqlTokenMap.LANGTAG); } },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(sparqlTokenMap.DoubleCaret);\n                            _this.SUBRULE(_this.iri);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.NumericLiteral = _this.RULE('NumericLiteral', function () {\n            log('NumericLiteral');\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteralUnsigned); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteralPositive); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteralNegative); } },\n            ]);\n        });\n        _this.NumericLiteralUnsigned = _this.RULE('NumericLiteralUnsigned', function () {\n            log('NumericLiteralUnsigned');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.INTEGER); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.DECIMAL); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.DOUBLE); } },\n            ]);\n        });\n        _this.NumericLiteralPositive = _this.RULE('NumericLiteralPositive', function () {\n            log('NumericLiteralPositive');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.INTEGER_POSITIVE); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.DECIMAL_POSITIVE); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.DOUBLE_POSITIVE); } },\n            ]);\n        });\n        _this.NumericLiteralNegative = _this.RULE('NumericLiteralNegative', function () {\n            log('NumericLiteralNegative');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.INTEGER_NEGATIVE); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.DECIMAL_NEGATIVE); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.DOUBLE_NEGATIVE); } },\n            ]);\n        });\n        _this.BooleanLiteral = _this.RULE('BooleanLiteral', function () {\n            log('BooleanLiteral');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.TRUE); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.FALSE); } },\n            ]);\n        });\n        _this.String = _this.RULE('String', function () {\n            log('String');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.STRING_LITERAL1); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.STRING_LITERAL2); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.STRING_LITERAL_LONG1); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.STRING_LITERAL_LONG2); } },\n            ]);\n        });\n        _this.iri = _this.RULE('iri', function () {\n            log('iri');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.IRIREF); } },\n                { ALT: function () { return _this.SUBRULE(_this.PrefixedName); } },\n            ]);\n        });\n        _this.PrefixedName = _this.RULE('PrefixedName', function () {\n            log('PrefixedName');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.PNAME_LN); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.PNAME_NS); } },\n            ]);\n        });\n        _this.BlankNode = _this.RULE('BlankNode', function () {\n            log('BlankNode');\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.BLANK_NODE_LABEL); } },\n                { ALT: function () { return _this.CONSUME(sparqlTokenMap.ANON); } },\n            ]);\n        });\n        _this.lexer = new Lexer(tokenVocab);\n        return _this;\n    }\n    return BaseSparqlParser;\n}(Parser));\nexport { BaseSparqlParser };\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexport var traverse = function (root, visit) {\n    _traverse(root, null, visit);\n};\nexport var unsafeTraverse = function (root, visit) {\n    _traverse(root, null, visit, false);\n};\nexport function isCstNode(object) {\n    return Boolean(object && 'name' in object);\n}\nvar TraverseContext = /** @class */ (function () {\n    function TraverseContext(_a) {\n        var node = _a.node, parentCtx = _a.parentCtx;\n        this.node = __assign({}, node);\n        this.parentCtx = __assign({}, parentCtx);\n    }\n    return TraverseContext;\n}());\nvar _traverse = function (root, ctx, visit, visitSafely) {\n    if (ctx === void 0) { ctx = new TraverseContext({ node: root }); }\n    if (visitSafely === void 0) { visitSafely = true; }\n    if (!isCstNode(root)) {\n        // must be a token\n        return visit(visitSafely ? __assign({}, ctx) : ctx);\n    }\n    // is a grammar rule node\n    var children = root.children;\n    Object.keys(children).forEach(function (key) {\n        var childType = children[key];\n        if (!childType.length) {\n            return;\n        }\n        childType.forEach(function (child) {\n            var childCtx = visitSafely\n                ? new TraverseContext({ node: child, parentCtx: ctx })\n                : { node: child, parentCtx: ctx };\n            var afterVisit = function (transformedCtx) {\n                var nextCtx = childCtx;\n                if (transformedCtx) {\n                    nextCtx = visitSafely\n                        ? new TraverseContext({\n                            node: transformedCtx.node,\n                            parentCtx: transformedCtx.parentCtx,\n                        })\n                        : {\n                            node: transformedCtx.node,\n                            parentCtx: transformedCtx.parentCtx,\n                        };\n                }\n                _traverse(child, nextCtx, visit, visitSafely);\n            };\n            visit(childCtx, afterVisit);\n        });\n    });\n};\n","/*\nCopyright 20122018 Ruben Verborgh\nWith modifications Copyright 2018 Stardog Union\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nvar escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\[uU]|\\\\(.)/g;\nvar escapeReplacements = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\"': '\"',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    f: '\\f',\n    b: '\\b',\n    _: '_',\n    '~': '~',\n    '.': '.',\n    '-': '-',\n    '!': '!',\n    $: '$',\n    '&': '&',\n    '(': '(',\n    ')': ')',\n    '*': '*',\n    '+': '+',\n    ',': ',',\n    ';': ';',\n    '=': '=',\n    '/': '/',\n    '?': '?',\n    '#': '#',\n    '@': '@',\n    '%': '%',\n};\nexport var unescapedStringLiteralQuote = /^\"([^\"\\\\\\r\\n]+)\"/; // non-empty string without escape sequences\nexport var unescapedStringLiteralSingleQuote = /^'([^'\\\\\\r\\n]+)'/;\nexport var stringLiteralQuote = /^\"((?:[^\"\\\\\\r\\n]|\\\\.)*)\"(?=[^\"])/;\nexport var stringLiteralSingleQuote = /^'((?:[^'\\\\\\r\\n]|\\\\.)*)'(?=[^'])/;\nexport var stringLiteralLongQuote = /^\"\"\"([^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*)\"\"\"/;\nexport var stringLiteralLongSingleQuote = /^'''([^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*)'''/;\nexport var illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\nexport var escapedIri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/;\nexport var unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/;\n// Handle special unescaping needs related to the IRIREF rule and others.\nexport var unescape = function (item) {\n    try {\n        return item.replace(escapeSequence, function (_, unicode4, unicode8, escapedChar) {\n            if (unicode4) {\n                return String.fromCharCode(parseInt(unicode4, 16));\n            }\n            else if (unicode8) {\n                var charCode = parseInt(unicode8, 16);\n                if (charCode <= 0xffff) {\n                    return String.fromCharCode(charCode);\n                }\n                return String.fromCharCode(0xd800 + (charCode -= 0x10000) / 0x400, 0xdc00 + (charCode & 0x3ff));\n            }\n            else {\n                var replacement = escapeReplacements[escapedChar];\n                if (!replacement) {\n                    throw new Error();\n                }\n                return replacement;\n            }\n        });\n    }\n    catch (error) {\n        return null;\n    }\n};\n","var sparqlTokenMap = require('../sparql/tokens').sparqlTokenMap;\nimport { createToken } from 'chevrotain';\nimport { regex } from '../helpers/regex';\nimport { EXPONENT, ECHAR, PLX, HEX, PN_CHARS_BASE, PN_CHARS_U, PN_CHARS, PN_PREFIX, PN_LOCAL, PN_LOCAL_ESC, } from '../helpers/matchers';\nimport { unescape, stringLiteralLongSingleQuote, stringLiteralLongQuote, unescapedStringLiteralQuote, stringLiteralQuote, unescapedStringLiteralSingleQuote, stringLiteralSingleQuote, unescapedIri, escapedIri, illegalIriChars, } from '../helpers/unescape';\nvar unicodeRegexp = /[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nexport var turtleTokenMap = {\n    Comment: createToken({\n        name: 'Comment',\n        pattern: /#[^\\n]*/,\n        group: 'comments',\n    }),\n    LBracket: sparqlTokenMap.LBracket,\n    RBracket: sparqlTokenMap.RBracket,\n    LCurly: sparqlTokenMap.LCurly,\n    RCurly: sparqlTokenMap.RCurly,\n    LParen: sparqlTokenMap.LParen,\n    RParen: sparqlTokenMap.RParen,\n    Period: sparqlTokenMap.Period,\n    WhiteSpace: sparqlTokenMap.WhiteSpace,\n    // 'true' and 'false' are case sensitive in Turtle but not in SPARQL\n    TRUE: createToken({\n        name: 'TRUE',\n        pattern: /true/,\n    }),\n    FALSE: createToken({\n        name: 'FALSE',\n        pattern: /false/,\n    }),\n    DoubleCaret: sparqlTokenMap.DoubleCaret,\n    LEmbed: sparqlTokenMap.LEmbed,\n    REmbed: sparqlTokenMap.REmbed,\n    Comma: sparqlTokenMap.Comma,\n    Semicolon: sparqlTokenMap.Semicolon,\n    A: sparqlTokenMap.A,\n    PREFIX: sparqlTokenMap.PREFIX,\n    BASE: sparqlTokenMap.BASE,\n    PNAME_NS: sparqlTokenMap.PNAME_NS,\n    PNAME_LN: sparqlTokenMap.PNAME_LN,\n    BLANK_NODE_LABEL: sparqlTokenMap.BLANK_NODE_LABEL,\n    TTL_BASE: createToken({ name: 'TTL_BASE', pattern: /@base/ }),\n    TTL_PREFIX: createToken({ name: 'TTL_PREFIX', pattern: /@prefix/ }),\n    LANGTAG: sparqlTokenMap.LANGTAG,\n    INTEGER: createToken({\n        name: 'INTEGER',\n        pattern: regex.and(regex.option(/[+-]/), /\\d+/),\n    }),\n    DECIMAL: createToken({\n        name: 'DECIMAL',\n        pattern: regex.and(regex.option(/[+-]/), /(\\d*\\.\\d+)/),\n    }),\n    DOUBLE: createToken({\n        name: 'DOUBLE',\n        pattern: regex.and(regex.option(/[+-]/), regex.or(regex.and(/\\d+\\.\\d*/, EXPONENT), regex.and(/\\.\\d+/, EXPONENT), regex.and(/\\d+/, EXPONENT))),\n    }),\n    EXPONENT: createToken({ name: 'EXPONENT', pattern: EXPONENT }),\n    ECHAR: createToken({ name: 'ECHAR', pattern: ECHAR }),\n    ANON: sparqlTokenMap.ANON,\n    PLX: createToken({ name: 'PLX', pattern: PLX }),\n    PERCENT: sparqlTokenMap.PERCENT,\n    HEX: createToken({ name: 'HEX', pattern: HEX }),\n    STRING_LITERAL_LONG_SINGLE_QUOTE: createToken({\n        name: 'STRING_LITERAL_LONG_SINGLE_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var match = stringLiteralLongSingleQuote.exec(text.slice(startOffset));\n            if (!match || unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: true,\n    }),\n    STRING_LITERAL_LONG_QUOTE: createToken({\n        name: 'STRING_LITERAL_LONG_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var match = stringLiteralLongQuote.exec(text.slice(startOffset));\n            if (!match || unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: true,\n    }),\n    STRING_LITERAL_QUOTE: createToken({\n        name: 'STRING_LITERAL_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedStringLiteralQuote.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = stringLiteralQuote.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            if (unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    STRING_LITERAL_SINGLE_QUOTE: createToken({\n        name: 'STRING_LITERAL_SINGLE_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedStringLiteralSingleQuote.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = stringLiteralSingleQuote.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            if (unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    UCHAR: createToken({\n        name: 'UCHAR',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            return unicodeRegexp.exec(text.slice(startOffset));\n        },\n        line_breaks: false,\n    }),\n    IRIREF: createToken({\n        name: 'IRIREF',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedIri.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = escapedIri.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            var value = unescape(match[1]);\n            if (value === null || illegalIriChars.test(value)) {\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    PN_CHARS_BASE: createToken({ name: 'PN_CHARS_BASE', pattern: PN_CHARS_BASE }),\n    PN_CHARS_U: createToken({ name: 'PN_CHARS_U', pattern: PN_CHARS_U }),\n    PN_CHARS: createToken({ name: 'PN_CHARS', pattern: PN_CHARS }),\n    PN_PREFIX: createToken({ name: 'PN_PREFIX', pattern: PN_PREFIX }),\n    PN_LOCAL: createToken({ name: 'PN_LOCAL', pattern: PN_LOCAL }),\n    PN_LOCAL_ESC: createToken({ name: 'PN_LOCAL_ESC', pattern: PN_LOCAL_ESC }),\n    Unknown: createToken({\n        name: 'Unknown',\n        pattern: /\\w+/,\n    }),\n};\nexport var turtleTokenTypes = [\n    turtleTokenMap.Comment,\n    sparqlTokenMap.ANON,\n    sparqlTokenMap.LBracket,\n    sparqlTokenMap.RBracket,\n    sparqlTokenMap.LCurly,\n    sparqlTokenMap.RCurly,\n    sparqlTokenMap.LParen,\n    sparqlTokenMap.RParen,\n    sparqlTokenMap.WhiteSpace,\n    turtleTokenMap.TRUE,\n    turtleTokenMap.FALSE,\n    sparqlTokenMap.Comma,\n    sparqlTokenMap.Semicolon,\n    sparqlTokenMap.PNAME_NS,\n    sparqlTokenMap.A,\n    sparqlTokenMap.PREFIX,\n    sparqlTokenMap.BASE,\n    sparqlTokenMap.PNAME_LN,\n    sparqlTokenMap.BLANK_NODE_LABEL,\n    turtleTokenMap.TTL_BASE,\n    turtleTokenMap.TTL_PREFIX,\n    sparqlTokenMap.LANGTAG,\n    turtleTokenMap.DOUBLE,\n    turtleTokenMap.DECIMAL,\n    sparqlTokenMap.Period,\n    sparqlTokenMap.DoubleCaret,\n    turtleTokenMap.LEmbed,\n    turtleTokenMap.REmbed,\n    turtleTokenMap.IRIREF,\n    turtleTokenMap.STRING_LITERAL_LONG_SINGLE_QUOTE,\n    turtleTokenMap.STRING_LITERAL_LONG_QUOTE,\n    turtleTokenMap.STRING_LITERAL_QUOTE,\n    turtleTokenMap.STRING_LITERAL_SINGLE_QUOTE,\n    turtleTokenMap.INTEGER,\n    turtleTokenMap.EXPONENT,\n    turtleTokenMap.PLX,\n    sparqlTokenMap.PERCENT,\n    turtleTokenMap.HEX,\n    turtleTokenMap.PN_CHARS_BASE,\n    turtleTokenMap.PN_CHARS_U,\n    turtleTokenMap.PN_CHARS,\n    turtleTokenMap.PN_PREFIX,\n    turtleTokenMap.PN_LOCAL,\n    turtleTokenMap.PN_LOCAL_ESC,\n    turtleTokenMap.ECHAR,\n    turtleTokenMap.UCHAR,\n    turtleTokenMap.Unknown,\n];\n"],"sourceRoot":""}