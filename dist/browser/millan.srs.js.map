{"version":3,"sources":["webpack://millan.[name]/webpack/universalModuleDefinition","webpack://millan.[name]/webpack/bootstrap","webpack://millan.[name]/./src/turtle/TurtleParser.ts","webpack://millan.[name]/./src/sparql/W3SpecSparqlParser.ts","webpack://millan.[name]/./src/helpers/unescape.ts","webpack://millan.[name]/./src/turtle/tokens.ts","webpack://millan.[name]/./src/srs/tokens.ts","webpack://millan.[name]/./src/srs/visitor.ts","webpack://millan.[name]/./src/srs/customErrors.ts","webpack://millan.[name]/./src/turtle/defaultNamespaces.ts","webpack://millan.[name]/./src/srs/SrsParser.ts","webpack://millan.[name]/./src/srs/index.ts","webpack://millan.[name]/./src/helpers/cst.ts"],"names":["root","factory","exports","module","define","amd","self","this","webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","6","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","oldJsonpFunction","slice","__webpack_exports__","TurtleParser","extendStatics","_tokens__WEBPACK_IMPORTED_MODULE_0__","chevrotain__WEBPACK_IMPORTED_MODULE_1__","__extends","b","setPrototypeOf","__proto__","Array","__","constructor","__assign","assign","arguments","_super","config","tokens","lexerDefinition","performSelfAnalysis","_this","outputCst","recoveryEnabled","namespacesMap","semanticErrors","resetManagedState","tokenize","document","lexer","parse","input","cst","turtleDoc","errors","RULE","MANY","SUBRULE","statement","OR","ALT","directive","triples","CONSUME","Period","prefixID","base","sparqlPrefix","sparqlBase","TTL_PREFIX","pnameNsToken","PNAME_NS","iriToken","IRIREF","pnameImageWithoutColon","image","iriImage","TTL_BASE","BASE","PREFIX","subject","predicateObjectList","blankNodePropertyList","OPTION","SUBRULE1","verb","objectList","Semicolon","iri","BlankNode","collection","predicate","Comma","A","literal","RDFLiteral","NumericLiteral","BooleanLiteral","LBracket","RBracket","LParen","RParen","INTEGER","DECIMAL","DOUBLE","String","LANGTAG","DoubleCaret","TRUE","FALSE","STRING_LITERAL_QUOTE","STRING_LITERAL_SINGLE_QUOTE","STRING_LITERAL_LONG_SINGLE_QUOTE","STRING_LITERAL_LONG_QUOTE","PrefixedName","prefixedNameToken","PNAME_LN","indexOf","message","token","context","ruleStack","getHumanReadableRuleStack","ruleOccurrenceStack","RULE_OCCURRENCE_STACK","resyncedTokens","BLANK_NODE_LABEL","ANON","W3SpecSparqlParser","_BaseSparqlParser__WEBPACK_IMPORTED_MODULE_1__","chevrotain__WEBPACK_IMPORTED_MODULE_2__","options","escapeSequence","escapeReplacements","\\","'","\"","f","_","~",".","-","!","$","&","(",")","*","+",",",";","=","/","?","#","@","%","unescapedStringLiteralQuote","unescapedStringLiteralSingleQuote","stringLiteralQuote","stringLiteralSingleQuote","stringLiteralLongQuote","stringLiteralLongSingleQuote","illegalIriChars","escapedIri","unescapedIri","unescape_unescape","item","replace","unicode4","unicode8","escapedChar","fromCharCode","parseInt","charCode","replacement","Error","error","turtleTokenMap","turtleTokenTypes","unicodeRegexp","Comment","api","pattern","group","WhiteSpace","regex","and","option","or","matchers","EXPONENT","ECHAR","PLX","PERCENT","HEX","text","startOffset","match","exec","line_breaks","textToMatch","UCHAR","test","PN_CHARS_BASE","PN_CHARS_U","PN_CHARS","PN_PREFIX","PN_LOCAL","PN_LOCAL_ESC","Unknown","tokens_a","LexerMode","customErrors_a","Rule","If","push_mode","IFCLAUSE","Then","THENCLAUSE","EndThen","pop_mode","GroupGraphPattern","cursor","unclosedBraceCount","TriplesBlock","indexOfIriRef","turtle_tokens","multiModeLexerDefinition","modes","TURTLE","concat","LCurly","defaultMode","srsTokenMap","srsTokenTypes","defaultNamespacesMap","freeze","reduce","prefix","_a","getSparqlSrsVisitor","BaseVisitor","SparqlSrsVisitor","groupGraphPatterns","triplesBlocks","IfClause","ctx","cstInputTokens","$storePlaceholderTokenReplacement","tokenStore","originalTokenContext","subParserRule","sparqlParser","parseGroupGraphPattern","ThenClause","parseTriplesBlock","_b","stripWrappers","originalToken","$getPlaceholderTokenReplacement","parseResult","frontPadding","latestEndOffset","latestEndLine","linesBetweenTokens","startLine","untokenizedSpaceBetweenTokens","repeat","Math","max","split","forEach","line","idx","endOffset","endLine","parseImage","$getGroupGraphPatterns","$getTriplesBlocks","$resetState","validateVisitor","reduceVisitorItemErrors","acc","findAndSwapPlaceholders","node","parentNode","visitorItems","matchingVisitorItem","find","visitorItem","children","subExpressionMatcher","defaultEarlyAbortTest","disallowedSparqlTokenNameToRuleMap","EXISTS","tokenName","NOT_EXISTS","NOW","disallowedSparqlTokenNames","keys","disallowedSparqlLiteralTokenNames","DOUBLE_POSITIVE","DECIMAL_POSITIVE","INTEGER_POSITIVE","DOUBLE_NEGATIVE","DECIMAL_NEGATIVE","INTEGER_NEGATIVE","STRING_LITERAL1","STRING_LITERAL2","STRING_LITERAL_LONG1","STRING_LITERAL_LONG2","map","getCustomErrorRuleStack","traverseCtx","fullCtx","startRuleNames","topLevelSubParserRuleName","earlyAbortTest","stackUnwindingPointer","helpers_cst","includes","parentCtx","unshift","getCustomIRecognitionException","getNoPrefixError","subParserRuleName","getDisallowedTokenError","tokenType","getDisallowedLiteralError","foundPropertyListPathNotEmptyCtx","didFindSubExpressionWithMultipleChildren","errorContext","errorRuleStack","stackCtx","nodeName","isExpression","isTriplesBlock","isBoundExpressionWithLiteralSubject","isTriplesBlockSubject","SrsParser_extends","SrsParser_assign","SrsParser_SrsParser","SrsParser","baseNamespacesMap","visitCst","sparqlSrsVisitor","BaseSrsVisitor","getBaseCstVisitorConstructorWithDefaults","visit","getSparqlRulesFromVisitor","setBaseNamespaces","newBaseNamespaces","SrsDoc","next","currentTokenName","some","addIfClauseErrorsToErrors","addThenClauseErrorsToErrors","RuleDoc","MANY1","RuleClause","traverse","unsafeTraverse","isCstNode","_traverse","Boolean","TraverseContext","visitSafely","childType","child","childCtx","transformedCtx","nextCtx"],"mappings":"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","file":"millan.srs.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"srs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"srs\"] = factory();\n\telse\n\t\troot[\"millan\"] = root[\"millan\"] || {}, root[\"millan\"][\"srs\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t6: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = (typeof self !== 'undefined' ? self : this)[\"webpackJsonp\"] = (typeof self !== 'undefined' ? self : this)[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([61,0,1]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { turtleTokenTypes, turtleTokenMap } from './tokens';\nimport { Parser, Lexer, } from 'chevrotain';\nvar TurtleParser = /** @class */ (function (_super) {\n    __extends(TurtleParser, _super);\n    function TurtleParser(config, tokens, lexerDefinition, performSelfAnalysis) {\n        if (tokens === void 0) { tokens = turtleTokenTypes; }\n        if (lexerDefinition === void 0) { lexerDefinition = tokens; }\n        if (performSelfAnalysis === void 0) { performSelfAnalysis = true; }\n        var _this = _super.call(this, tokens, __assign({ outputCst: true, recoveryEnabled: true }, config)) || this;\n        // Parsing Turtle requires that the parser keep a map of namespaces in state.\n        // Empty prefixes, for example, are allowed only if the empty prefix has been\n        // added to the namespaces map (for now, that's all this tracks). (TODO: We\n        // might want to use a visitor for this, but I'm doing it quick-and-dirty for\n        // now.)\n        // See here: https://www.w3.org/TR/turtle/#handle-PNAME_LN\n        _this.namespacesMap = {};\n        _this.semanticErrors = [];\n        // Clears the state that we have to manage on our own for each parse (see\n        // above for details).\n        _this.resetManagedState = function () {\n            _this.namespacesMap = {};\n            _this.semanticErrors = [];\n        };\n        _this.tokenize = function (document) {\n            return _this.lexer.tokenize(document).tokens;\n        };\n        _this.parse = function (document) {\n            _this.input = _this.lexer.tokenize(document).tokens;\n            var cst = _this.turtleDoc();\n            // Next two items are copied so that they can be returned/held after parse\n            // state is cleared.\n            var errors = _this.errors.slice();\n            var semanticErrors = _this.semanticErrors.slice();\n            _this.resetManagedState();\n            return {\n                errors: errors,\n                semanticErrors: semanticErrors,\n                cst: cst,\n            };\n        };\n        _this.turtleDoc = _this.RULE('turtleDoc', function () {\n            _this.MANY(function () { return _this.SUBRULE(_this.statement); });\n        });\n        _this.statement = _this.RULE('statement', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.directive); } },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.triples);\n                        _this.CONSUME(turtleTokenMap.Period);\n                    },\n                },\n            ]);\n        });\n        _this.directive = _this.RULE('directive', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.prefixID); } },\n                { ALT: function () { return _this.SUBRULE(_this.base); } },\n                { ALT: function () { return _this.SUBRULE(_this.sparqlPrefix); } },\n                { ALT: function () { return _this.SUBRULE(_this.sparqlBase); } },\n            ]);\n        });\n        _this.prefixID = _this.RULE('prefixID', function () {\n            _this.CONSUME(turtleTokenMap.TTL_PREFIX);\n            var pnameNsToken = _this.CONSUME(turtleTokenMap.PNAME_NS);\n            var iriToken = _this.CONSUME(turtleTokenMap.IRIREF);\n            var pnameImageWithoutColon = pnameNsToken.image.slice(0, -1);\n            var iriImage = iriToken.image;\n            _this.namespacesMap[pnameImageWithoutColon] = iriImage;\n            _this.CONSUME(turtleTokenMap.Period);\n        });\n        _this.base = _this.RULE('base', function () {\n            _this.CONSUME(turtleTokenMap.TTL_BASE);\n            _this.CONSUME(turtleTokenMap.IRIREF);\n            _this.CONSUME(turtleTokenMap.Period);\n        });\n        _this.sparqlBase = _this.RULE('sparqlBase', function () {\n            _this.CONSUME(turtleTokenMap.BASE);\n            _this.CONSUME(turtleTokenMap.IRIREF);\n        });\n        _this.sparqlPrefix = _this.RULE('sparqlPrefix', function () {\n            _this.CONSUME(turtleTokenMap.PREFIX);\n            var pnameNsToken = _this.CONSUME(turtleTokenMap.PNAME_NS);\n            var iriToken = _this.CONSUME(turtleTokenMap.IRIREF);\n            var pnameImageWithoutColon = pnameNsToken.image.slice(0, -1);\n            var iriImage = iriToken.image;\n            _this.namespacesMap[pnameImageWithoutColon] = iriImage;\n        });\n        _this.triples = _this.RULE('triples', function () {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.subject);\n                        _this.SUBRULE(_this.predicateObjectList);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.blankNodePropertyList);\n                        _this.OPTION(function () { return _this.SUBRULE1(_this.predicateObjectList); });\n                    },\n                },\n            ]);\n        });\n        _this.predicateObjectList = _this.RULE('predicateObjectList', function () {\n            _this.SUBRULE(_this.verb);\n            _this.SUBRULE(_this.objectList);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.SUBRULE1(_this.verb);\n                    _this.SUBRULE1(_this.objectList);\n                });\n            });\n        });\n        _this.subject = _this.RULE('subject', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNode); } },\n                { ALT: function () { return _this.SUBRULE(_this.collection); } },\n            ]);\n        });\n        _this.predicate = _this.RULE('predicate', function () {\n            _this.SUBRULE(_this.iri);\n        });\n        _this.objectList = _this.RULE('objectList', function () {\n            _this.SUBRULE(_this.object);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Comma);\n                _this.SUBRULE1(_this.object);\n            });\n        });\n        _this.verb = _this.RULE('verb', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.predicate); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.A); } },\n            ]);\n        });\n        _this.literal = _this.RULE('literal', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.RDFLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.BooleanLiteral); } },\n            ]);\n        });\n        _this.blankNodePropertyList = _this.RULE('blankNodePropertyList', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.SUBRULE(_this.predicateObjectList);\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.object = _this.RULE('object', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNode); } },\n                { ALT: function () { return _this.SUBRULE(_this.collection); } },\n                { ALT: function () { return _this.SUBRULE(_this.blankNodePropertyList); } },\n                { ALT: function () { return _this.SUBRULE(_this.literal); } },\n            ]);\n        });\n        _this.collection = _this.RULE('collection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () { return _this.SUBRULE(_this.object); });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.NumericLiteral = _this.RULE('NumericLiteral', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.INTEGER); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.DECIMAL); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.DOUBLE); } },\n            ]);\n        });\n        _this.RDFLiteral = _this.RULE('RDFLiteral', function () {\n            _this.SUBRULE(_this.String);\n            _this.OPTION(function () {\n                _this.OR([\n                    { ALT: function () { return _this.CONSUME(turtleTokenMap.LANGTAG); } },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(turtleTokenMap.DoubleCaret);\n                            _this.SUBRULE(_this.iri);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.BooleanLiteral = _this.RULE('BooleanLiteral', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.TRUE); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.FALSE); } },\n            ]);\n        });\n        _this.String = _this.RULE('String', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_QUOTE); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_SINGLE_QUOTE); } },\n                {\n                    ALT: function () {\n                        return _this.CONSUME(turtleTokenMap.STRING_LITERAL_LONG_SINGLE_QUOTE);\n                    },\n                },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_LONG_QUOTE); } },\n            ]);\n        });\n        _this.iri = _this.RULE('iri', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.IRIREF); } },\n                { ALT: function () { return _this.SUBRULE(_this.PrefixedName); } },\n            ]);\n        });\n        _this.PrefixedName = _this.RULE('PrefixedName', function () {\n            var prefixedNameToken = _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.PNAME_LN); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.PNAME_NS); } },\n            ]);\n            var pnameNsImage = prefixedNameToken.image.slice(0, prefixedNameToken.image.indexOf(':'));\n            if (!(pnameNsImage in _this.namespacesMap)) {\n                _this.semanticErrors.push({\n                    name: 'NoNamespacePrefixError',\n                    message: 'A prefix was used for which there was no namespace defined.',\n                    token: prefixedNameToken,\n                    context: {\n                        ruleStack: _this.getHumanReadableRuleStack(),\n                        ruleOccurrenceStack: _this.RULE_OCCURRENCE_STACK.slice(),\n                    },\n                    resyncedTokens: [],\n                });\n            }\n        });\n        _this.BlankNode = _this.RULE('BlankNode', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.BLANK_NODE_LABEL); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.ANON); } },\n            ]);\n        });\n        _this.lexer = new Lexer(lexerDefinition);\n        if (performSelfAnalysis) {\n            Parser.performSelfAnalysis(_this);\n        }\n        return _this;\n    }\n    return TurtleParser;\n}(Parser));\nexport { TurtleParser };\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { baseTokens } from './tokens';\nimport { BaseSparqlParser } from './BaseSparqlParser';\nimport { Parser } from 'chevrotain';\nvar W3SpecSparqlParser = /** @class */ (function (_super) {\n    __extends(W3SpecSparqlParser, _super);\n    function W3SpecSparqlParser(options) {\n        var _this = _super.call(this, options, baseTokens) || this;\n        Parser.performSelfAnalysis(_this);\n        return _this;\n    }\n    return W3SpecSparqlParser;\n}(BaseSparqlParser));\nexport { W3SpecSparqlParser };\n","/*\nCopyright 20122018 Ruben Verborgh\nWith modifications Copyright 2018 Stardog Union\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nvar escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\[uU]|\\\\(.)/g;\nvar escapeReplacements = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\"': '\"',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    f: '\\f',\n    b: '\\b',\n    _: '_',\n    '~': '~',\n    '.': '.',\n    '-': '-',\n    '!': '!',\n    $: '$',\n    '&': '&',\n    '(': '(',\n    ')': ')',\n    '*': '*',\n    '+': '+',\n    ',': ',',\n    ';': ';',\n    '=': '=',\n    '/': '/',\n    '?': '?',\n    '#': '#',\n    '@': '@',\n    '%': '%',\n};\nexport var unescapedStringLiteralQuote = /^\"([^\"\\\\\\r\\n]+)\"/; // non-empty string without escape sequences\nexport var unescapedStringLiteralSingleQuote = /^'([^'\\\\\\r\\n]+)'/;\nexport var stringLiteralQuote = /^\"((?:[^\"\\\\\\r\\n]|\\\\.)*)\"(?=[^\"])/;\nexport var stringLiteralSingleQuote = /^'((?:[^'\\\\\\r\\n]|\\\\.)*)'(?=[^'])/;\nexport var stringLiteralLongQuote = /^\"\"\"([^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*)\"\"\"/;\nexport var stringLiteralLongSingleQuote = /^'''([^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*)'''/;\nexport var illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\nexport var escapedIri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/;\nexport var unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/;\n// Handle special unescaping needs related to the IRIREF rule and others.\nexport var unescape = function (item) {\n    try {\n        return item.replace(escapeSequence, function (_, unicode4, unicode8, escapedChar) {\n            if (unicode4) {\n                return String.fromCharCode(parseInt(unicode4, 16));\n            }\n            else if (unicode8) {\n                var charCode = parseInt(unicode8, 16);\n                if (charCode <= 0xffff) {\n                    return String.fromCharCode(charCode);\n                }\n                return String.fromCharCode(0xd800 + (charCode -= 0x10000) / 0x400, 0xdc00 + (charCode & 0x3ff));\n            }\n            else {\n                var replacement = escapeReplacements[escapedChar];\n                if (!replacement) {\n                    throw new Error();\n                }\n                return replacement;\n            }\n        });\n    }\n    catch (error) {\n        return null;\n    }\n};\n","import { sparqlTokenMap } from '../sparql/tokens';\nimport { createToken } from 'chevrotain';\nimport { regex } from '../helpers/regex';\nimport { EXPONENT, ECHAR, PLX, HEX, PN_CHARS_BASE, PN_CHARS_U, PN_CHARS, PN_PREFIX, PN_LOCAL, PN_LOCAL_ESC, } from '../helpers/matchers';\nimport { unescape, stringLiteralLongSingleQuote, stringLiteralLongQuote, unescapedStringLiteralQuote, stringLiteralQuote, unescapedStringLiteralSingleQuote, stringLiteralSingleQuote, unescapedIri, escapedIri, illegalIriChars, } from '../helpers/unescape';\nvar unicodeRegexp = /[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nexport var turtleTokenMap = {\n    Comment: createToken({\n        name: 'Comment',\n        pattern: /#[^\\n]*/,\n        group: 'comments',\n    }),\n    LBracket: sparqlTokenMap.LBracket,\n    RBracket: sparqlTokenMap.RBracket,\n    LParen: sparqlTokenMap.LParen,\n    RParen: sparqlTokenMap.RParen,\n    Period: sparqlTokenMap.Period,\n    WhiteSpace: sparqlTokenMap.WhiteSpace,\n    TRUE: sparqlTokenMap.TRUE,\n    FALSE: sparqlTokenMap.FALSE,\n    DoubleCaret: sparqlTokenMap.DoubleCaret,\n    Comma: sparqlTokenMap.Comma,\n    Semicolon: sparqlTokenMap.Semicolon,\n    A: sparqlTokenMap.A,\n    PREFIX: sparqlTokenMap.PREFIX,\n    BASE: sparqlTokenMap.BASE,\n    PNAME_NS: sparqlTokenMap.PNAME_NS,\n    PNAME_LN: sparqlTokenMap.PNAME_LN,\n    BLANK_NODE_LABEL: sparqlTokenMap.BLANK_NODE_LABEL,\n    TTL_BASE: createToken({ name: 'TTL_BASE', pattern: /@base/ }),\n    TTL_PREFIX: createToken({ name: 'TTL_PREFIX', pattern: /@prefix/ }),\n    LANGTAG: sparqlTokenMap.LANGTAG,\n    INTEGER: createToken({\n        name: 'INTEGER',\n        pattern: regex.and(regex.option(/[+-]/), /\\d+/),\n    }),\n    DECIMAL: createToken({\n        name: 'DECIMAL',\n        pattern: regex.and(regex.option(/[+-]/), /(\\d*\\.\\d+)/),\n    }),\n    DOUBLE: createToken({\n        name: 'DOUBLE',\n        pattern: regex.and(regex.option(/[+-]/), regex.or(regex.and(/\\d+\\.\\d*/, EXPONENT), regex.and(/\\.\\d+/, EXPONENT), regex.and(/\\d+/, EXPONENT))),\n    }),\n    EXPONENT: createToken({ name: 'EXPONENT', pattern: EXPONENT }),\n    ECHAR: createToken({ name: 'ECHAR', pattern: ECHAR }),\n    ANON: sparqlTokenMap.ANON,\n    PLX: createToken({ name: 'PLX', pattern: PLX }),\n    PERCENT: sparqlTokenMap.PERCENT,\n    HEX: createToken({ name: 'HEX', pattern: HEX }),\n    STRING_LITERAL_LONG_SINGLE_QUOTE: createToken({\n        name: 'STRING_LITERAL_LONG_SINGLE_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var match = stringLiteralLongSingleQuote.exec(text.slice(startOffset));\n            if (!match || unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: true,\n    }),\n    STRING_LITERAL_LONG_QUOTE: createToken({\n        name: 'STRING_LITERAL_LONG_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var match = stringLiteralLongQuote.exec(text.slice(startOffset));\n            if (!match || unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: true,\n    }),\n    STRING_LITERAL_QUOTE: createToken({\n        name: 'STRING_LITERAL_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedStringLiteralQuote.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = stringLiteralQuote.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            if (unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    STRING_LITERAL_SINGLE_QUOTE: createToken({\n        name: 'STRING_LITERAL_SINGLE_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedStringLiteralSingleQuote.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = stringLiteralSingleQuote.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            if (unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    UCHAR: createToken({\n        name: 'UCHAR',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            return unicodeRegexp.exec(text.slice(startOffset));\n        },\n        line_breaks: false,\n    }),\n    IRIREF: createToken({\n        name: 'IRIREF',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedIri.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = escapedIri.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            var value = unescape(match[1]);\n            if (value === null || illegalIriChars.test(value)) {\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    PN_CHARS_BASE: createToken({ name: 'PN_CHARS_BASE', pattern: PN_CHARS_BASE }),\n    PN_CHARS_U: createToken({ name: 'PN_CHARS_U', pattern: PN_CHARS_U }),\n    PN_CHARS: createToken({ name: 'PN_CHARS', pattern: PN_CHARS }),\n    PN_PREFIX: createToken({ name: 'PN_PREFIX', pattern: PN_PREFIX }),\n    PN_LOCAL: createToken({ name: 'PN_LOCAL', pattern: PN_LOCAL }),\n    PN_LOCAL_ESC: createToken({ name: 'PN_LOCAL_ESC', pattern: PN_LOCAL_ESC }),\n    Unknown: createToken({\n        name: 'Unknown',\n        pattern: /\\w+/,\n    }),\n};\nexport var turtleTokenTypes = [\n    turtleTokenMap.Comment,\n    sparqlTokenMap.ANON,\n    sparqlTokenMap.LBracket,\n    sparqlTokenMap.RBracket,\n    sparqlTokenMap.LParen,\n    sparqlTokenMap.RParen,\n    sparqlTokenMap.WhiteSpace,\n    sparqlTokenMap.TRUE,\n    sparqlTokenMap.FALSE,\n    sparqlTokenMap.Comma,\n    sparqlTokenMap.Semicolon,\n    sparqlTokenMap.PNAME_NS,\n    sparqlTokenMap.A,\n    sparqlTokenMap.PREFIX,\n    sparqlTokenMap.BASE,\n    sparqlTokenMap.PNAME_LN,\n    sparqlTokenMap.BLANK_NODE_LABEL,\n    turtleTokenMap.TTL_BASE,\n    turtleTokenMap.TTL_PREFIX,\n    sparqlTokenMap.LANGTAG,\n    turtleTokenMap.DOUBLE,\n    turtleTokenMap.DECIMAL,\n    sparqlTokenMap.Period,\n    sparqlTokenMap.DoubleCaret,\n    turtleTokenMap.IRIREF,\n    turtleTokenMap.STRING_LITERAL_LONG_SINGLE_QUOTE,\n    turtleTokenMap.STRING_LITERAL_LONG_QUOTE,\n    turtleTokenMap.STRING_LITERAL_QUOTE,\n    turtleTokenMap.STRING_LITERAL_SINGLE_QUOTE,\n    turtleTokenMap.INTEGER,\n    turtleTokenMap.EXPONENT,\n    turtleTokenMap.PLX,\n    sparqlTokenMap.PERCENT,\n    turtleTokenMap.HEX,\n    turtleTokenMap.PN_CHARS_BASE,\n    turtleTokenMap.PN_CHARS_U,\n    turtleTokenMap.PN_CHARS,\n    turtleTokenMap.PN_PREFIX,\n    turtleTokenMap.PN_LOCAL,\n    turtleTokenMap.PN_LOCAL_ESC,\n    turtleTokenMap.ECHAR,\n    turtleTokenMap.UCHAR,\n    turtleTokenMap.Unknown,\n];\n","var _a;\nimport { turtleTokenTypes } from '../turtle/tokens';\nimport { createToken } from 'chevrotain';\nimport { CATCH_ALL_AT_LEAST_ONE } from 'helpers/matchers';\nimport { turtleTokenMap } from 'turtle/tokens';\nimport { sparqlTokenMap } from 'sparql/tokens';\nvar LexerMode;\n(function (LexerMode) {\n    LexerMode[\"TURTLE\"] = \"turtle\";\n    LexerMode[\"IFCLAUSE\"] = \"ifclause\";\n    LexerMode[\"THENCLAUSE\"] = \"thenclause\";\n})(LexerMode || (LexerMode = {}));\nvar Rule = createToken({\n    name: 'Rule',\n    pattern: /rule/i,\n});\nvar If = createToken({\n    name: 'If',\n    pattern: /if/i,\n    push_mode: LexerMode.IFCLAUSE,\n});\nvar Then = createToken({\n    name: 'Then',\n    pattern: /then/i,\n    push_mode: LexerMode.THENCLAUSE,\n});\nvar EndThen = createToken({\n    name: 'EndThen',\n    pattern: '}',\n    pop_mode: true,\n});\n// NOTE: Not a SPARQL GroupGraphPattern. Rather, a placeholder for one. We have\n// to let the SRS parser create this token, then replace with a token returned\n// by the SPARQL sub-parser.\nvar GroupGraphPattern = createToken({\n    name: 'GroupGraphPattern',\n    pattern: function (text, startOffset) {\n        if (startOffset === void 0) { startOffset = 0; }\n        // Capture a single brace and then anything up to its closing brace.\n        if (text[startOffset] !== '{') {\n            return null;\n        }\n        var unclosedBraceCount = 1;\n        var cursor;\n        for (cursor = startOffset + 1; cursor < text.length && unclosedBraceCount > 0; cursor++) {\n            if (text[cursor] === '{') {\n                unclosedBraceCount++;\n            }\n            else if (text[cursor] === '}') {\n                unclosedBraceCount--;\n            }\n        }\n        if (unclosedBraceCount > 0) {\n            return null;\n        }\n        return CATCH_ALL_AT_LEAST_ONE.exec(text.slice(startOffset, cursor));\n    },\n    line_breaks: true,\n    pop_mode: true,\n});\n// NOTE: Not a SPARQL TriplesBlock. Rather, a placeholder for one. We have\n// to let the SRS parser create this token, then replace with a token returned\n// by the SPARQL sub-parser.\nvar TriplesBlock = createToken({\n    name: 'TriplesBlock',\n    pattern: /[^{}]+/,\n    line_breaks: true,\n});\nvar indexOfIriRef = turtleTokenTypes.indexOf(turtleTokenMap.IRIREF);\nexport var multiModeLexerDefinition = {\n    modes: (_a = {},\n        _a[LexerMode.TURTLE] = turtleTokenTypes.slice(0, indexOfIriRef + 1).concat([\n            Rule,\n            If,\n            Then\n        ], turtleTokenTypes.slice(indexOfIriRef + 1)),\n        _a[LexerMode.IFCLAUSE] = [turtleTokenMap.WhiteSpace, GroupGraphPattern],\n        _a[LexerMode.THENCLAUSE] = [\n            turtleTokenMap.WhiteSpace,\n            sparqlTokenMap.LCurly,\n            EndThen,\n            TriplesBlock,\n        ],\n        _a),\n    defaultMode: LexerMode.TURTLE,\n};\nexport var srsTokenMap = {\n    Rule: Rule,\n    If: If,\n    Then: Then,\n    EndThen: EndThen,\n    GroupGraphPattern: GroupGraphPattern,\n    TriplesBlock: TriplesBlock,\n};\nexport var srsTokenTypes = [\n    Rule,\n    If,\n    Then,\n    EndThen,\n    sparqlTokenMap.LCurly\n].concat(turtleTokenTypes, [\n    GroupGraphPattern,\n    TriplesBlock,\n]);\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { W3SpecSparqlParser } from '../sparql/W3SpecSparqlParser';\n// Returns a custom visitor that extends the BaseVisitor for the SRS parser.\n// When the visitor encounters an SRS `IfClause` or an SRS `ThenClause`, it\n// delegates parsing of the block to the existing SPARQL parser's relevant\n// sub-rule (GroupGraphPattern or TriplesBlock).\nexport var getSparqlSrsVisitor = function (BaseVisitor) {\n    var SparqlSrsVisitor = /** @class */ (function (_super) {\n        __extends(SparqlSrsVisitor, _super);\n        function SparqlSrsVisitor() {\n            var _this = _super.call(this) || this;\n            _this.groupGraphPatterns = [];\n            _this.triplesBlocks = [];\n            // Get and store the SPARQL `GroupGraphPattern` that should replace the\n            // SRS placeholder `GroupGraphPattern` token inside of an SRS `IfClause`.\n            _this.IfClause = function (ctx, cstInputTokens) {\n                var GroupGraphPattern = ctx.GroupGraphPattern;\n                _this.$storePlaceholderTokenReplacement({\n                    tokenStore: _this.groupGraphPatterns,\n                    originalTokenContext: GroupGraphPattern,\n                    subParserRule: _this.sparqlParser.parseGroupGraphPattern.bind(_this.sparqlParser),\n                    cstInputTokens: cstInputTokens,\n                });\n            };\n            // Get and store the SPARQL `TriplesBlock` that should replace the\n            // SRS placeholder `TriplesBlock` token inside of an SRS `ThenClause`.\n            _this.ThenClause = function (ctx, cstInputTokens) {\n                var TriplesBlock = ctx.TriplesBlock;\n                _this.$storePlaceholderTokenReplacement({\n                    tokenStore: _this.triplesBlocks,\n                    originalTokenContext: TriplesBlock,\n                    subParserRule: _this.sparqlParser.parseTriplesBlock.bind(_this.sparqlParser),\n                    cstInputTokens: cstInputTokens,\n                });\n            };\n            // Utility methods ('$' prefix is necessary to prevent chevrotain's\n            // `validateVisitor` method from complaining that these are not grammar\n            // rules):\n            _this.$storePlaceholderTokenReplacement = function (_a) {\n                var tokenStore = _a.tokenStore, _b = _a.originalTokenContext, originalTokenContext = _b === void 0 ? [] : _b, subParserRule = _a.subParserRule, cstInputTokens = _a.cstInputTokens, stripWrappers = _a.stripWrappers;\n                var originalToken = originalTokenContext[0];\n                if (!originalToken || typeof originalToken.image !== 'string') {\n                    return;\n                }\n                var replacement = _this.$getPlaceholderTokenReplacement(originalToken, subParserRule, cstInputTokens, stripWrappers);\n                tokenStore.push({\n                    parseResult: replacement,\n                    originalToken: originalToken,\n                });\n            };\n            _this.$getPlaceholderTokenReplacement = function (originalToken, subParserRule, cstInputTokens, stripWrappers) {\n                if (stripWrappers === void 0) { stripWrappers = false; }\n                // Because we are replacing tokens by delegating the parsing of parts\n                // of the original document to sub-parsers, we add some empty padding to\n                // the part that is passed to the sub-parser, where the amount of padding\n                // matches the start line and offset of the token we are replacing. This\n                // ensures that all tokens have the right positions in the resulting CST\n                // (otherwise, the sub-parsers assume that the text starts at offset 0).\n                var image = originalToken.image;\n                var frontPadding = '';\n                var latestEndOffset = 0;\n                var latestEndLine = 0;\n                // Traditional `for` loop because we need to `break`.\n                for (var i = 0; i < cstInputTokens.length; i++) {\n                    var token = cstInputTokens[i];\n                    if (i > 0) {\n                        // Account for whitespace between this token and the previous one.\n                        var linesBetweenTokens = token.startLine - latestEndLine;\n                        var untokenizedSpaceBetweenTokens = token.startOffset - 1 - latestEndOffset - linesBetweenTokens;\n                        if (linesBetweenTokens > 0) {\n                            frontPadding += '\\n'.repeat(linesBetweenTokens - 1);\n                            frontPadding +=\n                                ' '.repeat(Math.max(untokenizedSpaceBetweenTokens, 0)) + '\\n';\n                        }\n                        else {\n                            frontPadding += ' '.repeat(Math.max(untokenizedSpaceBetweenTokens, 0));\n                        }\n                    }\n                    if (token === originalToken) {\n                        break;\n                    }\n                    // We haven't hit the token we're replacing yet, so we need to continue\n                    // accumulating padding by adding the newlines _inside_ the current\n                    // token, and replacing all non-newline characters inside the current\n                    // token with spaces.\n                    var newlinesInToken = token.image.split('\\n');\n                    newlinesInToken.forEach(function (line, idx) {\n                        if (idx > 0) {\n                            frontPadding += '\\n';\n                        }\n                        frontPadding += ' '.repeat(line.length);\n                    });\n                    // Track where the current token ends, in case the next token starts\n                    // much later (meaning that there was untokenized stuff (e.g.,\n                    // whitespace) in between) that needs to be accounted for.\n                    latestEndOffset = token.endOffset;\n                    latestEndLine = token.endLine;\n                }\n                // Finally, if we're stripping the wrappers (e.g., braces), replace them\n                // with whitespace.\n                var parseImage = stripWrappers ? \" \" + image.slice(1, -1) + \" \" : image;\n                return subParserRule(\"\" + frontPadding + parseImage);\n            };\n            _this.$getGroupGraphPatterns = function () { return _this.groupGraphPatterns; };\n            _this.$getTriplesBlocks = function () { return _this.triplesBlocks; };\n            _this.$resetState = function () {\n                _this.groupGraphPatterns = [];\n                _this.triplesBlocks = [];\n            };\n            _this.sparqlParser = new W3SpecSparqlParser();\n            _this.validateVisitor();\n            return _this;\n        }\n        return SparqlSrsVisitor;\n    }(BaseVisitor));\n    return new SparqlSrsVisitor();\n};\nexport function reduceVisitorItemErrors(acc, item) {\n    return acc.concat(item.parseResult.errors);\n}\n// The SRS cst contains placeholder tokens for unparsed blocks of SPARQL\n// inside of an SRS `IfClause` or `ThenClause`. This method swaps out those\n// placeholders with the actual SPARQL CST created by the SparqlSrsVisitor.\nexport function findAndSwapPlaceholders(node, parentNode, visitorItems, key) {\n    var matchingVisitorItem = visitorItems.find(function (visitorItem) { return visitorItem.originalToken === node; });\n    if (matchingVisitorItem) {\n        parentNode.children[key] = [matchingVisitorItem.parseResult.cst];\n    }\n    return matchingVisitorItem;\n}\n","var _a;\nimport { isCstNode, traverse } from '../helpers/cst';\nimport { sparqlTokenMap } from '../sparql/tokens';\n// RegEx for matching any relevant children of `Expression` inside of `Bind`;\n// used to avoid false negatives in the check for disallowed literals inside of\n// `Bind`.\nvar subExpressionMatcher = /(?:[A-Z]+Expression|ValueLogical)$/i;\n// Default: just don't abort early at all. Used in the stack unwinding process\n// that creates an error rule stack.\nvar defaultEarlyAbortTest = function () { return false; };\n// Tokens that are allowed in SPARQL but not inside the `IfClause` of SRS.\nvar disallowedSparqlTokenNameToRuleMap = (_a = {},\n    _a[sparqlTokenMap.EXISTS.tokenName] = 'ExistsFunction',\n    _a[sparqlTokenMap.NOT_EXISTS.tokenName] = 'NotExistsFunction',\n    _a[sparqlTokenMap.NOW.tokenName] = 'BuiltInCall_NOW',\n    _a);\nvar disallowedSparqlTokenNames = Object.keys(disallowedSparqlTokenNameToRuleMap);\n// Token names for literals; these are not allowed in the subject position of\n// certain patterns in SRS.\nvar disallowedSparqlLiteralTokenNames = [\n    sparqlTokenMap.DOUBLE,\n    sparqlTokenMap.DECIMAL,\n    sparqlTokenMap.INTEGER,\n    sparqlTokenMap.DOUBLE_POSITIVE,\n    sparqlTokenMap.DECIMAL_POSITIVE,\n    sparqlTokenMap.INTEGER_POSITIVE,\n    sparqlTokenMap.DOUBLE_NEGATIVE,\n    sparqlTokenMap.DECIMAL_NEGATIVE,\n    sparqlTokenMap.INTEGER_NEGATIVE,\n    sparqlTokenMap.STRING_LITERAL1,\n    sparqlTokenMap.STRING_LITERAL2,\n    sparqlTokenMap.STRING_LITERAL_LONG1,\n    sparqlTokenMap.STRING_LITERAL_LONG2,\n].map(function (token) { return token.tokenName; });\n// Walks back up the tree to construct the rule stack, first going upward\n// through the provided `traverseCtx`, and then continuing up through the\n// `fullCtx`. `traverseCtx` is intended to be the \"inner\" ITraverseContext\n// representing the results of the SPARQL sub-parser used by the\n// SparqlSrsVisitor. `fullCtx` is intended to be the \"outer\" ITraverseContext\n// representing the results of the SRS parser itself. The SRS parser delegates\n// blocks of SPARQL to a SPARQL sub-parser, so, by combinging the two contexts,\n// we get the full parser stack. The traversal adds rules to the stack only\n// once a rule matching one of the `startRuleNames` is hit.\n//\n// At the point where the traversal of `traverseCtx` ends and the traversal of\n// `fullCtx` begins, you may need to insert a rule into the stack (e.g.,\n// because the `traverseCtx` doesn't include the top-level rule for that\n// parse). If so, use `topLevelSubParserRuleName`.\n//\n// In some cases, there is a need to track nodes and potentially bail out early\n// at certain points while constructing the rule stack. For that, use\n// `earlyAbortTest`. If that method returns true, the rule stack construction\n// will abort.\nfunction getCustomErrorRuleStack(traverseCtx, fullCtx, startRuleNames, topLevelSubParserRuleName, earlyAbortTest) {\n    if (earlyAbortTest === void 0) { earlyAbortTest = defaultEarlyAbortTest; }\n    if (!traverseCtx) {\n        return []; // forced early exit\n    }\n    var ruleStack = [];\n    var stackUnwindingPointer = traverseCtx;\n    // Move up from current context to the first rule that should \"start\" the stack.\n    while (isCstNode(stackUnwindingPointer.node) &&\n        !startRuleNames.includes(stackUnwindingPointer.node.name)) {\n        if (earlyAbortTest(stackUnwindingPointer)) {\n            return [];\n        }\n        stackUnwindingPointer = stackUnwindingPointer.parentCtx;\n    }\n    // Now start adding all found rules to the stack as we move upward.\n    while (isCstNode(stackUnwindingPointer.node)) {\n        ruleStack.unshift(stackUnwindingPointer.node.name);\n        if (earlyAbortTest(stackUnwindingPointer)) {\n            return [];\n        }\n        stackUnwindingPointer = stackUnwindingPointer.parentCtx;\n    }\n    // If the rule stack of the sub-parser doesn't get all the way up to the\n    // relevant top-level rule, this will force the top-level rule to be put onto\n    // the stack before proceeding.\n    if (typeof topLevelSubParserRuleName === 'string') {\n        ruleStack.unshift(topLevelSubParserRuleName);\n    }\n    // Now that we've got the sub-parser's rule stack, we trace the remaining\n    // outer parser's stack to get to the true bottom of the stack.\n    stackUnwindingPointer = fullCtx;\n    while (stackUnwindingPointer) {\n        if (isCstNode(stackUnwindingPointer.node)) {\n            ruleStack.unshift(stackUnwindingPointer.node.name);\n            if (earlyAbortTest(stackUnwindingPointer)) {\n                return [];\n            }\n        }\n        stackUnwindingPointer = stackUnwindingPointer.parentCtx;\n    }\n    return ['SrsDoc'].concat(ruleStack);\n}\nvar getCustomIRecognitionException = function (_a) {\n    var name = _a.name, message = _a.message, node = _a.node, ruleStack = _a.ruleStack;\n    return ({\n        name: name,\n        message: message,\n        token: node,\n        context: {\n            ruleStack: ruleStack,\n            // `ruleOccurrenceStack` is meaningless to us as it just\n            // records the number used when the chevrotain rule is\n            // created (e.g., SUBRULE1 vs SUBRULE2); we can't know that\n            // or care about that here\n            ruleOccurrenceStack: [],\n        },\n        resyncedTokens: [],\n    });\n};\nvar getNoPrefixError = function (node, parentCtx, fullCtx, subParserRuleName) {\n    return getCustomIRecognitionException({\n        name: 'NoNamespacePrefixError',\n        message: \"A prefix (\\\"\" + node.image + \"\\\") was used for which there was no namespace defined.\",\n        node: node,\n        ruleStack: getCustomErrorRuleStack(parentCtx, fullCtx, ['PrefixedName'], subParserRuleName),\n    });\n};\nvar getDisallowedTokenError = function (node, parentCtx, fullCtx) {\n    return getCustomIRecognitionException({\n        name: 'DisallowedTokenError',\n        message: \"Token \" + node.tokenType.tokenName + \" cannot be used in Stardog Rules.\",\n        node: node,\n        ruleStack: getCustomErrorRuleStack(parentCtx, fullCtx, [disallowedSparqlTokenNameToRuleMap[node.tokenType.tokenName]], 'GroupGraphPattern'),\n    });\n};\nvar getDisallowedLiteralError = function (node, parentCtx, fullCtx, subParserRuleName) {\n    var foundPropertyListPathNotEmptyCtx = null;\n    var didFindSubExpressionWithMultipleChildren = false;\n    var errorContext = null;\n    var errorRuleStack = getCustomErrorRuleStack(parentCtx, fullCtx, ['Expression', 'TriplesSameSubjectPath'], subParserRuleName, function (stackCtx) {\n        var node = stackCtx.node, parentCtx = stackCtx.parentCtx;\n        var nodeName = node.name;\n        if (nodeName === 'PropertyListPathNotEmpty') {\n            // Track the found `PropertyListPathNotEmmpty` node and keep going.\n            foundPropertyListPathNotEmptyCtx = stackCtx;\n            return false;\n        }\n        if (!didFindSubExpressionWithMultipleChildren &&\n            subExpressionMatcher.test(nodeName)) {\n            // Track that we found a sub-expression with multiple children, then\n            // keep going.\n            didFindSubExpressionWithMultipleChildren =\n                parentCtx.node.children[nodeName].length > 1;\n            return false;\n        }\n        var isExpression = nodeName === 'Expression';\n        var isTriplesBlock = nodeName === 'TriplesSameSubjectPath';\n        if (!isExpression && !isTriplesBlock) {\n            return false;\n        }\n        var isBoundExpressionWithLiteralSubject = isExpression &&\n            parentCtx.node.name === 'Bind' &&\n            // If we've found a sub-expression with multiple children, it's highly\n            // likely (maybe definite?) that this `Bind` does not include an invalid\n            // literal as a subject, so we don't count this as an error. This _may_\n            // allow rare false positives, but it definitely prevents false\n            // negatives of the sort described in https://github.com/stardog-union/millan/issues/22\n            !didFindSubExpressionWithMultipleChildren;\n        var isTriplesBlockSubject = isTriplesBlock &&\n            (!foundPropertyListPathNotEmptyCtx ||\n                foundPropertyListPathNotEmptyCtx.parentCtx.node.name !==\n                    'TriplesSameSubjectPath');\n        if (isBoundExpressionWithLiteralSubject || isTriplesBlockSubject) {\n            errorContext = isBoundExpressionWithLiteralSubject\n                ? 'Bind'\n                : 'TriplesBlock';\n            return false;\n        }\n        // We got to the Expression or TriplesBlock containing the literal, but\n        // the literal wasn't in the subject position (i.e., was not the lead\n        // Expression inside of Bind and was not the subject of\n        // TriplesSameSubjectPath), so we can bail early here.\n        return true;\n    });\n    if (errorRuleStack.length === 0) {\n        return;\n    }\n    return getCustomIRecognitionException({\n        name: 'DisallowedLiteralError',\n        message: \"Token \" + node.tokenType.tokenName + \" (\" + node.image + \") cannot be used as a subject inside of a \" + errorContext + \" in Stardog Rules Syntax.\",\n        node: node,\n        ruleStack: errorRuleStack,\n    });\n};\n// Since the SRS parser delegates to the SPARQL parser inside of\n// an SRS `IfClause`, and SPARQL allows certain constructs that SRS does not,\n// we need to create our own errors for SRS-specific restrictions here.\nexport function addIfClauseErrorsToErrors(_a) {\n    var cst = _a.cst, namespacesMap = _a.namespacesMap, fullCtx = _a.fullCtx, errors = _a.errors, semanticErrors = _a.semanticErrors;\n    traverse(cst, function (ctx, next) {\n        var node = ctx.node, parentCtx = ctx.parentCtx;\n        if (isCstNode(node)) {\n            return next();\n        }\n        var tokenName = node.tokenType.tokenName;\n        if (disallowedSparqlTokenNames.some(function (name) { return name === tokenName; })) {\n            errors.push(getDisallowedTokenError(node, parentCtx, fullCtx));\n        }\n        if (disallowedSparqlLiteralTokenNames.some(function (tokenName) { return tokenName === node.tokenType.tokenName; })) {\n            var error = getDisallowedLiteralError(node, parentCtx, fullCtx, 'GroupGraphPattern');\n            if (error) {\n                errors.push(error);\n            }\n        }\n        if (tokenName === 'PNAME_NS' || tokenName === 'PNAME_LN') {\n            var prefix = node.image.split(':').shift();\n            if (!namespacesMap[prefix]) {\n                semanticErrors.push(getNoPrefixError(node, parentCtx, fullCtx, 'GroupGraphPattern'));\n            }\n        }\n    });\n    return {\n        errors: errors,\n        semanticErrors: semanticErrors,\n    };\n}\nexport function addThenClauseErrorsToErrors(_a) {\n    var cst = _a.cst, namespacesMap = _a.namespacesMap, errors = _a.errors, semanticErrors = _a.semanticErrors, fullCtx = _a.fullCtx;\n    traverse(cst, function (ctx, next) {\n        var node = ctx.node, parentCtx = ctx.parentCtx;\n        if (isCstNode(node)) {\n            return next();\n        }\n        var tokenName = node.tokenType.tokenName;\n        if (disallowedSparqlLiteralTokenNames.some(function (tokenName) { return tokenName === node.tokenType.tokenName; })) {\n            var error = getDisallowedLiteralError(node, parentCtx, fullCtx, 'GroupGraphPattern');\n            if (error) {\n                errors.push(error);\n            }\n        }\n        if (tokenName === 'PNAME_NS' || tokenName === 'PNAME_LN') {\n            var prefix = node.image.split(':').shift();\n            if (!namespacesMap[prefix]) {\n                semanticErrors.push(getNoPrefixError(node, parentCtx, fullCtx, 'TriplesBlock'));\n            }\n        }\n    });\n    return {\n        errors: errors,\n        semanticErrors: semanticErrors,\n    };\n}\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexport var defaultNamespacesMap = Object.freeze(['', 'rdf', 'rdfs', 'xsd', 'owl', 'stardog'].reduce(function (namespacesMap, prefix) {\n    var _a;\n    return (__assign({}, namespacesMap, (_a = {}, _a[prefix] = true, _a)));\n}, {}));\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { sparqlTokenMap } from '../sparql/tokens';\nimport { srsTokenMap, srsTokenTypes, multiModeLexerDefinition, } from './tokens';\nimport { Parser, Lexer, } from 'chevrotain';\nimport { TurtleParser } from '../turtle/TurtleParser';\nimport { isCstNode, unsafeTraverse } from '../helpers/cst';\nimport { defaultNamespacesMap } from 'turtle/defaultNamespaces';\nimport { getSparqlSrsVisitor, reduceVisitorItemErrors, findAndSwapPlaceholders, } from './visitor';\nimport { addThenClauseErrorsToErrors, addIfClauseErrorsToErrors, } from './customErrors';\nvar SrsParser = /** @class */ (function (_super) {\n    __extends(SrsParser, _super);\n    function SrsParser(config) {\n        var _this = _super.call(this, __assign({ outputCst: true, recoveryEnabled: true }, config), srsTokenTypes, multiModeLexerDefinition, false) || this;\n        _this.baseNamespacesMap = Object.freeze(__assign({}, defaultNamespacesMap));\n        _this.namespacesMap = {};\n        _this.visitCst = function (cst) {\n            // To save resources while parsing, the sparqlSrsVisitor is a singleton.\n            if (!_this.sparqlSrsVisitor) {\n                var BaseSrsVisitor = _this.getBaseCstVisitorConstructorWithDefaults();\n                _this.sparqlSrsVisitor = getSparqlSrsVisitor(BaseSrsVisitor);\n            }\n            else {\n                _this.sparqlSrsVisitor.$resetState();\n            }\n            _this.sparqlSrsVisitor.visit(cst, _this.input);\n        };\n        _this.getSparqlRulesFromVisitor = function (cst) {\n            _this.visitCst(cst);\n            return {\n                groupGraphPatterns: _this.sparqlSrsVisitor.$getGroupGraphPatterns(),\n                triplesBlocks: _this.sparqlSrsVisitor.$getTriplesBlocks(),\n            };\n        };\n        _this.resetManagedState = function () {\n            _this.namespacesMap = __assign({}, defaultNamespacesMap);\n            _this.semanticErrors = [];\n        };\n        _this.setBaseNamespaces = function (newBaseNamespaces) {\n            _this.baseNamespacesMap = __assign({}, newBaseNamespaces);\n        };\n        _this.tokenize = function (document) {\n            return _this.lexer.tokenize(document).tokens;\n        };\n        _this.parse = function (document) {\n            _this.resetManagedState();\n            _this.input = _this.lexer.tokenize(document).tokens;\n            var cst = _this.SrsDoc();\n            var _a = _this.getSparqlRulesFromVisitor(cst), groupGraphPatterns = _a.groupGraphPatterns, triplesBlocks = _a.triplesBlocks;\n            // Pull visitor errors\n            var errors = _this.errors.concat(groupGraphPatterns.reduce(reduceVisitorItemErrors, []), triplesBlocks.reduce(reduceVisitorItemErrors, []));\n            var semanticErrors = _this.semanticErrors.slice();\n            // Replace placeholder CST nodes created by the SRS parser with CST nodes\n            // returned by the visitor sub-parsers.\n            unsafeTraverse(cst, function (ctx, next) {\n                var node = ctx.node, parentCtx = ctx.parentCtx;\n                if (isCstNode(node)) {\n                    return next();\n                }\n                var currentTokenName = node.tokenType.tokenName;\n                if (currentTokenName !== 'GroupGraphPattern' &&\n                    currentTokenName !== 'TriplesBlock') {\n                    return;\n                }\n                var parentNode = parentCtx.node;\n                // The SRS parser parses only Turtle and SRS-specific content (RULE, IF,\n                // THEN), and creates placeholder tokens for the blocks where SPARQL is\n                // valid. The SparqlSrsVisitor visits these nodes and delegates their\n                // parsing to a SPARQL parser. Here, we replace the placeholder nodes\n                // (`GroupGraphPattern` and `TriplesBlock`) with the real ones from the\n                // SPARQL parser, collecting some custom SRS-specific errors along the\n                // way.\n                if (parentNode.name === 'IfClause') {\n                    var matchingVisitorItem = findAndSwapPlaceholders(node, parentNode, groupGraphPatterns, 'GroupGraphPattern');\n                    if (matchingVisitorItem) {\n                        addIfClauseErrorsToErrors({\n                            fullCtx: ctx,\n                            namespacesMap: __assign({}, _this.baseNamespacesMap, _this.namespacesMap),\n                            cst: matchingVisitorItem.parseResult.cst,\n                            errors: errors,\n                            semanticErrors: semanticErrors,\n                        });\n                    }\n                }\n                else if (parentNode.name === 'ThenClause') {\n                    var matchingVisitorItem = findAndSwapPlaceholders(node, parentNode, triplesBlocks, 'TriplesBlock');\n                    if (matchingVisitorItem) {\n                        addThenClauseErrorsToErrors({\n                            fullCtx: ctx,\n                            namespacesMap: __assign({}, _this.baseNamespacesMap, _this.namespacesMap),\n                            cst: matchingVisitorItem.parseResult.cst,\n                            errors: errors,\n                            semanticErrors: semanticErrors,\n                        });\n                    }\n                }\n            });\n            return {\n                semanticErrors: semanticErrors,\n                errors: errors,\n                cst: cst,\n            };\n        };\n        _this.SrsDoc = _this.RULE('SrsDoc', function () {\n            _this.SUBRULE(_this.turtleDoc);\n            _this.MANY(function () {\n                _this.SUBRULE(_this.RuleDoc);\n                _this.MANY1(function () {\n                    _this.SUBRULE(_this.triples);\n                    _this.CONSUME(sparqlTokenMap.Period);\n                });\n            });\n        });\n        _this.RuleDoc = _this.RULE('RuleDoc', function () {\n            _this.OPTION(function () { return _this.SUBRULE(_this.RuleClause); });\n            _this.SUBRULE(_this.IfClause);\n            _this.SUBRULE(_this.ThenClause);\n        });\n        _this.RuleClause = _this.RULE('RuleClause', function () {\n            _this.CONSUME(srsTokenMap.Rule);\n            _this.SUBRULE(_this.iri);\n        });\n        _this.IfClause = _this.RULE('IfClause', function () {\n            _this.CONSUME(srsTokenMap.If);\n            _this.CONSUME(srsTokenMap.GroupGraphPattern);\n        });\n        _this.ThenClause = _this.RULE('ThenClause', function () {\n            _this.CONSUME(srsTokenMap.Then);\n            _this.CONSUME(sparqlTokenMap.LCurly);\n            _this.CONSUME(srsTokenMap.TriplesBlock);\n            _this.CONSUME(srsTokenMap.EndThen);\n        });\n        _this.lexer = new Lexer(multiModeLexerDefinition);\n        Parser.performSelfAnalysis(_this);\n        return _this;\n    }\n    return SrsParser;\n}(TurtleParser));\nexport { SrsParser };\n","export * from './SrsParser';\nexport * from './tokens';\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexport var traverse = function (root, visit) {\n    _traverse(root, null, visit);\n};\nexport var unsafeTraverse = function (root, visit) {\n    _traverse(root, null, visit, false);\n};\nexport function isCstNode(object) {\n    return Boolean(object && 'name' in object);\n}\nvar TraverseContext = /** @class */ (function () {\n    function TraverseContext(_a) {\n        var node = _a.node, parentCtx = _a.parentCtx;\n        this.node = __assign({}, node);\n        this.parentCtx = __assign({}, parentCtx);\n    }\n    return TraverseContext;\n}());\nvar _traverse = function (root, ctx, visit, visitSafely) {\n    if (ctx === void 0) { ctx = new TraverseContext({ node: root }); }\n    if (visitSafely === void 0) { visitSafely = true; }\n    if (!isCstNode(root)) {\n        // must be a token\n        return visit(visitSafely ? __assign({}, ctx) : ctx);\n    }\n    // is a grammar rule node\n    var children = root.children;\n    Object.keys(children).forEach(function (key) {\n        var childType = children[key];\n        if (!childType.length) {\n            return;\n        }\n        childType.forEach(function (child) {\n            var childCtx = visitSafely\n                ? new TraverseContext({ node: child, parentCtx: ctx })\n                : { node: child, parentCtx: ctx };\n            var afterVisit = function (transformedCtx) {\n                var nextCtx = childCtx;\n                if (transformedCtx) {\n                    nextCtx = visitSafely\n                        ? new TraverseContext({\n                            node: transformedCtx.node,\n                            parentCtx: transformedCtx.parentCtx,\n                        })\n                        : {\n                            node: transformedCtx.node,\n                            parentCtx: transformedCtx.parentCtx,\n                        };\n                }\n                _traverse(child, nextCtx, visit, visitSafely);\n            };\n            visit(childCtx, afterVisit);\n        });\n    });\n};\n"],"sourceRoot":""}