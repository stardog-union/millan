{"version":3,"sources":["webpack://millan.[name]/webpack/universalModuleDefinition","webpack://millan.[name]/webpack/bootstrap","webpack://millan.[name]/./src/sparql/tokens.ts","webpack://millan.[name]/./src/turtle/TurtleParser.ts","webpack://millan.[name]/./src/sparql/keywords.ts","webpack://millan.[name]/./src/helpers/regex.ts","webpack://millan.[name]/./src/helpers/unescape.ts","webpack://millan.[name]/./src/turtle/tokens.ts","webpack://millan.[name]/./src/helpers/matchers.ts","webpack://millan.[name]/./src/sparql/terminals.ts","webpack://millan.[name]/./src/shacl/visitor.ts","webpack://millan.[name]/./src/helpers/types.ts","webpack://millan.[name]/./src/shacl/tokens.ts","webpack://millan.[name]/./src/shacl/ShaclParser.ts","webpack://millan.[name]/./src/shacl/index.ts","webpack://millan.[name]/./src/helpers/cst.ts"],"names":["root","factory","exports","module","define","amd","self","this","webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","3","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","oldJsonpFunction","slice","__webpack_exports__","sparqlTokenMap","baseTokens","pathsTokens","nonStandardTokens","stardogSparqlTokens","sparqlTokenTypes","chevrotain__WEBPACK_IMPORTED_MODULE_0__","_terminals__WEBPACK_IMPORTED_MODULE_1__","_keywords__WEBPACK_IMPORTED_MODULE_2__","IRIREF","LANGTAG","INTEGER","DECIMAL","DOUBLE","INTEGER_POSITIVE","DECIMAL_POSITIVE","DOUBLE_POSITIVE","INTEGER_NEGATIVE","DECIMAL_NEGATIVE","DOUBLE_NEGATIVE","STRING_LITERAL1","STRING_LITERAL2","STRING_LITERAL_LONG1","STRING_LITERAL_LONG2","NIL","ANON","PNAME_NS","PNAME_LN","BLANK_NODE_LABEL","VAR1","VAR2","PERCENT","Comment","pattern","group","LCurly","RCurly","LParen","RParen","WhiteSpace","SKIPPED","line_breaks","Star","Unknown","Period","QuestionMark","Plus","Minus","LBracket","RBracket","Semicolon","Comma","Pipe","ForwardSlash","Caret","DoubleCaret","Bang","LogicalOr","LogicalAnd","Equals","NotEquals","LessThan","GreaterThan","LessThanEquals","GreaterThanEquals","SELECT","CONSTRUCT","DISTINCT","START","END","VIA","CYCLIC","PATHS_SHORTEST","PATHS_ALL","PATHS","AS","WHERE","A","GroupBy","OrderBy","By","BASE","PREFIX","DESCRIBE","ASK","FROM","REDUCED","NAMED","HAVING","ASC","DESC","OFFSET","LIMIT","VALUES","LOAD","SILENT","INTO","CLEAR","DROP","CREATE","ADD","TO","MOVE","COPY","INSERT_DATA","DELETE_DATA","DELETE_WHERE","WITH","DELETE","INSERT","USING","DEFAULT","GRAPH","ALL","OPTIONAL","SERVICE","BIND","UNNEST","UNDEF","MINUS","UNION","FILTER","STR","LANG","LANGMATCHES","DATATYPE","BOUND","IRI","URI","BNODE","RAND","ABS","CEIL","FLOOR","ROUND","CONCAT","STRLEN","UCASE","LCASE","ENCODE_FOR_URI","CONTAINS","STRSTARTS","STRENDS","STRBEFORE","STRAFTER","YEAR","MONTH","DAY","HOURS","MINUTES","SECONDS","TIMEZONE","TZ","NOW","UUID","STRUUID","MD5","SHA1","SHA256","SHA384","SHA512","COALESCE","IF","STRLANG","STRDT","sameTerm","isIRI","isURI","isBlank","isLiteral","isNumeric","REGEX","SUBSTR","REPLACE","EXISTS","NOT_EXISTS","COUNT","SUM","MIN","AVG","SAMPLE","GROUP_CONCAT","SEPARATOR","TRUE","FALSE","IN","NOT_IN","MAX_LENGTH","MAX","concat","indexOfSelect","indexOf","TurtleParser","extendStatics","_tokens__WEBPACK_IMPORTED_MODULE_0__","chevrotain__WEBPACK_IMPORTED_MODULE_1__","__extends","b","setPrototypeOf","__proto__","Array","__","constructor","__assign","assign","arguments","_super","config","tokens","lexerDefinition","performSelfAnalysis","_this","outputCst","recoveryEnabled","namespacesMap","semanticErrors","resetManagedState","tokenize","document","lexer","parse","input","cst","turtleDoc","errors","RULE","MANY","SUBRULE","statement","OR","ALT","directive","triples","CONSUME","prefixID","base","sparqlPrefix","sparqlBase","TTL_PREFIX","pnameNsToken","iriToken","pnameImageWithoutColon","image","iriImage","TTL_BASE","subject","predicateObjectList","blankNodePropertyList","OPTION","SUBRULE1","verb","objectList","iri","BlankNode","collection","predicate","literal","RDFLiteral","NumericLiteral","BooleanLiteral","String","STRING_LITERAL_QUOTE","STRING_LITERAL_SINGLE_QUOTE","STRING_LITERAL_LONG_SINGLE_QUOTE","STRING_LITERAL_LONG_QUOTE","PrefixedName","prefixedNameToken","message","token","context","ruleStack","getHumanReadableRuleStack","ruleOccurrenceStack","RULE_OCCURRENCE_STACK","resyncedTokens","keywords","longer_alt","regex","or","_i","RegExp","map","_a","source","join","and","option","many","escapeSequence","escapeReplacements","\\","'","\"","f","_","~",".","-","!","$","&","(",")","*","+",",",";","=","/","?","#","@","%","unescapedStringLiteralQuote","unescapedStringLiteralSingleQuote","stringLiteralQuote","stringLiteralSingleQuote","stringLiteralLongQuote","stringLiteralLongSingleQuote","illegalIriChars","escapedIri","unescapedIri","unescape_unescape","item","replace","unicode4","unicode8","escapedChar","fromCharCode","parseInt","charCode","replacement","Error","error","turtleTokenMap","turtleTokenTypes","unicodeRegexp","api","matchers","EXPONENT","ECHAR","PLX","HEX","text","startOffset","match","exec","textToMatch","UCHAR","test","PN_CHARS_BASE","PN_CHARS_U","PN_CHARS","PN_PREFIX","PN_LOCAL","PN_LOCAL_ESC","CATCH_ALL_AT_LEAST_ONE","_regex__WEBPACK_IMPORTED_MODULE_0__","WS","VARNAME","terminals","helpers_matchers__WEBPACK_IMPORTED_MODULE_1__","STRING_LITERAL_LONG1_TOKEN","STRING_LITERAL_LONG2_TOKEN","PNAME_LN_TOKEN","label","getShaclLocalNameMatcher","shaclPrefix","escape_string_regexp_default","getUnderlyingStartToken","ctx","currentNode","children","currentNodeKey","keys","getLocalName","matcher","addPredicatesAndTypesToShape","shape","shaclRulePredicateObjectListNodes","forEach","node","child","verbTokenInsensitive","toLowerCase","shapeTypeNode","SHACL_NodeShape","types","type","SHACL_PropertyShape","SingleIriTakingPredicate","predicates","ManyIriTakingPredicate","SHACL_nodeKind","SHACL_targetNode","SHACL_path","ShapeExpectingPredicate","SHACL_hasValue","console","log","getShaclShapeFromBlankNodePropertyList","blankNodeNode","predicateObjectListNode","optionalPredicateObjectListNode","helpers_cst","shaclRulePredicateObjectList","getShaclVisitor","BaseVisitor","ShaclVisitor","shapes","visit","shaclShape","$resetState","$validateShapes","shacl","validationErrors","localNameMatcher","bnodeCount","shapesConsolidatedBySubject","reduce","consolidatedShapes","subjectImage","consolidatedShape","subjects","shapeType","pathPredicates","nonPathPredicateMap","localName","predicateImage","prefixedImage","validateVisitor","getAsTypedTuple","args","categoryTokenMap","NA","NodeKindIRI","IntTakingPredicate","StringLiteralQuoteTakingPredicate","LangStringTakingPredicate","BooleanTakingPredicate","AnyLiteralTakingPredicate","categoryTokens","localNamesByCategory","other","xsdLocalNames","localNameToCategoryMap","nameToCategoryMap","category","localNames","xsdUnprefixedTokenMap","tokenMap","tokenName","iriTokenName","iriOrPrefixCategoryToken","categories","shaclUnprefixedTokenMap","categoryToken","makePrefixer","prefix","getShaclTokenMap","memoize_one_esm","prefixes","prefixWithShacl","prefixWithXsd","xsd","shaclTokenMap","prefixedTokenName","lodash_isequal_default","a","pnameIndex","sparql_tokens","iriIndex","reverseSort","split","aName","aRemainder","_b","bName","bRemainder","aSortString","bSortString","aSuffix","bSuffix","getShaclTokenTypes","sort","accumulator","endsWith","iriTokens","pnameTokens","ShaclParser_extends","ShaclParser_assign","ShaclParser_ShaclParser","ShaclParser","validateWithVisitor","shaclVisitor","BaseSrsVisitor","getBaseCstVisitorConstructorWithDefaults","OVERRIDE_RULE","OR1","shaclPredicateIRI","shaclNodeKind","shaclTargetNode","shaclPropertyPath","shaclLiteralConstraint","shaclListTakingConstraint","shaclShapeExpectingConstraint","shaclHasValueConstraint","shaclVerbShape","SUBRULE2","shaclIRIOrLiteral","shaclShapeType","SHACL_Shape","shaclPropertyPathPath","shaclPredicatePath","shaclSequencePath","shaclAlternativePath","shaclInversePath","shaclZeroOrMorePath","shaclOneOrMorePath","shaclZeroOrOnePath","AT_LEAST_ONE","SHACL_alternativePath","SHACL_inversePath","SHACL_zeroOrMorePath","SHACL_oneOrMorePath","SHACL_zeroOrOnePath","shaclIntConstraint","shaclStringConstraint","shaclStringLiteralQuoteConstraint","shaclLangStringConstraint","shaclBooleanConstraint","shaclAnyLiteralConstraint","shaclXsdInteger","SHACL_select","SHACL_ask","SHACL_xsd_string","CONSUME1","SHACL_xsd_anyURI","shaclXsdBoolean","shaclLanguageInConstraint","shaclShapeListTakingConstraint","shaclIRIListTakingConstraint","shaclShapeOrLiteralListTakingConstraint","SHACL_languageIn","shaclStringCollection","SHACL_and","SHACL_or","SHACL_xone","shaclShapeCollection","SHACL_ignoredProperties","shaclIRICollection","SHACL_in","shaclShapeOrLiteralCollection","shaclShapeOrLiteral","shaclStringWithDoubleCaret","SHACL_xsd_boolean","shaclXsdString","SHACL_xsd_integer","shaclXsdDate","SHACL_xsd_date","shaclXsdAnyURI","traverse","unsafeTraverse","isCstNode","_traverse","Boolean","TraverseContext","parentCtx","visitSafely","childType","childCtx","transformedCtx","nextCtx"],"mappings":"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","file":"millan.shacl.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"shacl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"shacl\"] = factory();\n\telse\n\t\troot[\"millan\"] = root[\"millan\"] || {}, root[\"millan\"][\"shacl\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t3: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = (typeof self !== 'undefined' ? self : this)[\"webpackJsonp\"] = (typeof self !== 'undefined' ? self : this)[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([62,0,8]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","// @ts-ignore: import types for declarations\nimport { createToken, Lexer } from 'chevrotain';\nimport { terminals } from './terminals';\nimport { keywords } from './keywords';\nexport var sparqlTokenMap = {\n    IRIREF: terminals.IRIREF,\n    LANGTAG: terminals.LANGTAG,\n    INTEGER: terminals.INTEGER,\n    DECIMAL: terminals.DECIMAL,\n    DOUBLE: terminals.DOUBLE,\n    INTEGER_POSITIVE: terminals.INTEGER_POSITIVE,\n    DECIMAL_POSITIVE: terminals.DECIMAL_POSITIVE,\n    DOUBLE_POSITIVE: terminals.DOUBLE_POSITIVE,\n    INTEGER_NEGATIVE: terminals.INTEGER_NEGATIVE,\n    DECIMAL_NEGATIVE: terminals.DECIMAL_NEGATIVE,\n    DOUBLE_NEGATIVE: terminals.DOUBLE_NEGATIVE,\n    STRING_LITERAL1: terminals.STRING_LITERAL1,\n    STRING_LITERAL2: terminals.STRING_LITERAL2,\n    STRING_LITERAL_LONG1: terminals.STRING_LITERAL_LONG1,\n    STRING_LITERAL_LONG2: terminals.STRING_LITERAL_LONG2,\n    NIL: terminals.NIL,\n    ANON: terminals.ANON,\n    PNAME_NS: terminals.PNAME_NS,\n    PNAME_LN: terminals.PNAME_LN,\n    BLANK_NODE_LABEL: terminals.BLANK_NODE_LABEL,\n    VAR1: terminals.VAR1,\n    VAR2: terminals.VAR2,\n    PERCENT: terminals.PERCENT,\n    Comment: createToken({\n        name: 'Comment',\n        pattern: /#[^\\n]*/,\n        group: 'comments',\n    }),\n    LCurly: createToken({ name: 'LCurly', pattern: '{' }),\n    RCurly: createToken({ name: 'RCurly', pattern: '}' }),\n    LParen: createToken({ name: 'LParen', pattern: '(' }),\n    RParen: createToken({ name: 'RParen', pattern: ')' }),\n    WhiteSpace: createToken({\n        name: 'WhiteSpace',\n        pattern: /\\s+/,\n        group: Lexer.SKIPPED,\n        line_breaks: true,\n    }),\n    Star: createToken({\n        name: 'Star',\n        pattern: '*',\n    }),\n    Unknown: createToken({\n        name: 'Unknown',\n        pattern: /\\w+/,\n    }),\n    Period: createToken({\n        name: 'Period',\n        pattern: '.',\n    }),\n    QuestionMark: createToken({\n        name: 'QuestionMark',\n        pattern: '?',\n    }),\n    Plus: createToken({\n        name: 'Plus',\n        pattern: '+',\n    }),\n    Minus: createToken({\n        name: 'Minus',\n        pattern: '-',\n    }),\n    LBracket: createToken({\n        name: 'LBracket',\n        pattern: '[',\n    }),\n    RBracket: createToken({\n        name: 'RBracket',\n        pattern: ']',\n    }),\n    Semicolon: createToken({\n        name: 'Semicolon',\n        pattern: ';',\n    }),\n    Comma: createToken({\n        name: 'Comma',\n        pattern: ',',\n    }),\n    Pipe: createToken({\n        name: 'Pipe',\n        pattern: '|',\n    }),\n    ForwardSlash: createToken({\n        name: 'ForwardSlash',\n        pattern: '/',\n    }),\n    Caret: createToken({\n        name: 'Caret',\n        pattern: '^',\n    }),\n    DoubleCaret: createToken({\n        name: 'DoubleCaret',\n        pattern: '^^',\n    }),\n    Bang: createToken({\n        name: 'Bang',\n        pattern: '!',\n    }),\n    LogicalOr: createToken({\n        name: 'LogicalOr',\n        pattern: '||',\n    }),\n    LogicalAnd: createToken({\n        name: 'LogicalAnd',\n        pattern: '&&',\n    }),\n    Equals: createToken({\n        name: 'Equals',\n        pattern: '=',\n    }),\n    NotEquals: createToken({\n        name: 'NotEquals',\n        pattern: '!=',\n    }),\n    LessThan: createToken({\n        name: 'LessThan',\n        pattern: '<',\n    }),\n    GreaterThan: createToken({\n        name: 'GreaterThan',\n        pattern: '>',\n    }),\n    LessThanEquals: createToken({\n        name: 'LessThanEquals',\n        pattern: '<=',\n    }),\n    GreaterThanEquals: createToken({\n        name: 'GreaterThanEquals',\n        pattern: '>=',\n    }),\n    SELECT: keywords.SELECT,\n    CONSTRUCT: keywords.CONSTRUCT,\n    DISTINCT: keywords.DISTINCT,\n    START: keywords.START,\n    END: keywords.END,\n    VIA: keywords.VIA,\n    CYCLIC: keywords.CYCLIC,\n    PATHS_SHORTEST: keywords.PATHS_SHORTEST,\n    PATHS_ALL: keywords.PATHS_ALL,\n    PATHS: keywords.PATHS,\n    AS: keywords.AS,\n    WHERE: keywords.WHERE,\n    A: keywords.A,\n    GroupBy: keywords.GroupBy,\n    OrderBy: keywords.OrderBy,\n    By: keywords.By,\n    BASE: keywords.BASE,\n    PREFIX: keywords.PREFIX,\n    DESCRIBE: keywords.DESCRIBE,\n    ASK: keywords.ASK,\n    FROM: keywords.FROM,\n    REDUCED: keywords.REDUCED,\n    NAMED: keywords.NAMED,\n    HAVING: keywords.HAVING,\n    ASC: keywords.ASC,\n    DESC: keywords.DESC,\n    OFFSET: keywords.OFFSET,\n    LIMIT: keywords.LIMIT,\n    VALUES: keywords.VALUES,\n    LOAD: keywords.LOAD,\n    SILENT: keywords.SILENT,\n    INTO: keywords.INTO,\n    CLEAR: keywords.CLEAR,\n    DROP: keywords.DROP,\n    CREATE: keywords.CREATE,\n    ADD: keywords.ADD,\n    TO: keywords.TO,\n    MOVE: keywords.MOVE,\n    COPY: keywords.COPY,\n    INSERT_DATA: keywords.INSERT_DATA,\n    DELETE_DATA: keywords.DELETE_DATA,\n    DELETE_WHERE: keywords.DELETE_WHERE,\n    WITH: keywords.WITH,\n    DELETE: keywords.DELETE,\n    INSERT: keywords.INSERT,\n    USING: keywords.USING,\n    DEFAULT: keywords.DEFAULT,\n    GRAPH: keywords.GRAPH,\n    ALL: keywords.ALL,\n    OPTIONAL: keywords.OPTIONAL,\n    SERVICE: keywords.SERVICE,\n    BIND: keywords.BIND,\n    UNNEST: keywords.UNNEST,\n    UNDEF: keywords.UNDEF,\n    MINUS: keywords.MINUS,\n    UNION: keywords.UNION,\n    FILTER: keywords.FILTER,\n    STR: keywords.STR,\n    LANG: keywords.LANG,\n    LANGMATCHES: keywords.LANGMATCHES,\n    DATATYPE: keywords.DATATYPE,\n    BOUND: keywords.BOUND,\n    IRI: keywords.IRI,\n    URI: keywords.URI,\n    BNODE: keywords.BNODE,\n    RAND: keywords.RAND,\n    ABS: keywords.ABS,\n    CEIL: keywords.CEIL,\n    FLOOR: keywords.FLOOR,\n    ROUND: keywords.ROUND,\n    CONCAT: keywords.CONCAT,\n    STRLEN: keywords.STRLEN,\n    UCASE: keywords.UCASE,\n    LCASE: keywords.LCASE,\n    ENCODE_FOR_URI: keywords.ENCODE_FOR_URI,\n    CONTAINS: keywords.CONTAINS,\n    STRSTARTS: keywords.STRSTARTS,\n    STRENDS: keywords.STRENDS,\n    STRBEFORE: keywords.STRBEFORE,\n    STRAFTER: keywords.STRAFTER,\n    YEAR: keywords.YEAR,\n    MONTH: keywords.MONTH,\n    DAY: keywords.DAY,\n    HOURS: keywords.HOURS,\n    MINUTES: keywords.MINUTES,\n    SECONDS: keywords.SECONDS,\n    TIMEZONE: keywords.TIMEZONE,\n    TZ: keywords.TZ,\n    NOW: keywords.NOW,\n    UUID: keywords.UUID,\n    STRUUID: keywords.STRUUID,\n    MD5: keywords.MD5,\n    SHA1: keywords.SHA1,\n    SHA256: keywords.SHA256,\n    SHA384: keywords.SHA384,\n    SHA512: keywords.SHA512,\n    COALESCE: keywords.COALESCE,\n    IF: keywords.IF,\n    STRLANG: keywords.STRLANG,\n    STRDT: keywords.STRDT,\n    sameTerm: keywords.sameTerm,\n    isIRI: keywords.isIRI,\n    isURI: keywords.isURI,\n    isBlank: keywords.isBlank,\n    isLiteral: keywords.isLiteral,\n    isNumeric: keywords.isNumeric,\n    REGEX: keywords.REGEX,\n    SUBSTR: keywords.SUBSTR,\n    REPLACE: keywords.REPLACE,\n    EXISTS: keywords.EXISTS,\n    NOT_EXISTS: keywords.NOT_EXISTS,\n    COUNT: keywords.COUNT,\n    SUM: keywords.SUM,\n    MIN: keywords.MIN,\n    AVG: keywords.AVG,\n    SAMPLE: keywords.SAMPLE,\n    GROUP_CONCAT: keywords.GROUP_CONCAT,\n    SEPARATOR: keywords.SEPARATOR,\n    TRUE: keywords.TRUE,\n    FALSE: keywords.FALSE,\n    IN: keywords.IN,\n    NOT_IN: keywords.NOT_IN,\n    MAX_LENGTH: keywords.MAX_LENGTH,\n    MAX: keywords.MAX,\n};\nexport var baseTokens = [\n    sparqlTokenMap.NIL,\n    sparqlTokenMap.ANON,\n    sparqlTokenMap.LCurly,\n    sparqlTokenMap.RCurly,\n    sparqlTokenMap.LParen,\n    sparqlTokenMap.RParen,\n    sparqlTokenMap.WhiteSpace,\n    sparqlTokenMap.IRIREF,\n    sparqlTokenMap.LANGTAG,\n    sparqlTokenMap.DOUBLE,\n    sparqlTokenMap.DECIMAL,\n    sparqlTokenMap.INTEGER,\n    sparqlTokenMap.DOUBLE_POSITIVE,\n    sparqlTokenMap.DECIMAL_POSITIVE,\n    sparqlTokenMap.INTEGER_POSITIVE,\n    sparqlTokenMap.DOUBLE_NEGATIVE,\n    sparqlTokenMap.DECIMAL_NEGATIVE,\n    sparqlTokenMap.INTEGER_NEGATIVE,\n    sparqlTokenMap.STRING_LITERAL1,\n    sparqlTokenMap.STRING_LITERAL2,\n    sparqlTokenMap.STRING_LITERAL_LONG1,\n    sparqlTokenMap.STRING_LITERAL_LONG2,\n    sparqlTokenMap.PNAME_NS,\n    sparqlTokenMap.PNAME_LN,\n    sparqlTokenMap.BLANK_NODE_LABEL,\n    sparqlTokenMap.VAR1,\n    sparqlTokenMap.VAR2,\n    sparqlTokenMap.Comment,\n    sparqlTokenMap.SELECT,\n    sparqlTokenMap.CONSTRUCT,\n    sparqlTokenMap.DISTINCT,\n    sparqlTokenMap.Star,\n    sparqlTokenMap.WHERE,\n    sparqlTokenMap.GroupBy,\n    sparqlTokenMap.OrderBy,\n    sparqlTokenMap.By,\n    sparqlTokenMap.Period,\n    sparqlTokenMap.QuestionMark,\n    sparqlTokenMap.Plus,\n    sparqlTokenMap.Minus,\n    sparqlTokenMap.LBracket,\n    sparqlTokenMap.RBracket,\n    sparqlTokenMap.PERCENT,\n    sparqlTokenMap.BASE,\n    sparqlTokenMap.PREFIX,\n    sparqlTokenMap.DESCRIBE,\n    sparqlTokenMap.ASK,\n    sparqlTokenMap.FROM,\n    sparqlTokenMap.REDUCED,\n    sparqlTokenMap.NAMED,\n    sparqlTokenMap.HAVING,\n    sparqlTokenMap.ASC,\n    sparqlTokenMap.DESC,\n    sparqlTokenMap.OFFSET,\n    sparqlTokenMap.LIMIT,\n    sparqlTokenMap.VALUES,\n    sparqlTokenMap.LOAD,\n    sparqlTokenMap.SILENT,\n    sparqlTokenMap.INTO,\n    sparqlTokenMap.AS,\n    sparqlTokenMap.CLEAR,\n    sparqlTokenMap.DROP,\n    sparqlTokenMap.CREATE,\n    sparqlTokenMap.ADD,\n    sparqlTokenMap.TO,\n    sparqlTokenMap.MOVE,\n    sparqlTokenMap.COPY,\n    sparqlTokenMap.INSERT_DATA,\n    sparqlTokenMap.DELETE_DATA,\n    sparqlTokenMap.DELETE_WHERE,\n    sparqlTokenMap.WITH,\n    sparqlTokenMap.DELETE,\n    sparqlTokenMap.INSERT,\n    sparqlTokenMap.USING,\n    sparqlTokenMap.DEFAULT,\n    sparqlTokenMap.GRAPH,\n    sparqlTokenMap.ALL,\n    sparqlTokenMap.OPTIONAL,\n    sparqlTokenMap.SERVICE,\n    sparqlTokenMap.BIND,\n    sparqlTokenMap.UNDEF,\n    sparqlTokenMap.MINUS,\n    sparqlTokenMap.UNION,\n    sparqlTokenMap.FILTER,\n    sparqlTokenMap.LANGMATCHES,\n    sparqlTokenMap.LANG,\n    sparqlTokenMap.DATATYPE,\n    sparqlTokenMap.BOUND,\n    sparqlTokenMap.IRI,\n    sparqlTokenMap.URI,\n    sparqlTokenMap.BNODE,\n    sparqlTokenMap.RAND,\n    sparqlTokenMap.ABS,\n    sparqlTokenMap.CEIL,\n    sparqlTokenMap.FLOOR,\n    sparqlTokenMap.ROUND,\n    sparqlTokenMap.CONCAT,\n    sparqlTokenMap.STRLEN,\n    sparqlTokenMap.UCASE,\n    sparqlTokenMap.LCASE,\n    sparqlTokenMap.ENCODE_FOR_URI,\n    sparqlTokenMap.CONTAINS,\n    sparqlTokenMap.STRSTARTS,\n    sparqlTokenMap.STRENDS,\n    sparqlTokenMap.STRBEFORE,\n    sparqlTokenMap.STRAFTER,\n    sparqlTokenMap.YEAR,\n    sparqlTokenMap.MONTH,\n    sparqlTokenMap.DAY,\n    sparqlTokenMap.HOURS,\n    sparqlTokenMap.MINUTES,\n    sparqlTokenMap.SECONDS,\n    sparqlTokenMap.TIMEZONE,\n    sparqlTokenMap.TZ,\n    sparqlTokenMap.NOW,\n    sparqlTokenMap.UUID,\n    sparqlTokenMap.STRUUID,\n    sparqlTokenMap.MD5,\n    sparqlTokenMap.SHA1,\n    sparqlTokenMap.SHA256,\n    sparqlTokenMap.SHA384,\n    sparqlTokenMap.SHA512,\n    sparqlTokenMap.COALESCE,\n    sparqlTokenMap.IF,\n    sparqlTokenMap.STRLANG,\n    sparqlTokenMap.STRDT,\n    sparqlTokenMap.STR,\n    sparqlTokenMap.sameTerm,\n    sparqlTokenMap.isIRI,\n    sparqlTokenMap.isURI,\n    sparqlTokenMap.isBlank,\n    sparqlTokenMap.isLiteral,\n    sparqlTokenMap.isNumeric,\n    sparqlTokenMap.REGEX,\n    sparqlTokenMap.SUBSTR,\n    sparqlTokenMap.REPLACE,\n    sparqlTokenMap.EXISTS,\n    sparqlTokenMap.NOT_EXISTS,\n    sparqlTokenMap.COUNT,\n    sparqlTokenMap.SUM,\n    sparqlTokenMap.MIN,\n    sparqlTokenMap.MAX_LENGTH,\n    sparqlTokenMap.MAX,\n    sparqlTokenMap.AVG,\n    sparqlTokenMap.SAMPLE,\n    sparqlTokenMap.GROUP_CONCAT,\n    sparqlTokenMap.SEPARATOR,\n    sparqlTokenMap.TRUE,\n    sparqlTokenMap.FALSE,\n    sparqlTokenMap.Semicolon,\n    sparqlTokenMap.Comma,\n    sparqlTokenMap.ForwardSlash,\n    sparqlTokenMap.DoubleCaret,\n    sparqlTokenMap.Caret,\n    sparqlTokenMap.LogicalOr,\n    sparqlTokenMap.Pipe,\n    sparqlTokenMap.LogicalAnd,\n    sparqlTokenMap.NotEquals,\n    sparqlTokenMap.Bang,\n    sparqlTokenMap.Equals,\n    sparqlTokenMap.LessThanEquals,\n    sparqlTokenMap.GreaterThanEquals,\n    sparqlTokenMap.LessThan,\n    sparqlTokenMap.GreaterThan,\n    sparqlTokenMap.IN,\n    sparqlTokenMap.NOT_IN,\n    sparqlTokenMap.A,\n    sparqlTokenMap.Unknown,\n];\nexport var pathsTokens = [\n    sparqlTokenMap.START,\n    sparqlTokenMap.END,\n    sparqlTokenMap.VIA,\n    sparqlTokenMap.CYCLIC,\n    sparqlTokenMap.PATHS_SHORTEST,\n    sparqlTokenMap.PATHS_ALL,\n    sparqlTokenMap.PATHS,\n];\nexport var nonStandardTokens = pathsTokens.concat([sparqlTokenMap.UNNEST]);\nvar indexOfSelect = baseTokens.indexOf(sparqlTokenMap.SELECT);\nexport var stardogSparqlTokens = baseTokens.slice(0, indexOfSelect).concat(nonStandardTokens, baseTokens.slice(indexOfSelect));\nexport var sparqlTokenTypes = baseTokens.concat(nonStandardTokens);\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { turtleTokenTypes, turtleTokenMap } from './tokens';\nimport { Parser, Lexer, } from 'chevrotain';\nvar TurtleParser = /** @class */ (function (_super) {\n    __extends(TurtleParser, _super);\n    function TurtleParser(config, tokens, lexerDefinition, performSelfAnalysis) {\n        if (tokens === void 0) { tokens = turtleTokenTypes; }\n        if (lexerDefinition === void 0) { lexerDefinition = tokens; }\n        if (performSelfAnalysis === void 0) { performSelfAnalysis = true; }\n        var _this = _super.call(this, tokens, __assign({ outputCst: true, recoveryEnabled: true }, config)) || this;\n        // Parsing Turtle requires that the parser keep a map of namespaces in state.\n        // Empty prefixes, for example, are allowed only if the empty prefix has been\n        // added to the namespaces map (for now, that's all this tracks). (TODO: We\n        // might want to use a visitor for this, but I'm doing it quick-and-dirty for\n        // now.)\n        // See here: https://www.w3.org/TR/turtle/#handle-PNAME_LN\n        _this.namespacesMap = {};\n        _this.semanticErrors = [];\n        // Clears the state that we have to manage on our own for each parse (see\n        // above for details).\n        _this.resetManagedState = function () {\n            _this.namespacesMap = {};\n            _this.semanticErrors = [];\n        };\n        _this.tokenize = function (document) {\n            return _this.lexer.tokenize(document).tokens;\n        };\n        _this.parse = function (document) {\n            _this.input = _this.lexer.tokenize(document).tokens;\n            var cst = _this.turtleDoc();\n            // Next two items are copied so that they can be returned/held after parse\n            // state is cleared.\n            var errors = _this.errors.slice();\n            var semanticErrors = _this.semanticErrors.slice();\n            _this.resetManagedState();\n            return {\n                errors: errors,\n                semanticErrors: semanticErrors,\n                cst: cst,\n            };\n        };\n        _this.turtleDoc = _this.RULE('turtleDoc', function () {\n            _this.MANY(function () { return _this.SUBRULE(_this.statement); });\n        });\n        _this.statement = _this.RULE('statement', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.directive); } },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.triples);\n                        _this.CONSUME(turtleTokenMap.Period);\n                    },\n                },\n            ]);\n        });\n        _this.directive = _this.RULE('directive', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.prefixID); } },\n                { ALT: function () { return _this.SUBRULE(_this.base); } },\n                { ALT: function () { return _this.SUBRULE(_this.sparqlPrefix); } },\n                { ALT: function () { return _this.SUBRULE(_this.sparqlBase); } },\n            ]);\n        });\n        _this.prefixID = _this.RULE('prefixID', function () {\n            _this.CONSUME(turtleTokenMap.TTL_PREFIX);\n            var pnameNsToken = _this.CONSUME(turtleTokenMap.PNAME_NS);\n            var iriToken = _this.CONSUME(turtleTokenMap.IRIREF);\n            var pnameImageWithoutColon = pnameNsToken.image.slice(0, -1);\n            var iriImage = iriToken.image;\n            _this.namespacesMap[pnameImageWithoutColon] = iriImage;\n            _this.CONSUME(turtleTokenMap.Period);\n        });\n        _this.base = _this.RULE('base', function () {\n            _this.CONSUME(turtleTokenMap.TTL_BASE);\n            _this.CONSUME(turtleTokenMap.IRIREF);\n            _this.CONSUME(turtleTokenMap.Period);\n        });\n        _this.sparqlBase = _this.RULE('sparqlBase', function () {\n            _this.CONSUME(turtleTokenMap.BASE);\n            _this.CONSUME(turtleTokenMap.IRIREF);\n        });\n        _this.sparqlPrefix = _this.RULE('sparqlPrefix', function () {\n            _this.CONSUME(turtleTokenMap.PREFIX);\n            var pnameNsToken = _this.CONSUME(turtleTokenMap.PNAME_NS);\n            var iriToken = _this.CONSUME(turtleTokenMap.IRIREF);\n            var pnameImageWithoutColon = pnameNsToken.image.slice(0, -1);\n            var iriImage = iriToken.image;\n            _this.namespacesMap[pnameImageWithoutColon] = iriImage;\n        });\n        _this.triples = _this.RULE('triples', function () {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.subject);\n                        _this.SUBRULE(_this.predicateObjectList);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.blankNodePropertyList);\n                        _this.OPTION(function () { return _this.SUBRULE1(_this.predicateObjectList); });\n                    },\n                },\n            ]);\n        });\n        _this.predicateObjectList = _this.RULE('predicateObjectList', function () {\n            _this.SUBRULE(_this.verb);\n            _this.SUBRULE(_this.objectList);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.SUBRULE1(_this.verb);\n                    _this.SUBRULE1(_this.objectList);\n                });\n            });\n        });\n        _this.subject = _this.RULE('subject', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNode); } },\n                { ALT: function () { return _this.SUBRULE(_this.collection); } },\n            ]);\n        });\n        _this.predicate = _this.RULE('predicate', function () {\n            _this.SUBRULE(_this.iri);\n        });\n        _this.objectList = _this.RULE('objectList', function () {\n            _this.SUBRULE(_this.object);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Comma);\n                _this.SUBRULE1(_this.object);\n            });\n        });\n        _this.verb = _this.RULE('verb', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.predicate); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.A); } },\n            ]);\n        });\n        _this.literal = _this.RULE('literal', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.RDFLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.BooleanLiteral); } },\n            ]);\n        });\n        _this.blankNodePropertyList = _this.RULE('blankNodePropertyList', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.SUBRULE(_this.predicateObjectList);\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.object = _this.RULE('object', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNode); } },\n                { ALT: function () { return _this.SUBRULE(_this.collection); } },\n                { ALT: function () { return _this.SUBRULE(_this.blankNodePropertyList); } },\n                { ALT: function () { return _this.SUBRULE(_this.literal); } },\n            ]);\n        });\n        _this.collection = _this.RULE('collection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () { return _this.SUBRULE(_this.object); });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.NumericLiteral = _this.RULE('NumericLiteral', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.INTEGER); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.DECIMAL); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.DOUBLE); } },\n            ]);\n        });\n        _this.RDFLiteral = _this.RULE('RDFLiteral', function () {\n            _this.SUBRULE(_this.String);\n            _this.OPTION(function () {\n                _this.OR([\n                    { ALT: function () { return _this.CONSUME(turtleTokenMap.LANGTAG); } },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(turtleTokenMap.DoubleCaret);\n                            _this.SUBRULE(_this.iri);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.BooleanLiteral = _this.RULE('BooleanLiteral', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.TRUE); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.FALSE); } },\n            ]);\n        });\n        _this.String = _this.RULE('String', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_QUOTE); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_SINGLE_QUOTE); } },\n                {\n                    ALT: function () {\n                        return _this.CONSUME(turtleTokenMap.STRING_LITERAL_LONG_SINGLE_QUOTE);\n                    },\n                },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_LONG_QUOTE); } },\n            ]);\n        });\n        _this.iri = _this.RULE('iri', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.IRIREF); } },\n                { ALT: function () { return _this.SUBRULE(_this.PrefixedName); } },\n            ]);\n        });\n        _this.PrefixedName = _this.RULE('PrefixedName', function () {\n            var prefixedNameToken = _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.PNAME_LN); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.PNAME_NS); } },\n            ]);\n            var pnameNsImage = prefixedNameToken.image.slice(0, prefixedNameToken.image.indexOf(':'));\n            if (!(pnameNsImage in _this.namespacesMap)) {\n                _this.semanticErrors.push({\n                    name: 'NoNamespacePrefixError',\n                    message: 'A prefix was used for which there was no namespace defined.',\n                    token: prefixedNameToken,\n                    context: {\n                        ruleStack: _this.getHumanReadableRuleStack(),\n                        ruleOccurrenceStack: _this.RULE_OCCURRENCE_STACK.slice(),\n                    },\n                    resyncedTokens: [],\n                });\n            }\n        });\n        _this.BlankNode = _this.RULE('BlankNode', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.BLANK_NODE_LABEL); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.ANON); } },\n            ]);\n        });\n        _this.lexer = new Lexer(lexerDefinition);\n        if (performSelfAnalysis) {\n            Parser.performSelfAnalysis(_this);\n        }\n        return _this;\n    }\n    return TurtleParser;\n}(Parser));\nexport { TurtleParser };\n","// @ts-ignore: import types for declarations\nimport { createToken } from 'chevrotain';\nvar MAX_LENGTH = createToken({\n    name: 'MAX_LENGTH',\n    pattern: /MAX LENGTH/i,\n});\nexport var keywords = {\n    SELECT: createToken({\n        name: 'SELECT',\n        pattern: /SELECT/i,\n    }),\n    CONSTRUCT: createToken({\n        name: 'CONSTRUCT',\n        pattern: /CONSTRUCT/i,\n    }),\n    DISTINCT: createToken({\n        name: 'DISTINCT',\n        pattern: /DISTINCT/i,\n    }),\n    START: createToken({\n        name: 'START',\n        pattern: /START/i,\n    }),\n    END: createToken({\n        name: 'END',\n        pattern: /END/i,\n    }),\n    VIA: createToken({\n        name: 'VIA',\n        pattern: /VIA/i,\n    }),\n    PATHS: createToken({\n        name: 'PATHS',\n        pattern: /PATHS/i,\n    }),\n    PATHS_ALL: createToken({\n        name: 'PATHS_ALL',\n        pattern: /PATHS ALL/i,\n    }),\n    PATHS_SHORTEST: createToken({\n        name: 'PATHS_SHORTEST',\n        pattern: /PATHS SHORTEST/i,\n    }),\n    CYCLIC: createToken({\n        name: 'CYCLIC',\n        pattern: /CYCLIC/i,\n    }),\n    AS: createToken({\n        name: 'AS',\n        pattern: /AS/i,\n    }),\n    WHERE: createToken({\n        name: 'WHERE',\n        pattern: /WHERE/i,\n    }),\n    A: createToken({\n        name: 'A',\n        pattern: /a/i,\n    }),\n    GroupBy: createToken({\n        name: 'GroupBy',\n        pattern: /group by/i,\n    }),\n    OrderBy: createToken({\n        name: 'OrderBy',\n        pattern: /order by/i,\n    }),\n    By: createToken({\n        name: 'By',\n        pattern: /By/i,\n    }),\n    BASE: createToken({\n        name: 'BASE',\n        pattern: /BASE/i,\n    }),\n    PREFIX: createToken({\n        name: 'PREFIX',\n        pattern: /PREFIX/i,\n    }),\n    DESCRIBE: createToken({\n        name: 'DESCRIBE',\n        pattern: /DESCRIBE/i,\n    }),\n    ASK: createToken({\n        name: 'ASK',\n        pattern: /ASK/i,\n    }),\n    FROM: createToken({\n        name: 'FROM',\n        pattern: /FROM/i,\n    }),\n    REDUCED: createToken({\n        name: 'REDUCED',\n        pattern: /REDUCED/i,\n    }),\n    NAMED: createToken({\n        name: 'NAMED',\n        pattern: /NAMED/i,\n    }),\n    HAVING: createToken({\n        name: 'HAVING',\n        pattern: /HAVING/i,\n    }),\n    ASC: createToken({\n        name: 'ASC',\n        pattern: /ASC/i,\n    }),\n    DESC: createToken({\n        name: 'DESC',\n        pattern: /DESC/i,\n    }),\n    OFFSET: createToken({\n        name: 'OFFSET',\n        pattern: /OFFSET/i,\n    }),\n    LIMIT: createToken({\n        name: 'LIMIT',\n        pattern: /LIMIT/i,\n    }),\n    VALUES: createToken({\n        name: 'VALUES',\n        pattern: /VALUES/i,\n    }),\n    LOAD: createToken({\n        name: 'LOAD',\n        pattern: /LOAD/i,\n    }),\n    SILENT: createToken({\n        name: 'SILENT',\n        pattern: /SILENT/i,\n    }),\n    INTO: createToken({\n        name: 'INTO',\n        pattern: /INTO/i,\n    }),\n    CLEAR: createToken({\n        name: 'CLEAR',\n        pattern: /CLEAR/i,\n    }),\n    DROP: createToken({\n        name: 'DROP',\n        pattern: /DROP/i,\n    }),\n    CREATE: createToken({\n        name: 'CREATE',\n        pattern: /CREATE/i,\n    }),\n    ADD: createToken({\n        name: 'ADD',\n        pattern: /ADD/i,\n    }),\n    TO: createToken({\n        name: 'TO',\n        pattern: /TO/i,\n    }),\n    MOVE: createToken({\n        name: 'MOVE',\n        pattern: /MOVE/i,\n    }),\n    COPY: createToken({\n        name: 'COPY',\n        pattern: /COPY/i,\n    }),\n    INSERT_DATA: createToken({\n        name: 'INSERT_DATA',\n        pattern: /Insert +Data/i,\n    }),\n    DELETE_DATA: createToken({\n        name: 'DELETE_DATA',\n        pattern: /Delete +Data/i,\n    }),\n    DELETE_WHERE: createToken({\n        name: 'DELETE_WHERE',\n        pattern: /Delete +Where/i,\n    }),\n    WITH: createToken({\n        name: 'WITH',\n        pattern: /WITH/i,\n    }),\n    DELETE: createToken({\n        name: 'DELETE',\n        pattern: /DELETE/i,\n    }),\n    INSERT: createToken({\n        name: 'INSERT',\n        pattern: /INSERT/i,\n    }),\n    USING: createToken({\n        name: 'USING',\n        pattern: /USING/i,\n    }),\n    DEFAULT: createToken({\n        name: 'DEFAULT',\n        pattern: /DEFAULT/i,\n    }),\n    GRAPH: createToken({\n        name: 'GRAPH',\n        pattern: /GRAPH/i,\n    }),\n    ALL: createToken({\n        name: 'ALL',\n        pattern: /ALL/i,\n    }),\n    OPTIONAL: createToken({\n        name: 'OPTIONAL',\n        pattern: /OPTIONAL/i,\n    }),\n    SERVICE: createToken({\n        name: 'SERVICE',\n        pattern: /SERVICE/i,\n    }),\n    BIND: createToken({\n        name: 'BIND',\n        pattern: /BIND/i,\n    }),\n    UNNEST: createToken({\n        name: 'UNNEST',\n        pattern: /UNNEST/i,\n    }),\n    UNDEF: createToken({\n        name: 'UNDEF',\n        pattern: /UNDEF/i,\n    }),\n    MINUS: createToken({\n        name: 'MINUS',\n        pattern: /MINUS/i,\n    }),\n    UNION: createToken({\n        name: 'UNION',\n        pattern: /UNION/i,\n    }),\n    FILTER: createToken({\n        name: 'FILTER',\n        pattern: /FILTER/i,\n    }),\n    STR: createToken({\n        name: 'STR',\n        pattern: /STR/i,\n    }),\n    LANG: createToken({\n        name: 'LANG',\n        pattern: /LANG/i,\n    }),\n    LANGMATCHES: createToken({\n        name: 'LANGMATCHES',\n        pattern: /LANGMATCHES/i,\n    }),\n    DATATYPE: createToken({\n        name: 'DATATYPE',\n        pattern: /DATATYPE/i,\n    }),\n    BOUND: createToken({\n        name: 'BOUND',\n        pattern: /BOUND/i,\n    }),\n    IRI: createToken({\n        name: 'IRI',\n        pattern: /IRI/i,\n    }),\n    URI: createToken({\n        name: 'URI',\n        pattern: /URI/i,\n    }),\n    BNODE: createToken({\n        name: 'BNODE',\n        pattern: /BNODE/i,\n    }),\n    RAND: createToken({\n        name: 'RAND',\n        pattern: /RAND/i,\n    }),\n    ABS: createToken({\n        name: 'ABS',\n        pattern: /ABS/i,\n    }),\n    CEIL: createToken({\n        name: 'CEIL',\n        pattern: /CEIL/i,\n    }),\n    FLOOR: createToken({\n        name: 'FLOOR',\n        pattern: /FLOOR/i,\n    }),\n    ROUND: createToken({\n        name: 'ROUND',\n        pattern: /ROUND/i,\n    }),\n    CONCAT: createToken({\n        name: 'CONCAT',\n        pattern: /CONCAT/i,\n    }),\n    STRLEN: createToken({\n        name: 'STRLEN',\n        pattern: /STRLEN/i,\n    }),\n    UCASE: createToken({\n        name: 'UCASE',\n        pattern: /UCASE/i,\n    }),\n    LCASE: createToken({\n        name: 'LCASE',\n        pattern: /LCASE/i,\n    }),\n    ENCODE_FOR_URI: createToken({\n        name: 'ENCODE_FOR_URI',\n        pattern: /ENCODE_FOR_URI/i,\n    }),\n    CONTAINS: createToken({\n        name: 'CONTAINS',\n        pattern: /CONTAINS/i,\n    }),\n    STRSTARTS: createToken({\n        name: 'STRSTARTS',\n        pattern: /STRSTARTS/i,\n    }),\n    STRENDS: createToken({\n        name: 'STRENDS',\n        pattern: /STRENDS/i,\n    }),\n    STRBEFORE: createToken({\n        name: 'STRBEFORE',\n        pattern: /STRBEFORE/i,\n    }),\n    STRAFTER: createToken({\n        name: 'STRAFTER',\n        pattern: /STRAFTER/i,\n    }),\n    YEAR: createToken({\n        name: 'YEAR',\n        pattern: /YEAR/i,\n    }),\n    MONTH: createToken({\n        name: 'MONTH',\n        pattern: /MONTH/i,\n    }),\n    DAY: createToken({\n        name: 'DAY',\n        pattern: /DAY/i,\n    }),\n    HOURS: createToken({\n        name: 'HOURS',\n        pattern: /HOURS/i,\n    }),\n    MINUTES: createToken({\n        name: 'MINUTES',\n        pattern: /MINUTES/i,\n    }),\n    SECONDS: createToken({\n        name: 'SECONDS',\n        pattern: /SECONDS/i,\n    }),\n    TIMEZONE: createToken({\n        name: 'TIMEZONE',\n        pattern: /TIMEZONE/i,\n    }),\n    TZ: createToken({\n        name: 'TZ',\n        pattern: /TZ/i,\n    }),\n    NOW: createToken({\n        name: 'NOW',\n        pattern: /NOW/i,\n    }),\n    UUID: createToken({\n        name: 'UUID',\n        pattern: /UUID/i,\n    }),\n    STRUUID: createToken({\n        name: 'STRUUID',\n        pattern: /STRUUID/i,\n    }),\n    MD5: createToken({\n        name: 'MD5',\n        pattern: /MD5/i,\n    }),\n    SHA1: createToken({\n        name: 'SHA1',\n        pattern: /SHA1/i,\n    }),\n    SHA256: createToken({\n        name: 'SHA256',\n        pattern: /SHA256/i,\n    }),\n    SHA384: createToken({\n        name: 'SHA384',\n        pattern: /SHA384/i,\n    }),\n    SHA512: createToken({\n        name: 'SHA512',\n        pattern: /SHA512/i,\n    }),\n    COALESCE: createToken({\n        name: 'COALESCE',\n        pattern: /COALESCE/i,\n    }),\n    IF: createToken({\n        name: 'IF',\n        pattern: /IF/i,\n    }),\n    STRLANG: createToken({\n        name: 'STRLANG',\n        pattern: /STRLANG/i,\n    }),\n    STRDT: createToken({\n        name: 'STRDT',\n        pattern: /STRDT/i,\n    }),\n    sameTerm: createToken({\n        name: 'sameTerm',\n        pattern: /sameTerm/i,\n    }),\n    isIRI: createToken({\n        name: 'isIRI',\n        pattern: /isIRI/i,\n    }),\n    isURI: createToken({\n        name: 'isURI',\n        pattern: /isURI/i,\n    }),\n    isBlank: createToken({\n        name: 'isBlank',\n        pattern: /isBlank/i,\n    }),\n    isLiteral: createToken({\n        name: 'isLiteral',\n        pattern: /isLiteral/i,\n    }),\n    isNumeric: createToken({\n        name: 'isNumeric',\n        pattern: /isNumeric/i,\n    }),\n    REGEX: createToken({\n        name: 'REGEX',\n        pattern: /REGEX/i,\n    }),\n    SUBSTR: createToken({\n        name: 'SUBSTR',\n        pattern: /SUBSTR/i,\n    }),\n    REPLACE: createToken({\n        name: 'REPLACE',\n        pattern: /REPLACE/i,\n    }),\n    EXISTS: createToken({\n        name: 'EXISTS',\n        pattern: /EXISTS/i,\n    }),\n    NOT_EXISTS: createToken({\n        name: 'NOT_EXISTS',\n        pattern: /NOT EXISTS/i,\n    }),\n    COUNT: createToken({\n        name: 'COUNT',\n        pattern: /COUNT/i,\n    }),\n    SUM: createToken({\n        name: 'SUM',\n        pattern: /SUM/i,\n    }),\n    MIN: createToken({\n        name: 'MIN',\n        pattern: /MIN/i,\n    }),\n    AVG: createToken({\n        name: 'AVG',\n        pattern: /AVG/i,\n    }),\n    SAMPLE: createToken({\n        name: 'SAMPLE',\n        pattern: /SAMPLE/i,\n    }),\n    GROUP_CONCAT: createToken({\n        name: 'GROUP_CONCAT',\n        pattern: /GROUP_CONCAT/i,\n    }),\n    SEPARATOR: createToken({\n        name: 'SEPARATOR',\n        pattern: /SEPARATOR/i,\n    }),\n    TRUE: createToken({\n        name: 'TRUE',\n        pattern: /TRUE/i,\n    }),\n    FALSE: createToken({\n        name: 'FALSE',\n        pattern: /FALSE/i,\n    }),\n    IN: createToken({\n        name: 'IN',\n        pattern: /IN/i,\n    }),\n    NOT_IN: createToken({\n        name: 'NOT_IN',\n        pattern: /NOT IN/i,\n    }),\n    MAX_LENGTH: MAX_LENGTH,\n    MAX: createToken({\n        name: 'MAX',\n        pattern: /MAX/i,\n        longer_alt: MAX_LENGTH,\n    }),\n};\n","export var regex = {\n    or: function () {\n        var r = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            r[_i] = arguments[_i];\n        }\n        return new RegExp(r.map(function (_a) {\n            var source = _a.source;\n            return \"(\" + source + \")\";\n        }).join('|'));\n    },\n    and: function () {\n        var r = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            r[_i] = arguments[_i];\n        }\n        return new RegExp(r.map(function (_a) {\n            var source = _a.source;\n            return \"(\" + source + \")\";\n        }).join(''));\n    },\n    option: function (r) {\n        return new RegExp(\"(\" + r.source + \")?\");\n    },\n    many: function (r) {\n        return new RegExp(\"(\" + r.source + \")*\");\n    },\n};\n","/*\nCopyright ©2012–2018 Ruben Verborgh\nWith modifications Copyright ©2018 Stardog Union\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nvar escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\[uU]|\\\\(.)/g;\nvar escapeReplacements = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\"': '\"',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    f: '\\f',\n    b: '\\b',\n    _: '_',\n    '~': '~',\n    '.': '.',\n    '-': '-',\n    '!': '!',\n    $: '$',\n    '&': '&',\n    '(': '(',\n    ')': ')',\n    '*': '*',\n    '+': '+',\n    ',': ',',\n    ';': ';',\n    '=': '=',\n    '/': '/',\n    '?': '?',\n    '#': '#',\n    '@': '@',\n    '%': '%',\n};\nexport var unescapedStringLiteralQuote = /^\"([^\"\\\\\\r\\n]+)\"/; // non-empty string without escape sequences\nexport var unescapedStringLiteralSingleQuote = /^'([^'\\\\\\r\\n]+)'/;\nexport var stringLiteralQuote = /^\"((?:[^\"\\\\\\r\\n]|\\\\.)*)\"(?=[^\"])/;\nexport var stringLiteralSingleQuote = /^'((?:[^'\\\\\\r\\n]|\\\\.)*)'(?=[^'])/;\nexport var stringLiteralLongQuote = /^\"\"\"([^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*)\"\"\"/;\nexport var stringLiteralLongSingleQuote = /^'''([^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*)'''/;\nexport var illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\nexport var escapedIri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/;\nexport var unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/;\n// Handle special unescaping needs related to the IRIREF rule and others.\nexport var unescape = function (item) {\n    try {\n        return item.replace(escapeSequence, function (_, unicode4, unicode8, escapedChar) {\n            if (unicode4) {\n                return String.fromCharCode(parseInt(unicode4, 16));\n            }\n            else if (unicode8) {\n                var charCode = parseInt(unicode8, 16);\n                if (charCode <= 0xffff) {\n                    return String.fromCharCode(charCode);\n                }\n                return String.fromCharCode(0xd800 + (charCode -= 0x10000) / 0x400, 0xdc00 + (charCode & 0x3ff));\n            }\n            else {\n                var replacement = escapeReplacements[escapedChar];\n                if (!replacement) {\n                    throw new Error();\n                }\n                return replacement;\n            }\n        });\n    }\n    catch (error) {\n        return null;\n    }\n};\n","import { sparqlTokenMap } from '../sparql/tokens';\nimport { createToken } from 'chevrotain';\nimport { regex } from '../helpers/regex';\nimport { EXPONENT, ECHAR, PLX, HEX, PN_CHARS_BASE, PN_CHARS_U, PN_CHARS, PN_PREFIX, PN_LOCAL, PN_LOCAL_ESC, } from '../helpers/matchers';\nimport { unescape, stringLiteralLongSingleQuote, stringLiteralLongQuote, unescapedStringLiteralQuote, stringLiteralQuote, unescapedStringLiteralSingleQuote, stringLiteralSingleQuote, unescapedIri, escapedIri, illegalIriChars, } from '../helpers/unescape';\nvar unicodeRegexp = /[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nexport var turtleTokenMap = {\n    Comment: createToken({\n        name: 'Comment',\n        pattern: /#[^\\n]*/,\n        group: 'comments',\n    }),\n    LBracket: sparqlTokenMap.LBracket,\n    RBracket: sparqlTokenMap.RBracket,\n    LParen: sparqlTokenMap.LParen,\n    RParen: sparqlTokenMap.RParen,\n    Period: sparqlTokenMap.Period,\n    WhiteSpace: sparqlTokenMap.WhiteSpace,\n    TRUE: sparqlTokenMap.TRUE,\n    FALSE: sparqlTokenMap.FALSE,\n    DoubleCaret: sparqlTokenMap.DoubleCaret,\n    Comma: sparqlTokenMap.Comma,\n    Semicolon: sparqlTokenMap.Semicolon,\n    A: sparqlTokenMap.A,\n    PREFIX: sparqlTokenMap.PREFIX,\n    BASE: sparqlTokenMap.BASE,\n    PNAME_NS: sparqlTokenMap.PNAME_NS,\n    PNAME_LN: sparqlTokenMap.PNAME_LN,\n    BLANK_NODE_LABEL: sparqlTokenMap.BLANK_NODE_LABEL,\n    TTL_BASE: createToken({ name: 'TTL_BASE', pattern: /@base/ }),\n    TTL_PREFIX: createToken({ name: 'TTL_PREFIX', pattern: /@prefix/ }),\n    LANGTAG: sparqlTokenMap.LANGTAG,\n    INTEGER: createToken({\n        name: 'INTEGER',\n        pattern: regex.and(regex.option(/[+-]/), /\\d+/),\n    }),\n    DECIMAL: createToken({\n        name: 'DECIMAL',\n        pattern: regex.and(regex.option(/[+-]/), /(\\d*\\.\\d+)/),\n    }),\n    DOUBLE: createToken({\n        name: 'DOUBLE',\n        pattern: regex.and(regex.option(/[+-]/), regex.or(regex.and(/\\d+\\.\\d*/, EXPONENT), regex.and(/\\.\\d+/, EXPONENT), regex.and(/\\d+/, EXPONENT))),\n    }),\n    EXPONENT: createToken({ name: 'EXPONENT', pattern: EXPONENT }),\n    ECHAR: createToken({ name: 'ECHAR', pattern: ECHAR }),\n    ANON: sparqlTokenMap.ANON,\n    PLX: createToken({ name: 'PLX', pattern: PLX }),\n    PERCENT: sparqlTokenMap.PERCENT,\n    HEX: createToken({ name: 'HEX', pattern: HEX }),\n    STRING_LITERAL_LONG_SINGLE_QUOTE: createToken({\n        name: 'STRING_LITERAL_LONG_SINGLE_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var match = stringLiteralLongSingleQuote.exec(text.slice(startOffset));\n            if (!match || unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: true,\n    }),\n    STRING_LITERAL_LONG_QUOTE: createToken({\n        name: 'STRING_LITERAL_LONG_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var match = stringLiteralLongQuote.exec(text.slice(startOffset));\n            if (!match || unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: true,\n    }),\n    STRING_LITERAL_QUOTE: createToken({\n        name: 'STRING_LITERAL_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedStringLiteralQuote.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = stringLiteralQuote.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            if (unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    STRING_LITERAL_SINGLE_QUOTE: createToken({\n        name: 'STRING_LITERAL_SINGLE_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedStringLiteralSingleQuote.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = stringLiteralSingleQuote.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            if (unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    UCHAR: createToken({\n        name: 'UCHAR',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            return unicodeRegexp.exec(text.slice(startOffset));\n        },\n        line_breaks: false,\n    }),\n    IRIREF: createToken({\n        name: 'IRIREF',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedIri.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = escapedIri.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            var value = unescape(match[1]);\n            if (value === null || illegalIriChars.test(value)) {\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    PN_CHARS_BASE: createToken({ name: 'PN_CHARS_BASE', pattern: PN_CHARS_BASE }),\n    PN_CHARS_U: createToken({ name: 'PN_CHARS_U', pattern: PN_CHARS_U }),\n    PN_CHARS: createToken({ name: 'PN_CHARS', pattern: PN_CHARS }),\n    PN_PREFIX: createToken({ name: 'PN_PREFIX', pattern: PN_PREFIX }),\n    PN_LOCAL: createToken({ name: 'PN_LOCAL', pattern: PN_LOCAL }),\n    PN_LOCAL_ESC: createToken({ name: 'PN_LOCAL_ESC', pattern: PN_LOCAL_ESC }),\n    Unknown: createToken({\n        name: 'Unknown',\n        pattern: /\\w+/,\n    }),\n};\nexport var turtleTokenTypes = [\n    turtleTokenMap.Comment,\n    sparqlTokenMap.ANON,\n    sparqlTokenMap.LBracket,\n    sparqlTokenMap.RBracket,\n    sparqlTokenMap.LParen,\n    sparqlTokenMap.RParen,\n    sparqlTokenMap.WhiteSpace,\n    sparqlTokenMap.TRUE,\n    sparqlTokenMap.FALSE,\n    sparqlTokenMap.Comma,\n    sparqlTokenMap.Semicolon,\n    sparqlTokenMap.PNAME_NS,\n    sparqlTokenMap.A,\n    sparqlTokenMap.PREFIX,\n    sparqlTokenMap.BASE,\n    sparqlTokenMap.PNAME_LN,\n    sparqlTokenMap.BLANK_NODE_LABEL,\n    turtleTokenMap.TTL_BASE,\n    turtleTokenMap.TTL_PREFIX,\n    sparqlTokenMap.LANGTAG,\n    turtleTokenMap.DOUBLE,\n    turtleTokenMap.DECIMAL,\n    sparqlTokenMap.Period,\n    sparqlTokenMap.DoubleCaret,\n    turtleTokenMap.IRIREF,\n    turtleTokenMap.STRING_LITERAL_LONG_SINGLE_QUOTE,\n    turtleTokenMap.STRING_LITERAL_LONG_QUOTE,\n    turtleTokenMap.STRING_LITERAL_QUOTE,\n    turtleTokenMap.STRING_LITERAL_SINGLE_QUOTE,\n    turtleTokenMap.INTEGER,\n    turtleTokenMap.EXPONENT,\n    turtleTokenMap.PLX,\n    sparqlTokenMap.PERCENT,\n    turtleTokenMap.HEX,\n    turtleTokenMap.PN_CHARS_BASE,\n    turtleTokenMap.PN_CHARS_U,\n    turtleTokenMap.PN_CHARS,\n    turtleTokenMap.PN_PREFIX,\n    turtleTokenMap.PN_LOCAL,\n    turtleTokenMap.PN_LOCAL_ESC,\n    turtleTokenMap.ECHAR,\n    turtleTokenMap.UCHAR,\n    turtleTokenMap.Unknown,\n];\n","import { regex } from './regex';\nexport var CATCH_ALL = /[\\s\\S]*/; // equivalent to /.*/s, which isn't a JS standard yet\nexport var CATCH_ALL_AT_LEAST_ONE = /[\\s\\S]+/; // equivalent to /.+/s, which isn't a JS standard yet\nexport var IRIREF = /<[^<>\\\\{}|\\^`\\u0000-\\u0020]*>/;\nexport var PN_CHARS_BASE = /[A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\nexport var LANGTAG = /@[a-zA-Z]+(-[a-zA-Z0-9]+)*/;\nexport var INTEGER = /\\d+/;\nexport var DECIMAL = /(\\d*\\.\\d+)|(\\d+\\.\\d*)/;\nexport var EXPONENT = /[eE][+-]?\\d+/;\nexport var ECHAR = /\\\\[tbnrf\"'\\\\]/;\nexport var WS = /[\\u0020\\u0009\\u000d\\u000a]/;\nexport var HEX = /[0-9A-Fa-f]/;\nexport var PN_LOCAL_ESC = /\\\\[_~.\\-!\\$&'()*+,=\\/?#@%;]/;\nexport var PN_CHARS_U = regex.or(PN_CHARS_BASE, /_/);\nexport var PN_CHARS = regex.or(PN_CHARS_U, /-/, /\\d/, /\\u00b7/, /[\\u0300-\\u036f]/, /[\\u203f-\\u2040]/);\nexport var PN_PREFIX = regex.and(PN_CHARS_BASE, regex.option(regex.and(regex.many(regex.or(PN_CHARS, /\\./)), PN_CHARS)));\nexport var PERCENT = regex.and(/%/, HEX, HEX);\nexport var PLX = regex.or(PERCENT, PN_LOCAL_ESC);\nexport var PN_LOCAL = regex.and(regex.or(PN_CHARS_U, /:/, /\\d/, PLX), regex.option(regex.and(regex.many(regex.or(PN_CHARS, /\\./, /:/, PLX)), regex.or(PN_CHARS, /:/, PLX))));\nexport var VARNAME = regex.and(regex.or(PN_CHARS_U, /\\d/), regex.many(regex.or(PN_CHARS_U, /\\d/, /\\u00b7/, /[\\u0300-\\u036f]/, /[\\u203f-\\u2040]/)));\nexport var ANON = regex.and(/\\[/, regex.many(WS), /\\]/);\nexport var NIL = regex.and(/\\(/, regex.many(WS), /\\)/);\nexport var STRING_LITERAL1 = regex.and(/'/, regex.many(regex.or(/[^\\u0027\\u005C\\u000A\\u000D]/, ECHAR)), /'/);\nexport var STRING_LITERAL2 = regex.and(/\"/, regex.many(regex.or(/[^\\u0022\\u005C\\u000A\\u000D]/, ECHAR)), /\"/);\nexport var STRING_LITERAL_LONG1 = regex.and(/'''/, regex.many(regex.and(regex.option(regex.or(/'/, /''/)), regex.or(/[^'\\\\]/, ECHAR))), /'''/);\nexport var STRING_LITERAL_LONG2 = regex.and(/\"\"\"/, regex.many(regex.and(regex.option(regex.or(/\"/, /\"\"/)), regex.or(/[^\"\\\\]/, ECHAR))), /\"\"\"/);\nexport var DOUBLE = regex.or(regex.and(/\\d+\\.\\d*/, EXPONENT), regex.and(/\\.\\d+/, EXPONENT), regex.and(/\\d+/, EXPONENT));\nexport var INTEGER_POSITIVE = regex.and(/\\+/, INTEGER);\nexport var DECIMAL_POSITIVE = regex.and(/\\+/, DECIMAL);\nexport var DOUBLE_POSITIVE = regex.and(/\\+/, DOUBLE);\nexport var INTEGER_NEGATIVE = regex.and(/-/, INTEGER);\nexport var DECIMAL_NEGATIVE = regex.and(/-/, DECIMAL);\nexport var DOUBLE_NEGATIVE = regex.and(/-/, DOUBLE);\nexport var VAR1 = regex.and(/\\?/, VARNAME);\nexport var VAR2 = regex.and(/\\$/, VARNAME);\nexport var BLANK_NODE_LABEL = regex.and(/_:/, regex.or(PN_CHARS_U, /\\d/), regex.option(regex.and(regex.many(regex.or(PN_CHARS, /\\./)), PN_CHARS)));\nexport var PNAME_NS = regex.and(regex.option(PN_PREFIX), /:/);\nexport var PNAME_LN = regex.and(PNAME_NS, PN_LOCAL);\n","// @ts-ignore: import types for declarations\nimport { createToken } from 'chevrotain';\nimport { STRING_LITERAL_LONG1, STRING_LITERAL_LONG2, PNAME_LN, IRIREF, LANGTAG, INTEGER, DECIMAL, DOUBLE, INTEGER_POSITIVE, DECIMAL_POSITIVE, DOUBLE_POSITIVE, INTEGER_NEGATIVE, DECIMAL_NEGATIVE, DOUBLE_NEGATIVE, STRING_LITERAL1, STRING_LITERAL2, NIL, ANON, PNAME_NS, BLANK_NODE_LABEL, VAR1, VAR2, PERCENT, } from 'helpers/matchers';\nvar STRING_LITERAL_LONG1_TOKEN = createToken({\n    name: 'STRING_LITERAL_LONG1',\n    pattern: STRING_LITERAL_LONG1,\n});\nvar STRING_LITERAL_LONG2_TOKEN = createToken({\n    name: 'STRING_LITERAL_LONG2',\n    pattern: STRING_LITERAL_LONG2,\n});\nvar PNAME_LN_TOKEN = createToken({\n    name: 'PNAME_LN',\n    pattern: PNAME_LN,\n});\nexport var terminals = {\n    IRIREF: createToken({\n        name: 'IRIREF',\n        pattern: IRIREF,\n        label: '<http://example.com>',\n    }),\n    LANGTAG: createToken({\n        name: 'LANGTAG',\n        pattern: LANGTAG,\n    }),\n    INTEGER: createToken({\n        name: 'INTEGER',\n        pattern: INTEGER,\n    }),\n    DECIMAL: createToken({\n        name: 'DECIMAL',\n        pattern: DECIMAL,\n    }),\n    DOUBLE: createToken({\n        name: 'DOUBLE',\n        pattern: DOUBLE,\n    }),\n    INTEGER_POSITIVE: createToken({\n        name: 'INTEGER_POSITIVE',\n        pattern: INTEGER_POSITIVE,\n    }),\n    DECIMAL_POSITIVE: createToken({\n        name: 'DECIMAL_POSITIVE',\n        pattern: DECIMAL_POSITIVE,\n    }),\n    DOUBLE_POSITIVE: createToken({\n        name: 'DOUBLE_POSITIVE',\n        pattern: DOUBLE_POSITIVE,\n    }),\n    INTEGER_NEGATIVE: createToken({\n        name: 'INTEGER_NEGATIVE',\n        pattern: INTEGER_NEGATIVE,\n    }),\n    DECIMAL_NEGATIVE: createToken({\n        name: 'DECIMAL_NEGATIVE',\n        pattern: DECIMAL_NEGATIVE,\n    }),\n    DOUBLE_NEGATIVE: createToken({\n        name: 'DOUBLE_NEGATIVE',\n        pattern: DOUBLE_NEGATIVE,\n    }),\n    STRING_LITERAL_LONG1: STRING_LITERAL_LONG1_TOKEN,\n    STRING_LITERAL_LONG2: STRING_LITERAL_LONG2_TOKEN,\n    STRING_LITERAL1: createToken({\n        name: 'STRING_LITERAL1',\n        pattern: STRING_LITERAL1,\n        longer_alt: STRING_LITERAL_LONG1_TOKEN,\n    }),\n    STRING_LITERAL2: createToken({\n        name: 'STRING_LITERAL2',\n        pattern: STRING_LITERAL2,\n        longer_alt: STRING_LITERAL_LONG2_TOKEN,\n    }),\n    NIL: createToken({\n        name: 'NIL',\n        pattern: NIL,\n        label: '()',\n    }),\n    ANON: createToken({\n        name: 'ANON',\n        pattern: ANON,\n        label: '[]',\n    }),\n    PNAME_LN: PNAME_LN_TOKEN,\n    PNAME_NS: createToken({\n        name: 'PNAME_NS',\n        pattern: PNAME_NS,\n        longer_alt: PNAME_LN_TOKEN,\n    }),\n    BLANK_NODE_LABEL: createToken({\n        name: 'BLANK_NODE_LABEL',\n        pattern: BLANK_NODE_LABEL,\n    }),\n    VAR1: createToken({\n        name: 'VAR1',\n        pattern: VAR1,\n        label: '?foo',\n    }),\n    VAR2: createToken({\n        name: 'VAR2',\n        pattern: VAR2,\n        label: '?bar',\n    }),\n    PERCENT: createToken({\n        name: 'PERCENT',\n        pattern: PERCENT,\n    }),\n};\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport escapeStringRegexp from 'escape-string-regexp';\nimport { isCstNode } from 'helpers/cst';\n// Given a SHACL prefix, returns a RegExp that can be used for grabbing the\n// local name (e.g., the 'NodeShape' in 'sh:NodeShape') from either a full\n// SHACL IRI or a prefixed local name.\nvar getShaclLocalNameMatcher = function (shaclPrefix) {\n    return new RegExp(\"(?:shacl#|\" + escapeStringRegexp(shaclPrefix) + \":)(\\\\S+?)>?$\");\n};\n// Traverses the tree of descendants for a given CstNode until a token is\n// found. Returns the \"start\" token for the CstNode (i.e., the earliest token\n// encompassed by the CstNode). This is useful for diagnostics.\nvar getUnderlyingStartToken = function (ctx) {\n    var currentNode = ctx;\n    while (currentNode.children) {\n        var currentNodeKey = Object.keys(currentNode.children)[0];\n        currentNode = currentNode.children[currentNodeKey][0];\n    }\n    return currentNode;\n};\n// Grabs the local name (e.g., the 'NodeShape' in 'sh:NodeShape') from either\n// a full SHACL IRI or a prefixed local name, if it is available.\nvar getLocalName = function (iri, matcher) {\n    var result = matcher.exec(iri);\n    if (result) {\n        return result[1];\n    }\n};\n// Given an initial (possibly partially complete) `shape` object and an array\n// of CstElements matching the `shaclRulePredicateObjectList` grammar rule,\n// transforms the `shape` into a complete `ShaclShape` with associated SHACL\n// types and predicates.\n// NOTE: mutates `shape`!\nvar addPredicatesAndTypesToShape = function (shape, shaclRulePredicateObjectListNodes) {\n    shaclRulePredicateObjectListNodes.forEach(function (node) {\n        var child = node.children[Object.keys(node.children)[0]][0];\n        switch (child.name) {\n            case 'shaclVerbShape': {\n                var token = getUnderlyingStartToken(child);\n                var verbTokenInsensitive = token.image.toLowerCase();\n                var isTypeVerb = verbTokenInsensitive === 'a' ||\n                    verbTokenInsensitive === 'rdf:type' ||\n                    verbTokenInsensitive ===\n                        '<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>';\n                if (!isTypeVerb) {\n                    return;\n                }\n                Object.keys(child.children).forEach(function (key) {\n                    if (key !== 'shaclShapeType') {\n                        return;\n                    }\n                    var shapeTypeNode = child.children[key][0];\n                    if (shapeTypeNode.children.SHACL_NodeShape) {\n                        shape.types.push({\n                            type: 'NodeShape',\n                            token: getUnderlyingStartToken(shapeTypeNode),\n                        });\n                    }\n                    else if (shapeTypeNode.children.SHACL_PropertyShape) {\n                        shape.types.push({\n                            type: 'PropertyShape',\n                            token: getUnderlyingStartToken(shapeTypeNode),\n                        });\n                    }\n                });\n                break;\n            }\n            case 'shaclPredicateIRI': {\n                if (child.children.SingleIriTakingPredicate) {\n                    shape.predicates.push({\n                        type: 'SingleIriTakingPredicate',\n                        token: getUnderlyingStartToken(child.children\n                            .SingleIriTakingPredicate[0]),\n                    });\n                }\n                else if (child.children.ManyIriTakingPredicate) {\n                    shape.predicates.push({\n                        type: 'ManyIriTakingPredicate',\n                        token: getUnderlyingStartToken(child.children\n                            .ManyIriTakingPredicate[0]),\n                    });\n                }\n                break;\n            }\n            case 'shaclNodeKind':\n                shape.predicates.push({\n                    type: 'nodeKind',\n                    token: child.children.SHACL_nodeKind[0],\n                });\n                break;\n            case 'shaclTargetNode':\n                shape.predicates.push({\n                    type: 'targetNode',\n                    token: child.children.SHACL_targetNode[0],\n                });\n                break;\n            case 'shaclPropertyPath':\n                shape.predicates.push({\n                    type: 'path',\n                    token: child.children.SHACL_path[0],\n                });\n                break;\n            case 'shaclLiteralConstraint':\n                shape.predicates.push({\n                    type: 'LiteralConstraint',\n                    token: getUnderlyingStartToken(child),\n                });\n                break;\n            case 'shaclListTakingConstraint':\n                shape.predicates.push({\n                    type: 'ListTakingConstraint',\n                    token: getUnderlyingStartToken(child),\n                });\n                break;\n            case 'shaclShapeExpectingConstraint':\n                shape.predicates.push({\n                    type: 'ShapeExpectingPredicate',\n                    token: child.children.ShapeExpectingPredicate[0],\n                });\n                break;\n            case 'shaclHasValueConstraint':\n                shape.predicates.push({\n                    type: 'hasValue',\n                    token: child.children.SHACL_hasValue[0],\n                });\n                break;\n            default:\n                console.log(\"SHACL predicateObjectList with name \" + child.name + \" not recognized.\");\n        }\n    });\n};\n// Utility method for constructing a `ShaclShape` from CstElements matching the\n// `shaclShape` grammar rule.\nvar getShaclShapeFromBlankNodePropertyList = function (ctx) {\n    var blankNodeNode = ctx.blankNodePropertyList[0];\n    var predicateObjectListNode = blankNodeNode.children.predicateObjectList[0];\n    var optionalPredicateObjectListNode = ctx.predicateObjectList\n        ? ctx.predicateObjectList[0]\n        : null;\n    if (!isCstNode(predicateObjectListNode) &&\n        !isCstNode(optionalPredicateObjectListNode)) {\n        return;\n    }\n    var shaclRulePredicateObjectListNodes = optionalPredicateObjectListNode &&\n        optionalPredicateObjectListNode.children &&\n        optionalPredicateObjectListNode.children.shaclRulePredicateObjectList\n        ? (predicateObjectListNode.children.shaclRulePredicateObjectList ||\n            []).concat(optionalPredicateObjectListNode.children\n            .shaclRulePredicateObjectList) : predicateObjectListNode.children.shaclRulePredicateObjectList;\n    if (!shaclRulePredicateObjectListNodes) {\n        return;\n    }\n    var shape = {\n        subject: {\n            type: 'blankNodePropertyList',\n            token: getUnderlyingStartToken(blankNodeNode),\n        },\n        types: [],\n        predicates: [],\n    };\n    addPredicatesAndTypesToShape(shape, shaclRulePredicateObjectListNodes);\n    return shape;\n};\n// Returns a new SHACL visitor that extends that given BaseVisitor. The SHACL\n// visitor is capable of constructing ShaclShape objects from a given CST and\n// then using those shapes to perform validations that cannot be performed in\n// the initial parse of a SHACL document.\nexport var getShaclVisitor = function (BaseVisitor) {\n    var ShaclVisitor = /** @class */ (function (_super) {\n        __extends(ShaclVisitor, _super);\n        function ShaclVisitor() {\n            var _this = _super.call(this) || this;\n            // `triples` have two alternatives, one with a `subject` and one with a\n            // `blankNodePropertyList`. This method constructs SHACL shapes for each\n            // alternative.\n            _this.triples = function (ctx) {\n                if (ctx.subject) {\n                    var predicateObjectListNode = ctx.predicateObjectList[0];\n                    if (!isCstNode(predicateObjectListNode)) {\n                        return;\n                    }\n                    var shaclRulePredicateObjectListNodes = predicateObjectListNode.children.shaclRulePredicateObjectList;\n                    if (!shaclRulePredicateObjectListNodes) {\n                        return;\n                    }\n                    var shape = {\n                        subject: {\n                            type: Object.keys(ctx.subject[0].children)[0] === 'collection'\n                                ? 'collection'\n                                : 'subject',\n                            token: getUnderlyingStartToken(ctx.subject[0]),\n                        },\n                        types: [],\n                        predicates: [],\n                    };\n                    addPredicatesAndTypesToShape(shape, shaclRulePredicateObjectListNodes);\n                    _this.shapes.push(shape);\n                    _this.visit(ctx.subject);\n                    _this.visit(predicateObjectListNode);\n                }\n                else {\n                    var shape = getShaclShapeFromBlankNodePropertyList(ctx);\n                    if (!shape) {\n                        return;\n                    }\n                    _this.shapes.push(shape);\n                    _this.visit(ctx.blankNodePropertyList);\n                    if (ctx.predicateObjectList) {\n                        _this.visit(ctx.predicateObjectList);\n                    }\n                }\n            };\n            // Some SHACL shapes (e.g., nested PropertyShapes) are not matched\n            // by the `triples` grammar rule; instead, they match `shapeShape`.\n            _this.shaclShape = function (ctx) {\n                if (!ctx.blankNodePropertyList) {\n                    // Not an inline shape we need to traverse, just an identifier.\n                    return;\n                }\n                var shape = getShaclShapeFromBlankNodePropertyList(ctx);\n                if (!shape) {\n                    return;\n                }\n                _this.shapes.push(shape);\n                _this.visit(ctx.blankNodePropertyList);\n            };\n            _this.$resetState = function () {\n                _this.shapes = [];\n            };\n            _this.$validateShapes = function (_a) {\n                var shaclPrefix = _a.shacl;\n                var validationErrors = [];\n                var localNameMatcher = getShaclLocalNameMatcher(shaclPrefix);\n                var bnodeCount = 0;\n                var shapesConsolidatedBySubject = _this.shapes.reduce(function (consolidatedShapes, shape) {\n                    var image = shape.subject.token.image;\n                    var subjectImage = image === '[' ? \"bnode\" + ++bnodeCount : image;\n                    if (!consolidatedShapes[subjectImage]) {\n                        consolidatedShapes[subjectImage] = {\n                            subjects: [shape.subject],\n                            types: shape.types,\n                            predicates: shape.predicates,\n                        };\n                    }\n                    else {\n                        var consolidatedShape = consolidatedShapes[subjectImage];\n                        consolidatedShapes[subjectImage] = {\n                            subjects: consolidatedShape.subjects.concat([shape.subject]),\n                            types: consolidatedShape.types.concat(shape.types),\n                            predicates: consolidatedShape.predicates.concat(shape.predicates),\n                        };\n                    }\n                    return consolidatedShapes;\n                }, {});\n                Object.keys(shapesConsolidatedBySubject).forEach(function (subjectImage) {\n                    var _a = shapesConsolidatedBySubject[subjectImage], subjects = _a.subjects, types = _a.types, predicates = _a.predicates;\n                    var shapeType;\n                    types.forEach(function (_a) {\n                        var type = _a.type;\n                        if (shapeType && type !== shapeType) {\n                            validationErrors.push({\n                                name: 'ShapeTypeError',\n                                message: 'A SHACL shape can be at most one of NodeShape or PropertyShape.',\n                                token: subjects[0].token,\n                            });\n                        }\n                        else if (!shapeType) {\n                            shapeType = type;\n                        }\n                    });\n                    var pathPredicates = [];\n                    var nonPathPredicateMap = {};\n                    predicates.forEach(function (predicate) {\n                        var image = predicate.token.image;\n                        var localName = getLocalName(image, localNameMatcher);\n                        var predicateImage = localName\n                            ? shaclPrefix + \":\" + localName\n                            : image;\n                        if (predicateImage === shaclPrefix + \":path\") {\n                            pathPredicates.push(predicate);\n                        }\n                        else {\n                            if (!nonPathPredicateMap[predicateImage]) {\n                                nonPathPredicateMap[predicateImage] = [];\n                            }\n                            nonPathPredicateMap[predicateImage].push(predicate);\n                        }\n                    });\n                    if (pathPredicates.length > 0) {\n                        if (shapeType === 'NodeShape') {\n                            validationErrors.push({\n                                name: 'ShapePropertyError',\n                                message: 'SHACL instances of `NodeShape` cannot have a value for the `path` property.',\n                                token: pathPredicates[0].token,\n                            });\n                        }\n                        else {\n                            shapeType = 'PropertyShape';\n                        }\n                        if (pathPredicates.length > 1) {\n                            validationErrors.push({\n                                name: 'ShapePropertyError',\n                                message: 'A shape can have at most one value for sh:path.',\n                                token: pathPredicates[1].token,\n                            });\n                        }\n                    }\n                    if (shapeType === 'NodeShape') {\n                        [\n                            'minCount',\n                            'maxCount',\n                            'uniqueLang',\n                            'lessThan',\n                            'lessThanOrEquals',\n                            'qualifiedValueShape',\n                        ].forEach(function (image) {\n                            var prefixedImage = shaclPrefix + \":\" + image;\n                            if (nonPathPredicateMap[prefixedImage]) {\n                                validationErrors.push({\n                                    name: 'ShapePropertyError',\n                                    message: \"A NodeShape cannot have any value for \" + prefixedImage + \".\",\n                                    token: nonPathPredicateMap[prefixedImage][0].token,\n                                });\n                            }\n                        });\n                    }\n                    else {\n                        [\n                            'deactivated',\n                            'severity',\n                            'datatype',\n                            'nodeKind',\n                            'minCount',\n                            'maxCount',\n                            'minExclusive',\n                            'minInclusive',\n                            'maxExclusive',\n                            'maxInclusive',\n                            'minLength',\n                            'maxLength',\n                            'languageIn',\n                            'uniqueLang',\n                            'in',\n                        ].forEach(function (image) {\n                            var prefixedImage = shaclPrefix + \":\" + image;\n                            if (nonPathPredicateMap[prefixedImage] &&\n                                nonPathPredicateMap[prefixedImage].length > 1) {\n                                validationErrors.push({\n                                    name: 'ShapePropertyError',\n                                    message: \"A shape can have at most one value for \" + prefixedImage + \".\",\n                                    token: nonPathPredicateMap[prefixedImage][1].token,\n                                });\n                            }\n                        });\n                    }\n                });\n                return { validationErrors: validationErrors };\n            };\n            _this.validateVisitor();\n            _this.shapes = [];\n            return _this;\n        }\n        return ShaclVisitor;\n    }(BaseVisitor));\n    return new ShaclVisitor();\n};\n","import { IToken, CstNode, TokenType, } from 'chevrotain';\nexport var getAsTypedTuple = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args;\n};\n// exported for convenience\nexport { IToken, CstNode, TokenType };\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { turtleTokenTypes, turtleTokenMap } from '../turtle/tokens';\nimport { sparqlTokenMap } from '../sparql/tokens';\nimport { createToken, Lexer } from 'chevrotain';\nimport memoize from 'memoize-one';\nimport { getAsTypedTuple } from 'helpers/types';\nimport isDeepEqual from 'lodash.isequal';\nvar shaclIriNamespace = 'http://www.w3.org/ns/shacl#';\nvar xsdIriNamespace = 'http://www.w3.org/2001/XMLSchema#';\n// Token categories, useful for making the parser rules simpler.\nexport var categoryTokenMap = {\n    ManyIriTakingPredicate: createToken({\n        name: 'ManyIriTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    SingleIriTakingPredicate: createToken({\n        name: 'SingleIriTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    NodeKindIRI: createToken({\n        name: 'NodeKindIRI',\n        pattern: Lexer.NA,\n    }),\n    IntTakingPredicate: createToken({\n        name: 'IntTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    StringLiteralQuoteTakingPredicate: createToken({\n        name: 'StringLiteralQuoteTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    LangStringTakingPredicate: createToken({\n        name: 'LangStringTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    BooleanTakingPredicate: createToken({\n        name: 'BooleanTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    ShapeExpectingPredicate: createToken({\n        name: 'ShapeExpectingPredicate',\n        pattern: Lexer.NA,\n    }),\n    AnyLiteralTakingPredicate: createToken({\n        name: 'AnyLiteralTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n};\nexport var categoryTokens = Object.keys(categoryTokenMap).map(function (key) { return categoryTokenMap[key]; });\nvar localNamesByCategory = {\n    ManyIriTakingPredicate: getAsTypedTuple('equals', 'disjoint', 'lessThan', 'lessThanOrEquals', 'targetClass', 'targetSubjectsOf', 'targetObjectsOf'),\n    SingleIriTakingPredicate: getAsTypedTuple('class', 'datatype', 'severity'),\n    NodeKindIRI: getAsTypedTuple('IRI', 'BlankNode', 'Literal', 'BlankNodeOrIRI', 'BlankNodeOrLiteral', 'IRIOrLiteral'),\n    IntTakingPredicate: getAsTypedTuple('minCount', 'maxCount', 'minLength', 'maxLength', 'qualifiedMinCount', 'qualifiedMaxCount'),\n    StringLiteralQuoteTakingPredicate: getAsTypedTuple('pattern', 'flags', 'prefix', 'namespace'),\n    LangStringTakingPredicate: getAsTypedTuple('message', 'labelTemplate'),\n    BooleanTakingPredicate: getAsTypedTuple('uniqueLang', 'qualifiedValueShapesDisjoint', 'closed', 'deactivated', 'optional'),\n    ShapeExpectingPredicate: getAsTypedTuple('not', 'node', 'property', 'qualifiedValueShape', 'sparql', 'declare', 'prefixes', 'parameter', 'nodeValidator', 'propertyValidator', 'validator'),\n    AnyLiteralTakingPredicate: getAsTypedTuple('minExclusive', 'minInclusive', 'maxExclusive', 'maxInclusive'),\n    other: getAsTypedTuple('Shape', 'NodeShape', 'PropertyShape', 'targetNode', 'message', 'path', 'alternativePath', 'inversePath', 'zeroOrMorePath', 'oneOrMorePath', 'zeroOrOnePath', 'nodeKind', 'languageIn', 'and', 'or', 'xone', 'ignoredProperties', 'hasValue', 'in', 'select', 'ask'),\n};\nvar xsdLocalNames = getAsTypedTuple('boolean', 'integer', 'string', 'date', 'dateTime', 'anyURI');\n// Map of local names back to their categories, for easier lookup:\nvar localNameToCategoryMap = Object.keys(localNamesByCategory).reduce(function (nameToCategoryMap, category) {\n    var categoryLocalNames = localNamesByCategory[category];\n    categoryLocalNames.forEach(function (localName) { return (nameToCategoryMap[localName] = category); });\n    return nameToCategoryMap;\n}, {});\nvar localNames = Object.keys(localNameToCategoryMap);\n// We can pre-compute all tokens for the `xsd` namespace except for those that\n// include prefixes (since we don't know a priori what the prefix will be).\n// For each XSD local name, we will create a \"category\" token that will\n// ultimately be used as the single token encompassing either the full\n// (un-prefixed) IRI or the prefixed name (i.e., `xsd:string). At this point,\n// we create only the category token and the full (un-prefixed) IRI token; the\n// prefixed token is created later (via `getShaclTokenTypes`) once we actually\n// know what the `xsd` prefix is.\nvar xsdUnprefixedTokenMap = xsdLocalNames.reduce(function (tokenMap, localName) {\n    var _a;\n    var tokenName = \"SHACL_xsd_\" + localName; // category token name\n    var iriTokenName = tokenName + \"_IRI\"; // IRI token name\n    // Category token that will ultimately select either an XSD IRI or an XSD PN_LOCAL:\n    var iriOrPrefixCategoryToken = createToken({\n        name: tokenName,\n        pattern: Lexer.NA,\n    });\n    return __assign({}, tokenMap, (_a = {}, _a[tokenName] = iriOrPrefixCategoryToken, _a[iriTokenName] = createToken({\n        name: iriTokenName,\n        pattern: \"<\" + xsdIriNamespace + localName,\n        categories: [iriOrPrefixCategoryToken, turtleTokenMap.IRIREF],\n    }), _a));\n}, {});\n// We can also pre-compute all SHACL tokens except for those that include\n// prefixes (again, since we don't know a priori what the SHACL prefix will be).\n// This helps keep our parser quick. We do it in the same way that we did for\n// XSD tokens, above -- we create a \"category\" token for each SHACL local name\n// that will be used to match either the full (un-prefixed) IRI or the prefixed\n// name (once we know what the SHACL prefix is).\nvar shaclUnprefixedTokenMap = localNames.reduce(function (tokenMap, localName) {\n    var _a;\n    var category = localNameToCategoryMap[localName];\n    var categoryToken = categoryTokenMap[category];\n    var tokenName = \"SHACL_\" + localName;\n    var iriTokenName = tokenName + \"_IRI\";\n    // Category token that will select either a SHACL IRI or a SHACL PN_LOCAL:\n    var iriOrPrefixCategoryToken = createToken({\n        name: tokenName,\n        pattern: Lexer.NA,\n        categories: categoryToken ? [categoryToken] : [],\n    });\n    return __assign({}, tokenMap, (_a = {}, _a[tokenName] = iriOrPrefixCategoryToken, _a[iriTokenName] = createToken({\n        name: iriTokenName,\n        pattern: \"<\" + shaclIriNamespace + localName + \">\",\n        categories: [iriOrPrefixCategoryToken, turtleTokenMap.IRIREF],\n    }), _a));\n}, xsdUnprefixedTokenMap);\nvar makePrefixer = function (prefix) { return function (localName) {\n    return prefix + \":\" + localName;\n}; };\n// Retrieves the complete map of all SHACL/XSD tokens, given the SHACL and XSD\n// prefixes. The map contains, for every local name, a token matching the full\n// IRI, a token matching the prefixed local name, and a \"category\" token that\n// matches both. The category token is useful for simplifying parser rules (not\n// having to match every SHACL token as both a full IRI and a prefixed local\n// name.)\n// This function is called by the SHACL parser. It is memoized because the\n// arguments are small and unlikely to change often, and the parser needs to be\n// fast, so we should avoid re-computing.\nexport var getShaclTokenMap = memoize(function (prefixes) {\n    var prefixWithShacl = makePrefixer(prefixes.shacl);\n    var prefixWithXsd = makePrefixer(prefixes.xsd);\n    // Add the prefixed local names to the SHACL token map now that we know the\n    // prefixes.\n    var shaclTokenMap = localNames.reduce(function (tokenMap, localName) {\n        var _a;\n        var tokenName = \"SHACL_\" + localName;\n        var prefixedTokenName = tokenName + \"_prefixed\";\n        return __assign({}, tokenMap, (_a = {}, _a[prefixedTokenName] = createToken({\n            name: prefixedTokenName,\n            pattern: prefixWithShacl(localName),\n            categories: [tokenMap[tokenName], turtleTokenMap.PNAME_LN],\n        }), _a));\n    }, shaclUnprefixedTokenMap);\n    // Add the prefixed local names to the XSD token map now that we know the\n    // prefixes.\n    return xsdLocalNames.reduce(function (tokenMap, localName) {\n        var _a;\n        var tokenName = \"SHACL_xsd_\" + localName;\n        var prefixedTokenName = tokenName + \"_prefixed\";\n        return __assign({}, tokenMap, (_a = {}, _a[prefixedTokenName] = createToken({\n            name: prefixedTokenName,\n            pattern: \"\" + prefixWithXsd(localName),\n            categories: [tokenMap[tokenName], turtleTokenMap.PNAME_LN],\n        }), _a));\n    }, shaclTokenMap);\n}, isDeepEqual);\n// Get the index of PNAME_NS and IRIREF so that we can re-use existing Turtle\n// tokens but ensure that our special SHACL/XSD tokens are inserted at the\n// right place (since order of tokens matters for chevrotain).\nvar pnameIndex = turtleTokenTypes.indexOf(sparqlTokenMap.PNAME_NS);\nvar iriIndex = turtleTokenTypes.indexOf(turtleTokenMap.IRIREF);\n// tokenMap keys will need to be sorted in reverse order so that tokens with\n// partial overlap are in the right order in the TokenType array.\nvar reverseSort = function (a, b) {\n    // @ts-ignore: unused variable\n    var _a = a.split('_'), aIgnored = _a[0], aName = _a[1], aRemainder = _a.slice(2);\n    // @ts-ignore: unused variable\n    var _b = b.split('_'), bIgnored = _b[0], bName = _b[1], bRemainder = _b.slice(2);\n    // Grab the local name and lowercase it:\n    var aSortString = (aName === 'xsd' ? aRemainder[0] : aName).toLowerCase();\n    var bSortString = (bName === 'xsd' ? bRemainder[0] : bName).toLowerCase();\n    if (aSortString === bSortString) {\n        // If local names are identical, prefer the one without a suffix to those with suffixes.\n        var aSuffix = aName === 'xsd' ? aRemainder[1] : aRemainder[0];\n        var bSuffix = bName === 'xsd' ? bRemainder[1] : bRemainder[0];\n        if (aSuffix && bSuffix) {\n            return 0; // when both local names have suffixes, treat as lexicographically the same for sorting\n        }\n        else {\n            return aSuffix ? 1 : -1;\n        }\n    }\n    else {\n        return aSortString < bSortString ? 1 : bSortString < aSortString ? -1 : 0;\n    }\n};\n// Given SHACL and XSD prefixes, this method returns an array of Turtle +\n// SHACL/XSD tokens, including tokens for prefixed local names, with the\n// SHACL/XSD tokens inserted at the proper positions so that they are matched\n// before the more generic Turtle tokens.\nexport var getShaclTokenTypes = memoize(function (prefixes) {\n    var tokenMap = getShaclTokenMap(prefixes);\n    var _a = Object.keys(tokenMap)\n        .sort(reverseSort)\n        .reduce(function (accumulator, key) {\n        if (key.endsWith('_IRI')) {\n            if (iriIndex < pnameIndex) {\n                accumulator.iriTokens.push(tokenMap[key.slice(0, -4)]);\n            }\n            accumulator.iriTokens.push(tokenMap[key]);\n        }\n        else if (key.endsWith('_prefixed')) {\n            if (pnameIndex < iriIndex) {\n                accumulator.pnameTokens.push(tokenMap[key.slice(0, -9)]);\n            }\n            accumulator.pnameTokens.push(tokenMap[key]);\n        }\n        return accumulator;\n    }, { pnameTokens: [], iriTokens: [] }), pnameTokens = _a.pnameTokens, iriTokens = _a.iriTokens;\n    if (pnameIndex < iriIndex) {\n        return turtleTokenTypes.slice(0, pnameIndex).concat(categoryTokens, pnameTokens, turtleTokenTypes.slice(pnameIndex, iriIndex), iriTokens, turtleTokenTypes.slice(iriIndex));\n    }\n    else {\n        return turtleTokenTypes.slice(0, iriIndex).concat(categoryTokens, iriTokens, turtleTokenTypes.slice(iriIndex, pnameIndex), pnameTokens, turtleTokenTypes.slice(pnameIndex));\n    }\n}, isDeepEqual);\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { TurtleParser } from '../turtle/TurtleParser';\nimport { Lexer, Parser, } from 'chevrotain';\nimport { getShaclVisitor } from 'shacl/visitor';\nimport { getShaclTokenTypes, getShaclTokenMap, categoryTokenMap, } from './tokens';\nimport { turtleTokenMap } from '../turtle/tokens';\n// A SHACL parser for the Turtle serialization of SHACL only. The parser can\n// can accept any arbitrary namespace prefix for SHACL/XSD and still tokenize\n// and parse the document correctly (it will also, of course, parse docuemnts\n// using the full SHACL/XSD IRIs). The parser runs both a parse phase and a\n// second validation phase (using a visitor) in order to accommodate SHACL\n// rules that are not purely syntactic.\nvar ShaclParser = /** @class */ (function (_super) {\n    __extends(ShaclParser, _super);\n    function ShaclParser(config, prefixes) {\n        if (prefixes === void 0) { prefixes = { shacl: 'sh', xsd: 'xsd' }; }\n        var _this = _super.call(this, __assign({ outputCst: true, recoveryEnabled: true }, config), getShaclTokenTypes(prefixes), getShaclTokenTypes(prefixes), false) || this;\n        // Some SHACL rules cannot be checked for violations during the first parse.\n        // The visitor accepts the CST that results from parsing and checks\n        // conformity with these SHACL rules.\n        _this.validateWithVisitor = function (cst) {\n            // To save resources while parsing, the shaclVisitor is a singleton.\n            if (!_this.shaclVisitor) {\n                var BaseSrsVisitor = _this.getBaseCstVisitorConstructorWithDefaults();\n                _this.shaclVisitor = getShaclVisitor(BaseSrsVisitor);\n            }\n            else {\n                _this.shaclVisitor.$resetState();\n            }\n            _this.shaclVisitor.visit(cst);\n            return _this.shaclVisitor.$validateShapes(_this.prefixes);\n        };\n        _this.tokenize = function (document) {\n            return _this.lexer.tokenize(document).tokens;\n        };\n        _this.parse = function (document) {\n            _this.input = _this.tokenize(document);\n            var cst = _this.turtleDoc();\n            var validationErrors = _this.validateWithVisitor(cst).validationErrors;\n            // Next two items are copied so that they can be returned/held after parse\n            // state is cleared.\n            var errors = _this.errors.slice();\n            var semanticErrors = _this.semanticErrors.concat(validationErrors);\n            return {\n                errors: errors,\n                semanticErrors: semanticErrors,\n                cst: cst,\n            };\n        };\n        _this.predicateObjectList = _this.OVERRIDE_RULE('predicateObjectList', function () {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.shaclRulePredicateObjectList);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.verb);\n                        _this.SUBRULE(_this.objectList);\n                    },\n                },\n            ]);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.OR1([\n                        {\n                            ALT: function () {\n                                _this.SUBRULE1(_this.shaclRulePredicateObjectList);\n                            },\n                        },\n                        {\n                            ALT: function () {\n                                _this.SUBRULE1(_this.verb);\n                                _this.SUBRULE1(_this.objectList);\n                            },\n                        },\n                    ]);\n                });\n            });\n        });\n        _this.shaclRulePredicateObjectList = _this.RULE('shaclRulePredicateObjectList', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclPredicateIRI); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclNodeKind); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclTargetNode); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclPropertyPath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclLiteralConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclListTakingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShapeExpectingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclHasValueConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclVerbShape); },\n                },\n            ]);\n        });\n        _this.shaclPredicateIRI = _this.RULE('shaclPredicateIRI', function () {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.CONSUME(categoryTokenMap.SingleIriTakingPredicate);\n                        _this.SUBRULE(_this.iri);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.CONSUME(categoryTokenMap.ManyIriTakingPredicate);\n                        _this.SUBRULE1(_this.iri);\n                        _this.MANY(function () {\n                            _this.CONSUME(turtleTokenMap.Comma);\n                            _this.SUBRULE2(_this.iri);\n                        });\n                    },\n                },\n            ]);\n        });\n        _this.shaclNodeKind = _this.RULE('shaclNodeKind', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_nodeKind);\n            _this.CONSUME(categoryTokenMap.NodeKindIRI);\n        });\n        _this.shaclTargetNode = _this.RULE('shaclTargetNode', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_targetNode);\n            _this.SUBRULE(_this.shaclIRIOrLiteral);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Comma);\n                _this.SUBRULE1(_this.shaclIRIOrLiteral);\n            });\n        });\n        _this.shaclVerbShape = _this.RULE('shaclVerbShape', function () {\n            _this.SUBRULE(_this.verb);\n            _this.SUBRULE(_this.shaclShapeType);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Comma);\n                _this.SUBRULE1(_this.shaclShapeType);\n            });\n        });\n        _this.shaclShapeType = _this.RULE('shaclShapeType', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_Shape); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_NodeShape); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_PropertyShape); },\n                },\n            ]);\n        });\n        _this.shaclPropertyPath = _this.RULE('shaclPropertyPath', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_path);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n        });\n        _this.shaclPropertyPathPath = _this.RULE('shaclPropertyPathPath', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclPredicatePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclSequencePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclAlternativePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclInversePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclZeroOrMorePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclOneOrMorePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclZeroOrOnePath); },\n                },\n            ]);\n        });\n        _this.shaclPredicatePath = _this.RULE('shaclPredicatePath', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.iri); },\n                },\n                {\n                    // This case does not seem to be allowed by the SHACL spec, but the\n                    // online W3C validator accepts one level of parens wrapping the IRI.\n                    ALT: function () {\n                        _this.CONSUME(turtleTokenMap.LParen);\n                        _this.SUBRULE1(_this.iri);\n                        _this.CONSUME(turtleTokenMap.RParen);\n                    },\n                },\n            ]);\n        });\n        _this.shaclSequencePath = _this.RULE('shaclSequencePath', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.AT_LEAST_ONE(function () { return _this.SUBRULE1(_this.shaclPropertyPathPath); });\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclAlternativePath = _this.RULE('shaclAlternativePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_alternativePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath); // This does not match the SHACL spec, but it does match the test cases, which violate the spec. ;_;\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclInversePath = _this.RULE('shaclInversePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_inversePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclZeroOrMorePath = _this.RULE('shaclZeroOrMorePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_zeroOrMorePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclOneOrMorePath = _this.RULE('shaclOneOrMorePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_oneOrMorePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclZeroOrOnePath = _this.RULE('shaclZeroOrOnePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_zeroOrOnePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclLiteralConstraint = _this.RULE('shaclLiteralConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclIntConstraint); },\n                },\n                // TODO: Some specificity here is possibly unnecessary -- e.g., maybe `shaclStringConstraint` and `shaclStringLiteralQuoteConstraint` can be consolidated in some way?\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclStringConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclStringLiteralQuoteConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclLangStringConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclBooleanConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclAnyLiteralConstraint); },\n                },\n            ]);\n        });\n        _this.shaclIntConstraint = _this.RULE('shaclIntConstraint', function () {\n            _this.CONSUME(categoryTokenMap.IntTakingPredicate);\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(turtleTokenMap.INTEGER); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclXsdInteger); },\n                },\n            ]);\n        });\n        _this.shaclStringConstraint = _this.RULE('shaclStringConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_select); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_ask); },\n                },\n            ]);\n            _this.SUBRULE(_this.String); // TODO: a bit too lax?\n        });\n        _this.shaclStringLiteralQuoteConstraint = _this.RULE('shaclStringLiteralQuoteConstraint', function () {\n            _this.CONSUME(categoryTokenMap.StringLiteralQuoteTakingPredicate);\n            _this.CONSUME(turtleTokenMap.STRING_LITERAL_QUOTE);\n            _this.OPTION(function () {\n                _this.OR([\n                    {\n                        ALT: function () { return _this.CONSUME(turtleTokenMap.LANGTAG); },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(turtleTokenMap.DoubleCaret);\n                            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_string);\n                        },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME1(turtleTokenMap.DoubleCaret);\n                            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_anyURI);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.shaclLangStringConstraint = _this.RULE('shaclLangStringConstraint', function () {\n            _this.CONSUME(categoryTokenMap.LangStringTakingPredicate);\n            _this.SUBRULE(_this.String);\n            _this.OPTION(function () {\n                _this.OR([\n                    {\n                        ALT: function () { return _this.CONSUME(turtleTokenMap.LANGTAG); },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(turtleTokenMap.DoubleCaret);\n                            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_string);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.shaclBooleanConstraint = _this.RULE('shaclBooleanConstraint', function () {\n            _this.CONSUME(categoryTokenMap.BooleanTakingPredicate);\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(turtleTokenMap.TRUE); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(turtleTokenMap.FALSE); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclXsdBoolean); },\n                },\n            ]);\n        });\n        _this.shaclAnyLiteralConstraint = _this.RULE('shaclAnyLiteralConstraint', function () {\n            _this.CONSUME(categoryTokenMap.AnyLiteralTakingPredicate);\n            _this.SUBRULE(_this.literal);\n        });\n        _this.shaclListTakingConstraint = _this.RULE('shaclListTakingConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclLanguageInConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShapeListTakingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclIRIListTakingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShapeOrLiteralListTakingConstraint); },\n                },\n            ]);\n        });\n        _this.shaclLanguageInConstraint = _this.RULE('shaclLanguageInConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_languageIn);\n            _this.SUBRULE(_this.shaclStringCollection);\n        });\n        _this.shaclStringCollection = _this.RULE('shaclStringCollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.STRING_LITERAL_QUOTE);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclShapeListTakingConstraint = _this.RULE('shaclShapeListTakingConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_and); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_or); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_xone); },\n                },\n            ]);\n            _this.SUBRULE(_this.shaclShapeCollection);\n        });\n        _this.shaclShapeCollection = _this.RULE('shaclShapeCollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.SUBRULE(_this.shaclShape);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclIRIListTakingConstraint = _this.RULE('shaclIRIListTakingConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_ignoredProperties);\n            _this.SUBRULE(_this.shaclIRICollection);\n        });\n        _this.shaclIRICollection = _this.RULE('shaclIRICollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.SUBRULE(_this.iri);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclShapeOrLiteralListTakingConstraint = _this.RULE('shaclShapeOrLiteralListTakingConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_in);\n            _this.SUBRULE(_this.shaclShapeOrLiteralCollection);\n        });\n        _this.shaclShapeOrLiteralCollection = _this.RULE('shaclShapeOrLiteralCollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.SUBRULE(_this.shaclShapeOrLiteral);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclShapeExpectingConstraint = _this.RULE('shaclShapeExpectingConstraint', function () {\n            _this.CONSUME(categoryTokenMap.ShapeExpectingPredicate);\n            _this.SUBRULE(_this.shaclShape);\n        });\n        _this.shaclHasValueConstraint = _this.RULE('shaclHasValueConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_hasValue);\n            _this.SUBRULE(_this.shaclShapeOrLiteral);\n        });\n        _this.shaclShape = _this.RULE('shaclShape', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.iri); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.blankNodePropertyList); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.BlankNode); },\n                },\n            ]);\n        });\n        _this.shaclShapeOrLiteral = _this.RULE('shaclShapeOrLiteral', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShape); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.literal); },\n                },\n            ]);\n        });\n        _this.shaclIRIOrLiteral = _this.RULE('shaclIRIOrLiteral', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.iri); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.literal); },\n                },\n            ]);\n        });\n        _this.shaclXsdBoolean = _this.RULE('shaclXsdBoolean', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_boolean);\n        });\n        _this.shaclXsdString = _this.RULE('shaclXsdString', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_string);\n        });\n        _this.shaclXsdInteger = _this.RULE('shaclXsdInteger', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_integer);\n        });\n        _this.shaclXsdDate = _this.RULE('shaclXsdDate', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_date);\n        });\n        _this.shaclXsdAnyURI = _this.RULE('shaclXsdAnyURI', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_anyURI);\n        });\n        _this.shaclStringWithDoubleCaret = _this.RULE('shaclStringWithDoubleCaret', function () {\n            _this.SUBRULE(_this.String);\n            _this.CONSUME(turtleTokenMap.DoubleCaret);\n        });\n        _this.prefixes = prefixes;\n        _this.lexer = new Lexer(getShaclTokenTypes(prefixes));\n        _this.shaclTokenMap = getShaclTokenMap(prefixes);\n        Parser.performSelfAnalysis(_this);\n        return _this;\n    }\n    return ShaclParser;\n}(TurtleParser));\nexport { ShaclParser };\n","export * from './ShaclParser';\nexport * from './tokens';\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexport var traverse = function (root, visit) {\n    _traverse(root, null, visit);\n};\nexport var unsafeTraverse = function (root, visit) {\n    _traverse(root, null, visit, false);\n};\nexport function isCstNode(object) {\n    return Boolean(object && 'name' in object);\n}\nvar TraverseContext = /** @class */ (function () {\n    function TraverseContext(_a) {\n        var node = _a.node, parentCtx = _a.parentCtx;\n        this.node = __assign({}, node);\n        this.parentCtx = __assign({}, parentCtx);\n    }\n    return TraverseContext;\n}());\nvar _traverse = function (root, ctx, visit, visitSafely) {\n    if (ctx === void 0) { ctx = new TraverseContext({ node: root }); }\n    if (visitSafely === void 0) { visitSafely = true; }\n    if (!isCstNode(root)) {\n        // must be a token\n        return visit(visitSafely ? __assign({}, ctx) : ctx);\n    }\n    // is a grammar rule node\n    var children = root.children;\n    Object.keys(children).forEach(function (key) {\n        var childType = children[key];\n        if (!childType.length) {\n            return;\n        }\n        childType.forEach(function (child) {\n            var childCtx = visitSafely\n                ? new TraverseContext({ node: child, parentCtx: ctx })\n                : { node: child, parentCtx: ctx };\n            var afterVisit = function (transformedCtx) {\n                var nextCtx = childCtx;\n                if (transformedCtx) {\n                    nextCtx = visitSafely\n                        ? new TraverseContext({\n                            node: transformedCtx.node,\n                            parentCtx: transformedCtx.parentCtx,\n                        })\n                        : {\n                            node: transformedCtx.node,\n                            parentCtx: transformedCtx.parentCtx,\n                        };\n                }\n                _traverse(child, nextCtx, visit, visitSafely);\n            };\n            visit(childCtx, afterVisit);\n        });\n    });\n};\n"],"sourceRoot":""}