{"version":3,"sources":["webpack://millan.[name]/webpack/universalModuleDefinition","webpack://millan.[name]/webpack/bootstrap","webpack://millan.[name]/./src/helpers/chevrotainHelper.ts","webpack://millan.[name]/./src/sparql/keywords.ts","webpack://millan.[name]/./src/turtle/TurtleParser.ts","webpack://millan.[name]/./src/helpers/regex.ts","webpack://millan.[name]/./src/helpers/matchers.ts","webpack://millan.[name]/./src/sparql/terminals.ts","webpack://millan.[name]/./src/helpers/types.ts","webpack://millan.[name]/./src/shacl/tokens.ts","webpack://millan.[name]/./src/sparql/tokens.ts","webpack://millan.[name]/./src/shacl/visitor.ts","webpack://millan.[name]/./src/shacl/ShaclParser.ts","webpack://millan.[name]/./src/shacl/index.ts","webpack://millan.[name]/./src/helpers/cst.ts","webpack://millan.[name]/./src/helpers/unescape.ts","webpack://millan.[name]/./src/turtle/tokens.ts"],"names":["root","factory","exports","module","define","amd","self","this","webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","3","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","oldJsonpFunction","slice","__assign","assign","arguments","__rest","e","indexOf","getOwnPropertySymbols","__webpack_exports__","keywords_createKeyword","keywords","keywords_assign","keywords_rest","_a","_b","longer_alt","UNKNOWN","props","pattern","api","RegExp","createKeyword","MAX_LENGTH","SELECT","CONSTRUCT","DISTINCT","START","END","VIA","PATHS","PATHS_ALL","PATHS_SHORTEST","CYCLIC","AS","WHERE","A","GROUP_BY","ORDER_BY","BY","BASE","PREFIX","DESCRIBE","ASK","FROM","REDUCED","NAMED","HAVING","ASC","DESC","OFFSET","LIMIT","VALUES","LOAD","SILENT","INTO","CLEAR","DROP","CREATE","ADD","TO","MOVE","COPY","INSERT_DATA","DELETE_DATA","DELETE_WHERE","WITH","DELETE","INSERT","USING","DEFAULT","GRAPH","ALL","OPTIONAL","SERVICE","BIND","UNNEST","UNDEF","MINUS","UNION","FILTER","STR","LANG","LANGMATCHES","DATATYPE","BOUND","IRI","URI","BNODE","RAND","ABS","CEIL","FLOOR","ROUND","CONCAT","STRLEN","UCASE","LCASE","ENCODE_FOR_URI","CONTAINS","STRSTARTS","STRENDS","STRBEFORE","STRAFTER","YEAR","MONTH","DAY","HOURS","MINUTES","SECONDS","TIMEZONE","TZ","NOW","UUID","STRUUID","MD5","SHA1","SHA256","SHA384","SHA512","COALESCE","IF","STRLANG","STRDT","sameTerm","isIRI","isURI","isBLANK","isLITERAL","isNUMERIC","REGEX","SUBSTR","REPLACE","EXISTS","NOT_EXISTS","COUNT","SUM","MIN","AVG","SAMPLE","GROUP_CONCAT","SEPARATOR","TRUE","FALSE","IN","NOT_IN","MAX","TurtleParser","extendStatics","chevrotain__WEBPACK_IMPORTED_MODULE_0__","__extends","b","setPrototypeOf","__proto__","Array","__","constructor","turtleTokenTypes","turtleTokenMap","_super","config","tokens","lexerDefinition","performSelfAnalysis","_this","outputCst","recoveryEnabled","namespacesMap","semanticErrors","resetManagedState","tokenize","document","lexer","parse","input","cst","turtleDoc","errors","RULE","allowEdgeProperties","MANY","SUBRULE","statement","ARGS","OR","ALT","directive","triples","CONSUME","Period","prefixID","base","sparqlPrefix","sparqlBase","TTL_PREFIX","pnameNsToken","PNAME_NS","iriToken","IRIREF","pnameImageWithoutColon","image","iriImage","TTL_BASE","subject","SUBRULE1","predicateObjectList","GATE","Boolean","EmbeddedTriplePattern","blankNodePropertyList","OPTION","SUBRULE2","LEmbed","REmbed","verb","objectList","EmbeddedPredicateObjectList","Semicolon","OR1","LCurly","RCurly","iri","BlankNode","collection","predicate","Comma","literal","RDFLiteral","NumericLiteral","BooleanLiteral","LBracket","RBracket","LParen","RParen","INTEGER","DECIMAL","DOUBLE","String","LANGTAG","DoubleCaret","STRING_LITERAL_QUOTE","STRING_LITERAL_SINGLE_QUOTE","STRING_LITERAL_LONG_SINGLE_QUOTE","STRING_LITERAL_LONG_QUOTE","PrefixedName","prefixedNameToken","PNAME_LN","message","token","context","ruleStack","getHumanReadableRuleStack","ruleOccurrenceStack","RULE_OCCURRENCE_STACK","resyncedTokens","BLANK_NODE_LABEL","ANON","regex","or","_i","map","source","join","and","option","many","CATCH_ALL_AT_LEAST_ONE","PN_CHARS_BASE","EXPONENT","ECHAR","HEX","PN_LOCAL_ESC","PN_CHARS_U","PN_CHARS","PN_PREFIX","PERCENT","PLX","PN_LOCAL","NIL","STRING_LITERAL1","STRING_LITERAL2","STRING_LITERAL_LONG1","STRING_LITERAL_LONG2","INTEGER_POSITIVE","DECIMAL_POSITIVE","DOUBLE_POSITIVE","INTEGER_NEGATIVE","DECIMAL_NEGATIVE","DOUBLE_NEGATIVE","VAR1","VAR2","_regex__WEBPACK_IMPORTED_MODULE_0__","WS","VARNAME","terminals","helpers_matchers__WEBPACK_IMPORTED_MODULE_1__","STRING_LITERAL_LONG1_TOKEN","STRING_LITERAL_LONG2_TOKEN","PNAME_LN_TOKEN","label","getAsTypedTuple","args","categoryTokenMap","categoryTokens","getShaclTokenMap","getShaclTokenTypes","tokens_a","sparqlTokenMap","ManyIriTakingPredicate","NA","SingleIriTakingPredicate","NodeKindIRI","IntTakingPredicate","StringLiteralQuoteTakingPredicate","LangStringTakingPredicate","BooleanTakingPredicate","ShapeExpectingPredicate","AnyLiteralTakingPredicate","keys","localNamesByCategory","other","xsdLocalNames","localNameToCategoryMap","reduce","nameToCategoryMap","category","forEach","localName","localNames","xsdUnprefixedTokenMap","tokenMap","tokenName","iriTokenName","iriOrPrefixCategoryToken","categories","shaclUnprefixedTokenMap","categoryToken","makePrefixer","prefix","memoize_one_esm","prefixes","prefixWithShacl","shacl","prefixWithXsd","xsd","shaclTokenMap","prefixedTokenName","lodash_isequal_default","a","pnameIndex","iriIndex","reverseSort","split","aName","aRemainder","bName","bRemainder","aSortString","toLowerCase","bSortString","aSuffix","bSuffix","sort","accumulator","endsWith","iriTokens","pnameTokens","concat","baseTokens","pathsTokens","nonStandardTokens","stardogSparqlTokens","sparqlTokenTypes","_terminals__WEBPACK_IMPORTED_MODULE_1__","_keywords__WEBPACK_IMPORTED_MODULE_2__","Comment","group","WhiteSpace","SKIPPED","line_breaks","Star","QuestionMark","Plus","Minus","Pipe","ForwardSlash","Caret","Bang","LogicalOr","LogicalAnd","Equals","NotEquals","LessThan","GreaterThan","LessThanEquals","GreaterThanEquals","indexOfSelect","getShaclLocalNameMatcher","shaclPrefix","escape_string_regexp_default","getUnderlyingStartToken","ctx","currentNode","children","currentNodeKey","getLocalName","matcher","exec","addPredicatesAndTypesToShape","shape","shaclRulePredicateObjectListNodes","node","child","verbTokenInsensitive","shapeTypeNode","SHACL_NodeShape","types","type","SHACL_PropertyShape","predicates","SHACL_nodeKind","SHACL_targetNode","SHACL_path","SHACL_hasValue","console","log","getShaclShapeFromBlankNodePropertyList","blankNodeNode","predicateObjectListNode","optionalPredicateObjectListNode","helpers_cst","shaclRulePredicateObjectList","getShaclVisitor","BaseVisitor","ShaclVisitor","shapes","visit","shaclShape","$resetState","$validateShapes","validationErrors","localNameMatcher","bnodeCount","shapesConsolidatedBySubject","consolidatedShapes","subjectImage","consolidatedShape","subjects","shapeType","pathPredicates","nonPathPredicateMap","predicateImage","prefixedImage","validateVisitor","ShaclParser_extends","ShaclParser_ShaclParser","ShaclParser","validateWithVisitor","shaclVisitor","BaseSrsVisitor","getBaseCstVisitorConstructorWithDefaults","OVERRIDE_RULE","shaclPredicateIRI","shaclNodeKind","shaclTargetNode","shaclPropertyPath","shaclLiteralConstraint","shaclListTakingConstraint","shaclShapeExpectingConstraint","shaclHasValueConstraint","shaclVerbShape","shaclIRIOrLiteral","shaclShapeType","SHACL_Shape","shaclPropertyPathPath","shaclPredicatePath","shaclSequencePath","shaclAlternativePath","shaclInversePath","shaclZeroOrMorePath","shaclOneOrMorePath","shaclZeroOrOnePath","AT_LEAST_ONE","SHACL_alternativePath","SHACL_inversePath","SHACL_zeroOrMorePath","SHACL_oneOrMorePath","SHACL_zeroOrOnePath","shaclIntConstraint","shaclStringConstraint","shaclStringLiteralQuoteConstraint","shaclLangStringConstraint","shaclBooleanConstraint","shaclAnyLiteralConstraint","shaclXsdInteger","SHACL_select","SHACL_ask","SHACL_xsd_string","CONSUME1","SHACL_xsd_anyURI","shaclXsdBoolean","shaclLanguageInConstraint","shaclShapeListTakingConstraint","shaclIRIListTakingConstraint","shaclShapeOrLiteralListTakingConstraint","SHACL_languageIn","shaclStringCollection","SHACL_and","SHACL_or","SHACL_xone","shaclShapeCollection","SHACL_ignoredProperties","shaclIRICollection","SHACL_in","shaclShapeOrLiteralCollection","shaclShapeOrLiteral","shaclStringWithDoubleCaret","SHACL_xsd_boolean","shaclXsdString","SHACL_xsd_integer","shaclXsdDate","SHACL_xsd_date","shaclXsdAnyURI","shaclTokens","traverse","unsafeTraverse","isCstNode","_traverse","TraverseContext","parentCtx","visitSafely","childType","childCtx","transformedCtx","nextCtx","escapeSequence","escapeReplacements","\\","'","\"","f","_","~",".","-","!","$","&","(",")","*","+",",",";","=","/","?","#","@","%","unescapedStringLiteralQuote","unescapedStringLiteralSingleQuote","stringLiteralQuote","stringLiteralSingleQuote","stringLiteralLongQuote","stringLiteralLongSingleQuote","illegalIriChars","escapedIri","unescapedIri","unescape_unescape","item","replace","unicode4","unicode8","escapedChar","fromCharCode","parseInt","charCode","replacement","Error","error","unicodeRegexp","matchers","text","startOffset","match","textToMatch","UCHAR","test"],"mappings":"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","file":"millan.shacl.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"shacl\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"shacl\"] = factory();\n\telse\n\t\troot[\"millan\"] = root[\"millan\"] || {}, root[\"millan\"][\"shacl\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t3: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = (typeof self !== 'undefined' ? self : this)[\"webpackJsonp\"] = (typeof self !== 'undefined' ? self : this)[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([66,0,9]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nimport { createToken } from 'chevrotain';\nexport var createKeyword = function (_a) {\n    var name = _a.name, pattern = _a.pattern, props = __rest(_a, [\"name\", \"pattern\"]);\n    return createToken(__assign({ name: name, pattern: pattern || new RegExp(name, 'i') }, props));\n};\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nimport { createToken } from 'chevrotain';\nimport { createKeyword as createKeywordToken } from 'helpers/chevrotainHelper';\nexport var createKeyword = function (_a) {\n    var _b = _a.longer_alt, longer_alt = _b === void 0 ? UNKNOWN : _b, props = __rest(_a, [\"longer_alt\"]);\n    return createKeywordToken(__assign({ longer_alt: longer_alt }, props));\n};\nvar UNKNOWN = createToken({ name: 'UNKNOWN', pattern: /\\w+/i });\nvar MAX_LENGTH = createKeyword({\n    name: 'MAX_LENGTH',\n    pattern: /MAX LENGTH/i,\n});\nexport var keywords = {\n    SELECT: createKeyword({ name: 'SELECT' }),\n    CONSTRUCT: createKeyword({ name: 'CONSTRUCT' }),\n    DISTINCT: createKeyword({ name: 'DISTINCT' }),\n    START: createKeyword({ name: 'START' }),\n    END: createKeyword({ name: 'END' }),\n    VIA: createKeyword({ name: 'VIA' }),\n    PATHS: createKeyword({ name: 'PATHS' }),\n    PATHS_ALL: createKeyword({ name: 'PATHS_ALL', pattern: /PATHS ALL/i }),\n    PATHS_SHORTEST: createKeyword({\n        name: 'PATHS_SHORTEST',\n        pattern: /PATHS SHORTEST/i,\n    }),\n    CYCLIC: createKeyword({ name: 'CYCLIC' }),\n    AS: createKeyword({ name: 'AS' }),\n    WHERE: createKeyword({ name: 'WHERE' }),\n    A: createKeyword({ name: 'A', pattern: /a/ }),\n    GROUP_BY: createKeyword({ name: 'GROUP_BY', pattern: /GROUP BY/i }),\n    ORDER_BY: createKeyword({ name: 'ORDER_BY', pattern: /ORDER BY/i }),\n    BY: createKeyword({ name: 'BY' }),\n    BASE: createKeyword({ name: 'BASE' }),\n    PREFIX: createKeyword({ name: 'PREFIX' }),\n    DESCRIBE: createKeyword({ name: 'DESCRIBE' }),\n    ASK: createKeyword({ name: 'ASK' }),\n    FROM: createKeyword({ name: 'FROM' }),\n    REDUCED: createKeyword({ name: 'REDUCED' }),\n    NAMED: createKeyword({ name: 'NAMED' }),\n    HAVING: createKeyword({ name: 'HAVING' }),\n    ASC: createKeyword({ name: 'ASC' }),\n    DESC: createKeyword({ name: 'DESC' }),\n    OFFSET: createKeyword({ name: 'OFFSET' }),\n    LIMIT: createKeyword({ name: 'LIMIT' }),\n    VALUES: createKeyword({ name: 'VALUES' }),\n    LOAD: createKeyword({ name: 'LOAD' }),\n    SILENT: createKeyword({ name: 'SILENT' }),\n    INTO: createKeyword({ name: 'INTO' }),\n    CLEAR: createKeyword({ name: 'CLEAR' }),\n    DROP: createKeyword({ name: 'DROP' }),\n    CREATE: createKeyword({ name: 'CREATE' }),\n    ADD: createKeyword({ name: 'ADD' }),\n    TO: createKeyword({ name: 'TO' }),\n    MOVE: createKeyword({ name: 'MOVE' }),\n    COPY: createKeyword({ name: 'COPY' }),\n    INSERT_DATA: createKeyword({ name: 'INSERT_DATA', pattern: /INSERT +DATA/i }),\n    DELETE_DATA: createKeyword({ name: 'DELETE_DATA', pattern: /DELETE +DATA/i }),\n    DELETE_WHERE: createKeyword({\n        name: 'DELETE_WHERE',\n        pattern: /DELETE +WHERE/i,\n    }),\n    WITH: createKeyword({ name: 'WITH' }),\n    DELETE: createKeyword({ name: 'DELETE' }),\n    INSERT: createKeyword({ name: 'INSERT' }),\n    USING: createKeyword({ name: 'USING' }),\n    DEFAULT: createKeyword({ name: 'DEFAULT' }),\n    GRAPH: createKeyword({ name: 'GRAPH' }),\n    ALL: createKeyword({ name: 'ALL' }),\n    OPTIONAL: createKeyword({ name: 'OPTIONAL' }),\n    SERVICE: createKeyword({ name: 'SERVICE' }),\n    BIND: createKeyword({ name: 'BIND' }),\n    UNNEST: createKeyword({ name: 'UNNEST' }),\n    UNDEF: createKeyword({ name: 'UNDEF' }),\n    MINUS: createKeyword({ name: 'MINUS' }),\n    UNION: createKeyword({ name: 'UNION' }),\n    FILTER: createKeyword({ name: 'FILTER' }),\n    STR: createKeyword({ name: 'STR' }),\n    LANG: createKeyword({ name: 'LANG' }),\n    LANGMATCHES: createKeyword({ name: 'LANGMATCHES' }),\n    DATATYPE: createKeyword({ name: 'DATATYPE' }),\n    BOUND: createKeyword({ name: 'BOUND' }),\n    IRI: createKeyword({ name: 'IRI' }),\n    URI: createKeyword({ name: 'URI' }),\n    BNODE: createKeyword({ name: 'BNODE' }),\n    RAND: createKeyword({ name: 'RAND' }),\n    ABS: createKeyword({ name: 'ABS' }),\n    CEIL: createKeyword({ name: 'CEIL' }),\n    FLOOR: createKeyword({ name: 'FLOOR' }),\n    ROUND: createKeyword({ name: 'ROUND' }),\n    CONCAT: createKeyword({ name: 'CONCAT' }),\n    STRLEN: createKeyword({ name: 'STRLEN' }),\n    UCASE: createKeyword({ name: 'UCASE' }),\n    LCASE: createKeyword({ name: 'LCASE' }),\n    ENCODE_FOR_URI: createKeyword({ name: 'ENCODE_FOR_URI' }),\n    CONTAINS: createKeyword({ name: 'CONTAINS' }),\n    STRSTARTS: createKeyword({ name: 'STRSTARTS' }),\n    STRENDS: createKeyword({ name: 'STRENDS' }),\n    STRBEFORE: createKeyword({ name: 'STRBEFORE' }),\n    STRAFTER: createKeyword({ name: 'STRAFTER' }),\n    YEAR: createKeyword({ name: 'YEAR' }),\n    MONTH: createKeyword({ name: 'MONTH' }),\n    DAY: createKeyword({ name: 'DAY' }),\n    HOURS: createKeyword({ name: 'HOURS' }),\n    MINUTES: createKeyword({ name: 'MINUTES' }),\n    SECONDS: createKeyword({ name: 'SECONDS' }),\n    TIMEZONE: createKeyword({ name: 'TIMEZONE' }),\n    TZ: createKeyword({ name: 'TZ' }),\n    NOW: createKeyword({ name: 'NOW' }),\n    UUID: createKeyword({ name: 'UUID' }),\n    STRUUID: createKeyword({ name: 'STRUUID' }),\n    MD5: createKeyword({ name: 'MD5' }),\n    SHA1: createKeyword({ name: 'SHA1' }),\n    SHA256: createKeyword({ name: 'SHA256' }),\n    SHA384: createKeyword({ name: 'SHA384' }),\n    SHA512: createKeyword({ name: 'SHA512' }),\n    COALESCE: createKeyword({ name: 'COALESCE' }),\n    IF: createKeyword({ name: 'IF' }),\n    STRLANG: createKeyword({ name: 'STRLANG' }),\n    STRDT: createKeyword({ name: 'STRDT' }),\n    sameTerm: createKeyword({ name: 'sameTerm' }),\n    isIRI: createKeyword({ name: 'isIRI' }),\n    isURI: createKeyword({ name: 'isURI' }),\n    isBLANK: createKeyword({ name: 'isBLANK' }),\n    isLITERAL: createKeyword({ name: 'isLITERAL' }),\n    isNUMERIC: createKeyword({ name: 'isNUMERIC' }),\n    REGEX: createKeyword({ name: 'REGEX' }),\n    SUBSTR: createKeyword({ name: 'SUBSTR' }),\n    REPLACE: createKeyword({ name: 'REPLACE' }),\n    EXISTS: createKeyword({ name: 'EXISTS' }),\n    NOT_EXISTS: createKeyword({ name: 'NOT_EXISTS', pattern: /NOT EXISTS/i }),\n    COUNT: createKeyword({ name: 'COUNT' }),\n    SUM: createKeyword({ name: 'SUM' }),\n    MIN: createKeyword({ name: 'MIN' }),\n    AVG: createKeyword({ name: 'AVG' }),\n    SAMPLE: createKeyword({ name: 'SAMPLE' }),\n    GROUP_CONCAT: createKeyword({ name: 'GROUP_CONCAT' }),\n    SEPARATOR: createKeyword({ name: 'SEPARATOR' }),\n    TRUE: createKeyword({ name: 'TRUE' }),\n    FALSE: createKeyword({ name: 'FALSE' }),\n    IN: createKeyword({ name: 'IN' }),\n    NOT_IN: createKeyword({ name: 'NOT_IN', pattern: /NOT IN/i }),\n    MAX: createKeyword({ name: 'MAX', longer_alt: MAX_LENGTH }),\n    MAX_LENGTH: MAX_LENGTH,\n    UNKNOWN: UNKNOWN,\n};\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar _a = require('./tokens'), turtleTokenTypes = _a.turtleTokenTypes, turtleTokenMap = _a.turtleTokenMap;\nimport { Parser, Lexer, } from 'chevrotain';\nvar TurtleParser = /** @class */ (function (_super) {\n    __extends(TurtleParser, _super);\n    function TurtleParser(config, tokens, lexerDefinition, performSelfAnalysis) {\n        if (config === void 0) { config = {}; }\n        if (tokens === void 0) { tokens = turtleTokenTypes; }\n        if (lexerDefinition === void 0) { lexerDefinition = tokens; }\n        if (performSelfAnalysis === void 0) { performSelfAnalysis = true; }\n        var _this = _super.call(this, tokens, __assign({ outputCst: true, recoveryEnabled: true }, config)) || this;\n        // Parsing Turtle requires that the parser keep a map of namespaces in state.\n        // Empty prefixes, for example, are allowed only if the empty prefix has been\n        // added to the namespaces map (for now, that's all this tracks). (TODO: We\n        // might want to use a visitor for this, but I'm doing it quick-and-dirty for\n        // now.)\n        // See here: https://www.w3.org/TR/turtle/#handle-PNAME_LN\n        _this.namespacesMap = {};\n        _this.semanticErrors = [];\n        // Clears the state that we have to manage on our own for each parse (see\n        // above for details).\n        _this.resetManagedState = function () {\n            _this.namespacesMap = {};\n            _this.semanticErrors = [];\n        };\n        _this.tokenize = function (document) {\n            return _this.lexer.tokenize(document).tokens;\n        };\n        // NOTE: This parser can parse in two modes, 'standard' and 'stardog'. The\n        // latter includes non-standard features like embedded triples patterns (edge\n        // properties).\n        _this.parse = function (document, mode) {\n            if (mode === void 0) { mode = 'standard'; }\n            _this.input = _this.lexer.tokenize(document).tokens;\n            var cst = _this.turtleDoc(0, [mode]);\n            // Next two items are copied so that they can be returned/held after parse\n            // state is cleared.\n            var errors = _this.errors.slice();\n            var semanticErrors = _this.semanticErrors.slice();\n            _this.resetManagedState();\n            return {\n                errors: errors,\n                semanticErrors: semanticErrors,\n                cst: cst,\n            };\n        };\n        _this.turtleDoc = _this.RULE('turtleDoc', function (mode) {\n            var allowEdgeProperties = mode === 'stardog';\n            _this.MANY(function () {\n                return _this.SUBRULE(_this.statement, { ARGS: [allowEdgeProperties] });\n            });\n        });\n        _this.statement = _this.RULE('statement', function (allowEdgeProperties) {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.directive); } },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.triples, { ARGS: [allowEdgeProperties] });\n                        _this.CONSUME(turtleTokenMap.Period);\n                    },\n                },\n            ]);\n        });\n        _this.directive = _this.RULE('directive', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.prefixID); } },\n                { ALT: function () { return _this.SUBRULE(_this.base); } },\n                { ALT: function () { return _this.SUBRULE(_this.sparqlPrefix); } },\n                { ALT: function () { return _this.SUBRULE(_this.sparqlBase); } },\n            ]);\n        });\n        _this.prefixID = _this.RULE('prefixID', function () {\n            _this.CONSUME(turtleTokenMap.TTL_PREFIX);\n            var pnameNsToken = _this.CONSUME(turtleTokenMap.PNAME_NS);\n            var iriToken = _this.CONSUME(turtleTokenMap.IRIREF);\n            var pnameImageWithoutColon = pnameNsToken.image.slice(0, -1);\n            var iriImage = iriToken.image;\n            _this.namespacesMap[pnameImageWithoutColon] = iriImage;\n            _this.CONSUME(turtleTokenMap.Period);\n        });\n        _this.base = _this.RULE('base', function () {\n            _this.CONSUME(turtleTokenMap.TTL_BASE);\n            _this.CONSUME(turtleTokenMap.IRIREF);\n            _this.CONSUME(turtleTokenMap.Period);\n        });\n        _this.sparqlBase = _this.RULE('sparqlBase', function () {\n            _this.CONSUME(turtleTokenMap.BASE);\n            _this.CONSUME(turtleTokenMap.IRIREF);\n        });\n        _this.sparqlPrefix = _this.RULE('sparqlPrefix', function () {\n            _this.CONSUME(turtleTokenMap.PREFIX);\n            var pnameNsToken = _this.CONSUME(turtleTokenMap.PNAME_NS);\n            var iriToken = _this.CONSUME(turtleTokenMap.IRIREF);\n            var pnameImageWithoutColon = pnameNsToken.image.slice(0, -1);\n            var iriImage = iriToken.image;\n            _this.namespacesMap[pnameImageWithoutColon] = iriImage;\n        });\n        // NOTE: Not part of Turtle spec. Part of Stardog's support for edge\n        // properties/embedded triples/a subset of RDF*.\n        // ALSO NOTE: Intentionally does not conform to the RDF* spec.\n        // Stardog does not allow nesting of embedded triples.\n        _this.triples = _this.RULE('triples', function (allowEdgeProperties) {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.subject);\n                        _this.SUBRULE1(_this.predicateObjectList, {\n                            ARGS: [allowEdgeProperties],\n                        });\n                    },\n                },\n                {\n                    GATE: function () { return Boolean(allowEdgeProperties); },\n                    ALT: function () {\n                        _this.SUBRULE(_this.EmbeddedTriplePattern);\n                        _this.SUBRULE(_this.predicateObjectList);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.blankNodePropertyList, {\n                            ARGS: [allowEdgeProperties],\n                        });\n                        _this.OPTION(function () {\n                            return _this.SUBRULE2(_this.predicateObjectList, {\n                                ARGS: [allowEdgeProperties],\n                            });\n                        });\n                    },\n                },\n            ]);\n        });\n        // NOTE: Not part of Turtle spec. Part of Stardog's support for edge\n        // properties/embedded triples/a subset of RDF*.\n        // ALSO NOTE: Intentionally does not conform to the RDF* spec.\n        // Stardog does not allow nesting of embedded triples.\n        _this.EmbeddedTriplePattern = _this.RULE('EmbeddedTriplePattern', function () {\n            _this.CONSUME(turtleTokenMap.LEmbed);\n            _this.SUBRULE(_this.triples);\n            _this.CONSUME(turtleTokenMap.REmbed);\n        });\n        // NOTE: Not part of Turtle spec. Part of Stardog's support for edge\n        // properties/embedded triples/a subset of RDF*.\n        // ALSO NOTE: Intentionally does not conform to the RDF* spec.\n        // Stardog does not allow embedded triples with object lists.\n        _this.predicateObjectList = _this.RULE('predicateObjectList', function (allowEdgeProperties) {\n            _this.SUBRULE(_this.verb);\n            _this.OR([\n                {\n                    ALT: function () {\n                        return _this.SUBRULE(_this.objectList, { ARGS: [allowEdgeProperties] });\n                    },\n                },\n                {\n                    GATE: function () { return Boolean(allowEdgeProperties); },\n                    ALT: function () {\n                        _this.SUBRULE(_this.EmbeddedPredicateObjectList);\n                        _this.SUBRULE(_this.object, { ARGS: [allowEdgeProperties] });\n                    },\n                },\n            ]);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.SUBRULE1(_this.verb);\n                    _this.OR1([\n                        {\n                            ALT: function () {\n                                return _this.SUBRULE1(_this.objectList, { ARGS: [allowEdgeProperties] });\n                            },\n                        },\n                        {\n                            GATE: function () { return Boolean(allowEdgeProperties); },\n                            ALT: function () {\n                                _this.SUBRULE1(_this.EmbeddedPredicateObjectList);\n                                _this.SUBRULE1(_this.object, { ARGS: [allowEdgeProperties] });\n                            },\n                        },\n                    ]);\n                });\n            });\n        });\n        // NOTE: Not part of Turtle spec. Part of Stardog's support for edge\n        // properties/embedded triples/a subset of RDF*.\n        // ALSO NOTE: Intentionally does not conform to the RDF* spec.\n        // Stardog does not allow nesting of embedded triples.\n        _this.EmbeddedPredicateObjectList = _this.RULE('EmbeddedPredicateObjectList', function () {\n            _this.CONSUME(turtleTokenMap.LCurly);\n            _this.SUBRULE(_this.predicateObjectList);\n            _this.CONSUME(turtleTokenMap.RCurly);\n        });\n        _this.subject = _this.RULE('subject', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNode); } },\n                { ALT: function () { return _this.SUBRULE(_this.collection); } },\n            ]);\n        });\n        _this.predicate = _this.RULE('predicate', function () {\n            _this.SUBRULE(_this.iri);\n        });\n        _this.objectList = _this.RULE('objectList', function (allowEdgeProperties) {\n            _this.SUBRULE(_this.object, { ARGS: [allowEdgeProperties] });\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Comma);\n                _this.SUBRULE1(_this.object, { ARGS: [allowEdgeProperties] });\n            });\n        });\n        _this.verb = _this.RULE('verb', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.predicate); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.A); } },\n            ]);\n        });\n        _this.literal = _this.RULE('literal', function () {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.RDFLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.NumericLiteral); } },\n                { ALT: function () { return _this.SUBRULE(_this.BooleanLiteral); } },\n            ]);\n        });\n        _this.blankNodePropertyList = _this.RULE('blankNodePropertyList', function (allowEdgeProperties) {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.SUBRULE(_this.predicateObjectList, { ARGS: [allowEdgeProperties] });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.object = _this.RULE('object', function (allowEdgeProperties) {\n            _this.OR([\n                { ALT: function () { return _this.SUBRULE(_this.iri); } },\n                { ALT: function () { return _this.SUBRULE(_this.BlankNode); } },\n                { ALT: function () { return _this.SUBRULE(_this.collection); } },\n                {\n                    ALT: function () {\n                        return _this.SUBRULE(_this.blankNodePropertyList, {\n                            ARGS: [allowEdgeProperties],\n                        });\n                    },\n                },\n                { ALT: function () { return _this.SUBRULE(_this.literal); } },\n            ]);\n        });\n        _this.collection = _this.RULE('collection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () { return _this.SUBRULE(_this.object); });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.NumericLiteral = _this.RULE('NumericLiteral', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.INTEGER); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.DECIMAL); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.DOUBLE); } },\n            ]);\n        });\n        _this.RDFLiteral = _this.RULE('RDFLiteral', function () {\n            _this.SUBRULE(_this.String);\n            _this.OPTION(function () {\n                _this.OR([\n                    { ALT: function () { return _this.CONSUME(turtleTokenMap.LANGTAG); } },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(turtleTokenMap.DoubleCaret);\n                            _this.SUBRULE(_this.iri);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.BooleanLiteral = _this.RULE('BooleanLiteral', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.TRUE); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.FALSE); } },\n            ]);\n        });\n        _this.String = _this.RULE('String', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_QUOTE); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_SINGLE_QUOTE); } },\n                {\n                    ALT: function () {\n                        return _this.CONSUME(turtleTokenMap.STRING_LITERAL_LONG_SINGLE_QUOTE);\n                    },\n                },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.STRING_LITERAL_LONG_QUOTE); } },\n            ]);\n        });\n        _this.iri = _this.RULE('iri', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.IRIREF); } },\n                { ALT: function () { return _this.SUBRULE(_this.PrefixedName); } },\n            ]);\n        });\n        _this.PrefixedName = _this.RULE('PrefixedName', function () {\n            var prefixedNameToken = _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.PNAME_LN); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.PNAME_NS); } },\n            ]);\n            var pnameNsImage = prefixedNameToken.image.slice(0, prefixedNameToken.image.indexOf(':'));\n            if (!(pnameNsImage in _this.namespacesMap)) {\n                _this.semanticErrors.push({\n                    name: 'NoNamespacePrefixError',\n                    message: 'A prefix was used for which there was no namespace defined.',\n                    token: prefixedNameToken,\n                    context: {\n                        ruleStack: _this.getHumanReadableRuleStack(),\n                        ruleOccurrenceStack: _this.RULE_OCCURRENCE_STACK.slice(),\n                    },\n                    resyncedTokens: [],\n                });\n            }\n        });\n        _this.BlankNode = _this.RULE('BlankNode', function () {\n            _this.OR([\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.BLANK_NODE_LABEL); } },\n                { ALT: function () { return _this.CONSUME(turtleTokenMap.ANON); } },\n            ]);\n        });\n        _this.lexer = new Lexer(lexerDefinition);\n        if (performSelfAnalysis) {\n            Parser.performSelfAnalysis(_this);\n        }\n        return _this;\n    }\n    return TurtleParser;\n}(Parser));\nexport { TurtleParser };\n","export var regex = {\n    or: function () {\n        var r = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            r[_i] = arguments[_i];\n        }\n        return new RegExp(r.map(function (_a) {\n            var source = _a.source;\n            return \"(\" + source + \")\";\n        }).join('|'));\n    },\n    and: function () {\n        var r = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            r[_i] = arguments[_i];\n        }\n        return new RegExp(r.map(function (_a) {\n            var source = _a.source;\n            return \"(\" + source + \")\";\n        }).join(''));\n    },\n    option: function (r) {\n        return new RegExp(\"(\" + r.source + \")?\");\n    },\n    many: function (r) {\n        return new RegExp(\"(\" + r.source + \")*\");\n    },\n};\n","import { regex } from './regex';\nexport var CATCH_ALL = /[\\s\\S]*/; // equivalent to /.*/s, which isn't a JS standard yet\nexport var CATCH_ALL_AT_LEAST_ONE = /[\\s\\S]+/; // equivalent to /.+/s, which isn't a JS standard yet\nexport var IRIREF = /<[^<>\\\\{}|\\^`\\u0000-\\u0020]*>/;\nexport var PN_CHARS_BASE = /[A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\nexport var LANGTAG = /@[a-zA-Z]+(-[a-zA-Z0-9]+)*/;\nexport var INTEGER = /\\d+/;\nexport var DECIMAL = /(\\d*\\.\\d+)|(\\d+\\.\\d*)/;\nexport var EXPONENT = /[eE][+-]?\\d+/;\nexport var ECHAR = /\\\\[tbnrf\"'\\\\]/;\nexport var WS = /[\\u0020\\u0009\\u000d\\u000a]/;\nexport var HEX = /[0-9A-Fa-f]/;\nexport var PN_LOCAL_ESC = /\\\\[_~.\\-!\\$&'()*+,=\\/?#@%;]/;\nexport var PN_CHARS_U = regex.or(PN_CHARS_BASE, /_/);\nexport var PN_CHARS = regex.or(PN_CHARS_U, /-/, /\\d/, /\\u00b7/, /[\\u0300-\\u036f]/, /[\\u203f-\\u2040]/);\nexport var PN_PREFIX = regex.and(PN_CHARS_BASE, regex.option(regex.and(regex.many(regex.or(PN_CHARS, /\\./)), PN_CHARS)));\nexport var PERCENT = regex.and(/%/, HEX, HEX);\nexport var PLX = regex.or(PERCENT, PN_LOCAL_ESC);\nexport var PN_LOCAL = regex.and(regex.or(PN_CHARS_U, /:/, /\\d/, PLX), regex.option(regex.and(regex.many(regex.or(PN_CHARS, /\\./, /:/, PLX)), regex.or(PN_CHARS, /:/, PLX))));\nexport var VARNAME = regex.and(regex.or(PN_CHARS_U, /\\d/), regex.many(regex.or(PN_CHARS_U, /\\d/, /\\u00b7/, /[\\u0300-\\u036f]/, /[\\u203f-\\u2040]/)));\nexport var ANON = regex.and(/\\[/, regex.many(WS), /\\]/);\nexport var NIL = regex.and(/\\(/, regex.many(WS), /\\)/);\nexport var STRING_LITERAL1 = regex.and(/'/, regex.many(regex.or(/[^\\u0027\\u005C\\u000A\\u000D]/, ECHAR)), /'/);\nexport var STRING_LITERAL2 = regex.and(/\"/, regex.many(regex.or(/[^\\u0022\\u005C\\u000A\\u000D]/, ECHAR)), /\"/);\nexport var STRING_LITERAL_LONG1 = regex.and(/'''/, regex.many(regex.and(regex.option(regex.or(/'/, /''/)), regex.or(/[^'\\\\]/, ECHAR))), /'''/);\nexport var STRING_LITERAL_LONG2 = regex.and(/\"\"\"/, regex.many(regex.and(regex.option(regex.or(/\"/, /\"\"/)), regex.or(/[^\"\\\\]/, ECHAR))), /\"\"\"/);\nexport var DOUBLE = regex.or(regex.and(/\\d+\\.\\d*/, EXPONENT), regex.and(/\\.\\d+/, EXPONENT), regex.and(/\\d+/, EXPONENT));\nexport var INTEGER_POSITIVE = regex.and(/\\+/, INTEGER);\nexport var DECIMAL_POSITIVE = regex.and(/\\+/, DECIMAL);\nexport var DOUBLE_POSITIVE = regex.and(/\\+/, DOUBLE);\nexport var INTEGER_NEGATIVE = regex.and(/-/, INTEGER);\nexport var DECIMAL_NEGATIVE = regex.and(/-/, DECIMAL);\nexport var DOUBLE_NEGATIVE = regex.and(/-/, DOUBLE);\nexport var VAR1 = regex.and(/\\?/, VARNAME);\nexport var VAR2 = regex.and(/\\$/, VARNAME);\nexport var BLANK_NODE_LABEL = regex.and(/_:/, regex.or(PN_CHARS_U, /\\d/), regex.option(regex.and(regex.many(regex.or(PN_CHARS, /\\./)), PN_CHARS)));\nexport var PNAME_NS = regex.and(regex.option(PN_PREFIX), /:/);\nexport var PNAME_LN = regex.and(PNAME_NS, PN_LOCAL);\n","// @ts-ignore: import types for declarations\nimport { createToken } from 'chevrotain';\nimport { STRING_LITERAL_LONG1, STRING_LITERAL_LONG2, PNAME_LN, IRIREF, LANGTAG, INTEGER, DECIMAL, DOUBLE, INTEGER_POSITIVE, DECIMAL_POSITIVE, DOUBLE_POSITIVE, INTEGER_NEGATIVE, DECIMAL_NEGATIVE, DOUBLE_NEGATIVE, STRING_LITERAL1, STRING_LITERAL2, NIL, ANON, PNAME_NS, BLANK_NODE_LABEL, VAR1, VAR2, PERCENT, } from 'helpers/matchers';\nvar STRING_LITERAL_LONG1_TOKEN = createToken({\n    name: 'STRING_LITERAL_LONG1',\n    pattern: STRING_LITERAL_LONG1,\n});\nvar STRING_LITERAL_LONG2_TOKEN = createToken({\n    name: 'STRING_LITERAL_LONG2',\n    pattern: STRING_LITERAL_LONG2,\n});\nvar PNAME_LN_TOKEN = createToken({\n    name: 'PNAME_LN',\n    pattern: PNAME_LN,\n});\nexport var terminals = {\n    IRIREF: createToken({\n        name: 'IRIREF',\n        pattern: IRIREF,\n        label: '<http://example.com>',\n    }),\n    LANGTAG: createToken({\n        name: 'LANGTAG',\n        pattern: LANGTAG,\n    }),\n    INTEGER: createToken({\n        name: 'INTEGER',\n        pattern: INTEGER,\n    }),\n    DECIMAL: createToken({\n        name: 'DECIMAL',\n        pattern: DECIMAL,\n    }),\n    DOUBLE: createToken({\n        name: 'DOUBLE',\n        pattern: DOUBLE,\n    }),\n    INTEGER_POSITIVE: createToken({\n        name: 'INTEGER_POSITIVE',\n        pattern: INTEGER_POSITIVE,\n    }),\n    DECIMAL_POSITIVE: createToken({\n        name: 'DECIMAL_POSITIVE',\n        pattern: DECIMAL_POSITIVE,\n    }),\n    DOUBLE_POSITIVE: createToken({\n        name: 'DOUBLE_POSITIVE',\n        pattern: DOUBLE_POSITIVE,\n    }),\n    INTEGER_NEGATIVE: createToken({\n        name: 'INTEGER_NEGATIVE',\n        pattern: INTEGER_NEGATIVE,\n    }),\n    DECIMAL_NEGATIVE: createToken({\n        name: 'DECIMAL_NEGATIVE',\n        pattern: DECIMAL_NEGATIVE,\n    }),\n    DOUBLE_NEGATIVE: createToken({\n        name: 'DOUBLE_NEGATIVE',\n        pattern: DOUBLE_NEGATIVE,\n    }),\n    STRING_LITERAL_LONG1: STRING_LITERAL_LONG1_TOKEN,\n    STRING_LITERAL_LONG2: STRING_LITERAL_LONG2_TOKEN,\n    STRING_LITERAL1: createToken({\n        name: 'STRING_LITERAL1',\n        pattern: STRING_LITERAL1,\n        longer_alt: STRING_LITERAL_LONG1_TOKEN,\n    }),\n    STRING_LITERAL2: createToken({\n        name: 'STRING_LITERAL2',\n        pattern: STRING_LITERAL2,\n        longer_alt: STRING_LITERAL_LONG2_TOKEN,\n    }),\n    NIL: createToken({\n        name: 'NIL',\n        pattern: NIL,\n        label: '()',\n    }),\n    ANON: createToken({\n        name: 'ANON',\n        pattern: ANON,\n        label: '[]',\n    }),\n    PNAME_LN: PNAME_LN_TOKEN,\n    PNAME_NS: createToken({\n        name: 'PNAME_NS',\n        pattern: PNAME_NS,\n        longer_alt: PNAME_LN_TOKEN,\n    }),\n    BLANK_NODE_LABEL: createToken({\n        name: 'BLANK_NODE_LABEL',\n        pattern: BLANK_NODE_LABEL,\n    }),\n    VAR1: createToken({\n        name: 'VAR1',\n        pattern: VAR1,\n        label: '?foo',\n    }),\n    VAR2: createToken({\n        name: 'VAR2',\n        pattern: VAR2,\n        label: '?bar',\n    }),\n    PERCENT: createToken({\n        name: 'PERCENT',\n        pattern: PERCENT,\n    }),\n};\n","import { IToken, CstNode, TokenType, } from 'chevrotain';\nexport var getAsTypedTuple = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return args;\n};\n// exported for convenience\nexport { IToken, CstNode, TokenType };\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar _a = require('../turtle/tokens'), turtleTokenTypes = _a.turtleTokenTypes, turtleTokenMap = _a.turtleTokenMap;\nvar sparqlTokenMap = require('../sparql/tokens').sparqlTokenMap;\nimport { createToken, Lexer } from 'chevrotain';\nimport memoize from 'memoize-one';\nimport { getAsTypedTuple } from 'helpers/types';\nimport isDeepEqual from 'lodash.isequal';\nvar shaclIriNamespace = 'http://www.w3.org/ns/shacl#';\nvar xsdIriNamespace = 'http://www.w3.org/2001/XMLSchema#';\n// Token categories, useful for making the parser rules simpler.\nexport var categoryTokenMap = {\n    ManyIriTakingPredicate: createToken({\n        name: 'ManyIriTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    SingleIriTakingPredicate: createToken({\n        name: 'SingleIriTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    NodeKindIRI: createToken({\n        name: 'NodeKindIRI',\n        pattern: Lexer.NA,\n    }),\n    IntTakingPredicate: createToken({\n        name: 'IntTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    StringLiteralQuoteTakingPredicate: createToken({\n        name: 'StringLiteralQuoteTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    LangStringTakingPredicate: createToken({\n        name: 'LangStringTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    BooleanTakingPredicate: createToken({\n        name: 'BooleanTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n    ShapeExpectingPredicate: createToken({\n        name: 'ShapeExpectingPredicate',\n        pattern: Lexer.NA,\n    }),\n    AnyLiteralTakingPredicate: createToken({\n        name: 'AnyLiteralTakingPredicate',\n        pattern: Lexer.NA,\n    }),\n};\nexport var categoryTokens = Object.keys(categoryTokenMap).map(function (key) { return categoryTokenMap[key]; });\nvar localNamesByCategory = {\n    ManyIriTakingPredicate: getAsTypedTuple('equals', 'disjoint', 'lessThan', 'lessThanOrEquals', 'targetClass', 'targetSubjectsOf', 'targetObjectsOf'),\n    SingleIriTakingPredicate: getAsTypedTuple('class', 'datatype', 'severity'),\n    NodeKindIRI: getAsTypedTuple('IRI', 'BlankNode', 'Literal', 'BlankNodeOrIRI', 'BlankNodeOrLiteral', 'IRIOrLiteral'),\n    IntTakingPredicate: getAsTypedTuple('minCount', 'maxCount', 'minLength', 'maxLength', 'qualifiedMinCount', 'qualifiedMaxCount'),\n    StringLiteralQuoteTakingPredicate: getAsTypedTuple('pattern', 'flags', 'prefix', 'namespace'),\n    LangStringTakingPredicate: getAsTypedTuple('message', 'labelTemplate'),\n    BooleanTakingPredicate: getAsTypedTuple('uniqueLang', 'qualifiedValueShapesDisjoint', 'closed', 'deactivated', 'optional'),\n    ShapeExpectingPredicate: getAsTypedTuple('not', 'node', 'property', 'qualifiedValueShape', 'sparql', 'declare', 'prefixes', 'parameter', 'nodeValidator', 'propertyValidator', 'validator'),\n    AnyLiteralTakingPredicate: getAsTypedTuple('minExclusive', 'minInclusive', 'maxExclusive', 'maxInclusive'),\n    other: getAsTypedTuple('Shape', 'NodeShape', 'PropertyShape', 'targetNode', 'message', 'path', 'alternativePath', 'inversePath', 'zeroOrMorePath', 'oneOrMorePath', 'zeroOrOnePath', 'nodeKind', 'languageIn', 'and', 'or', 'xone', 'ignoredProperties', 'hasValue', 'in', 'select', 'ask'),\n};\nvar xsdLocalNames = getAsTypedTuple('boolean', 'integer', 'string', 'date', 'dateTime', 'anyURI');\n// Map of local names back to their categories, for easier lookup:\nvar localNameToCategoryMap = Object.keys(localNamesByCategory).reduce(function (nameToCategoryMap, category) {\n    var categoryLocalNames = localNamesByCategory[category];\n    categoryLocalNames.forEach(function (localName) { return (nameToCategoryMap[localName] = category); });\n    return nameToCategoryMap;\n}, {});\nvar localNames = Object.keys(localNameToCategoryMap);\n// We can pre-compute all tokens for the `xsd` namespace except for those that\n// include prefixes (since we don't know a priori what the prefix will be).\n// For each XSD local name, we will create a \"category\" token that will\n// ultimately be used as the single token encompassing either the full\n// (un-prefixed) IRI or the prefixed name (i.e., `xsd:string). At this point,\n// we create only the category token and the full (un-prefixed) IRI token; the\n// prefixed token is created later (via `getShaclTokenTypes`) once we actually\n// know what the `xsd` prefix is.\nvar xsdUnprefixedTokenMap = xsdLocalNames.reduce(function (tokenMap, localName) {\n    var _a;\n    var tokenName = \"SHACL_xsd_\" + localName; // category token name\n    var iriTokenName = tokenName + \"_IRI\"; // IRI token name\n    // Category token that will ultimately select either an XSD IRI or an XSD PN_LOCAL:\n    var iriOrPrefixCategoryToken = createToken({\n        name: tokenName,\n        pattern: Lexer.NA,\n    });\n    return __assign({}, tokenMap, (_a = {}, _a[tokenName] = iriOrPrefixCategoryToken, _a[iriTokenName] = createToken({\n        name: iriTokenName,\n        pattern: \"<\" + xsdIriNamespace + localName,\n        categories: [iriOrPrefixCategoryToken, turtleTokenMap.IRIREF],\n    }), _a));\n}, {});\n// We can also pre-compute all SHACL tokens except for those that include\n// prefixes (again, since we don't know a priori what the SHACL prefix will be).\n// This helps keep our parser quick. We do it in the same way that we did for\n// XSD tokens, above -- we create a \"category\" token for each SHACL local name\n// that will be used to match either the full (un-prefixed) IRI or the prefixed\n// name (once we know what the SHACL prefix is).\nvar shaclUnprefixedTokenMap = localNames.reduce(function (tokenMap, localName) {\n    var _a;\n    var category = localNameToCategoryMap[localName];\n    var categoryToken = categoryTokenMap[category];\n    var tokenName = \"SHACL_\" + localName;\n    var iriTokenName = tokenName + \"_IRI\";\n    // Category token that will select either a SHACL IRI or a SHACL PN_LOCAL:\n    var iriOrPrefixCategoryToken = createToken({\n        name: tokenName,\n        pattern: Lexer.NA,\n        categories: categoryToken ? [categoryToken] : [],\n    });\n    return __assign({}, tokenMap, (_a = {}, _a[tokenName] = iriOrPrefixCategoryToken, _a[iriTokenName] = createToken({\n        name: iriTokenName,\n        pattern: \"<\" + shaclIriNamespace + localName + \">\",\n        categories: [iriOrPrefixCategoryToken, turtleTokenMap.IRIREF],\n    }), _a));\n}, xsdUnprefixedTokenMap);\nvar makePrefixer = function (prefix) { return function (localName) {\n    return prefix + \":\" + localName;\n}; };\n// Retrieves the complete map of all SHACL/XSD tokens, given the SHACL and XSD\n// prefixes. The map contains, for every local name, a token matching the full\n// IRI, a token matching the prefixed local name, and a \"category\" token that\n// matches both. The category token is useful for simplifying parser rules (not\n// having to match every SHACL token as both a full IRI and a prefixed local\n// name.)\n// This function is called by the SHACL parser. It is memoized because the\n// arguments are small and unlikely to change often, and the parser needs to be\n// fast, so we should avoid re-computing.\nexport var getShaclTokenMap = memoize(function (prefixes) {\n    var prefixWithShacl = makePrefixer(prefixes.shacl);\n    var prefixWithXsd = makePrefixer(prefixes.xsd);\n    // Add the prefixed local names to the SHACL token map now that we know the\n    // prefixes.\n    var shaclTokenMap = localNames.reduce(function (tokenMap, localName) {\n        var _a;\n        var tokenName = \"SHACL_\" + localName;\n        var prefixedTokenName = tokenName + \"_prefixed\";\n        return __assign({}, tokenMap, (_a = {}, _a[prefixedTokenName] = createToken({\n            name: prefixedTokenName,\n            pattern: prefixWithShacl(localName),\n            categories: [tokenMap[tokenName], turtleTokenMap.PNAME_LN],\n        }), _a));\n    }, shaclUnprefixedTokenMap);\n    // Add the prefixed local names to the XSD token map now that we know the\n    // prefixes.\n    return xsdLocalNames.reduce(function (tokenMap, localName) {\n        var _a;\n        var tokenName = \"SHACL_xsd_\" + localName;\n        var prefixedTokenName = tokenName + \"_prefixed\";\n        return __assign({}, tokenMap, (_a = {}, _a[prefixedTokenName] = createToken({\n            name: prefixedTokenName,\n            pattern: \"\" + prefixWithXsd(localName),\n            categories: [tokenMap[tokenName], turtleTokenMap.PNAME_LN],\n        }), _a));\n    }, shaclTokenMap);\n}, isDeepEqual);\n// Get the index of PNAME_NS and IRIREF so that we can re-use existing Turtle\n// tokens but ensure that our special SHACL/XSD tokens are inserted at the\n// right place (since order of tokens matters for chevrotain).\nvar pnameIndex = turtleTokenTypes.indexOf(sparqlTokenMap.PNAME_NS);\nvar iriIndex = turtleTokenTypes.indexOf(turtleTokenMap.IRIREF);\n// tokenMap keys will need to be sorted in reverse order so that tokens with\n// partial overlap are in the right order in the TokenType array.\nvar reverseSort = function (a, b) {\n    // @ts-ignore: unused variable\n    var _a = a.split('_'), aIgnored = _a[0], aName = _a[1], aRemainder = _a.slice(2);\n    // @ts-ignore: unused variable\n    var _b = b.split('_'), bIgnored = _b[0], bName = _b[1], bRemainder = _b.slice(2);\n    // Grab the local name and lowercase it:\n    var aSortString = (aName === 'xsd' ? aRemainder[0] : aName).toLowerCase();\n    var bSortString = (bName === 'xsd' ? bRemainder[0] : bName).toLowerCase();\n    if (aSortString === bSortString) {\n        // If local names are identical, prefer the one without a suffix to those with suffixes.\n        var aSuffix = aName === 'xsd' ? aRemainder[1] : aRemainder[0];\n        var bSuffix = bName === 'xsd' ? bRemainder[1] : bRemainder[0];\n        if (aSuffix && bSuffix) {\n            return 0; // when both local names have suffixes, treat as lexicographically the same for sorting\n        }\n        else {\n            return aSuffix ? 1 : -1;\n        }\n    }\n    else {\n        return aSortString < bSortString ? 1 : bSortString < aSortString ? -1 : 0;\n    }\n};\n// Given SHACL and XSD prefixes, this method returns an array of Turtle +\n// SHACL/XSD tokens, including tokens for prefixed local names, with the\n// SHACL/XSD tokens inserted at the proper positions so that they are matched\n// before the more generic Turtle tokens.\nexport var getShaclTokenTypes = memoize(function (prefixes) {\n    var tokenMap = getShaclTokenMap(prefixes);\n    var _a = Object.keys(tokenMap)\n        .sort(reverseSort)\n        .reduce(function (accumulator, key) {\n        if (key.endsWith('_IRI')) {\n            if (iriIndex < pnameIndex) {\n                accumulator.iriTokens.push(tokenMap[key.slice(0, -4)]);\n            }\n            accumulator.iriTokens.push(tokenMap[key]);\n        }\n        else if (key.endsWith('_prefixed')) {\n            if (pnameIndex < iriIndex) {\n                accumulator.pnameTokens.push(tokenMap[key.slice(0, -9)]);\n            }\n            accumulator.pnameTokens.push(tokenMap[key]);\n        }\n        return accumulator;\n    }, { pnameTokens: [], iriTokens: [] }), pnameTokens = _a.pnameTokens, iriTokens = _a.iriTokens;\n    if (pnameIndex < iriIndex) {\n        return turtleTokenTypes.slice(0, pnameIndex).concat(categoryTokens, pnameTokens, turtleTokenTypes.slice(pnameIndex, iriIndex), iriTokens, turtleTokenTypes.slice(iriIndex));\n    }\n    else {\n        return turtleTokenTypes.slice(0, iriIndex).concat(categoryTokens, iriTokens, turtleTokenTypes.slice(iriIndex, pnameIndex), pnameTokens, turtleTokenTypes.slice(pnameIndex));\n    }\n}, isDeepEqual);\n","// @ts-ignore: import types for declarations\nimport { createToken, Lexer } from 'chevrotain';\nimport { terminals } from './terminals';\nimport { keywords } from './keywords';\nexport var sparqlTokenMap = {\n    IRIREF: terminals.IRIREF,\n    LANGTAG: terminals.LANGTAG,\n    INTEGER: terminals.INTEGER,\n    DECIMAL: terminals.DECIMAL,\n    DOUBLE: terminals.DOUBLE,\n    INTEGER_POSITIVE: terminals.INTEGER_POSITIVE,\n    DECIMAL_POSITIVE: terminals.DECIMAL_POSITIVE,\n    DOUBLE_POSITIVE: terminals.DOUBLE_POSITIVE,\n    INTEGER_NEGATIVE: terminals.INTEGER_NEGATIVE,\n    DECIMAL_NEGATIVE: terminals.DECIMAL_NEGATIVE,\n    DOUBLE_NEGATIVE: terminals.DOUBLE_NEGATIVE,\n    STRING_LITERAL1: terminals.STRING_LITERAL1,\n    STRING_LITERAL2: terminals.STRING_LITERAL2,\n    STRING_LITERAL_LONG1: terminals.STRING_LITERAL_LONG1,\n    STRING_LITERAL_LONG2: terminals.STRING_LITERAL_LONG2,\n    NIL: terminals.NIL,\n    ANON: terminals.ANON,\n    PNAME_NS: terminals.PNAME_NS,\n    PNAME_LN: terminals.PNAME_LN,\n    BLANK_NODE_LABEL: terminals.BLANK_NODE_LABEL,\n    VAR1: terminals.VAR1,\n    VAR2: terminals.VAR2,\n    PERCENT: terminals.PERCENT,\n    Comment: createToken({\n        name: 'Comment',\n        pattern: /#[^\\n]*/,\n        group: 'comments',\n    }),\n    LCurly: createToken({ name: 'LCurly', pattern: '{' }),\n    RCurly: createToken({ name: 'RCurly', pattern: '}' }),\n    LParen: createToken({ name: 'LParen', pattern: '(' }),\n    RParen: createToken({ name: 'RParen', pattern: ')' }),\n    WhiteSpace: createToken({\n        name: 'WhiteSpace',\n        pattern: /\\s+/,\n        group: Lexer.SKIPPED,\n        line_breaks: true,\n    }),\n    Star: createToken({\n        name: 'Star',\n        pattern: '*',\n    }),\n    UNKNOWN: keywords.UNKNOWN,\n    Period: createToken({\n        name: 'Period',\n        pattern: '.',\n    }),\n    QuestionMark: createToken({\n        name: 'QuestionMark',\n        pattern: '?',\n    }),\n    Plus: createToken({\n        name: 'Plus',\n        pattern: '+',\n    }),\n    Minus: createToken({\n        name: 'Minus',\n        pattern: '-',\n    }),\n    LBracket: createToken({\n        name: 'LBracket',\n        pattern: '[',\n    }),\n    RBracket: createToken({\n        name: 'RBracket',\n        pattern: ']',\n    }),\n    Semicolon: createToken({\n        name: 'Semicolon',\n        pattern: ';',\n    }),\n    Comma: createToken({\n        name: 'Comma',\n        pattern: ',',\n    }),\n    Pipe: createToken({\n        name: 'Pipe',\n        pattern: '|',\n    }),\n    ForwardSlash: createToken({\n        name: 'ForwardSlash',\n        pattern: '/',\n    }),\n    Caret: createToken({\n        name: 'Caret',\n        pattern: '^',\n    }),\n    DoubleCaret: createToken({\n        name: 'DoubleCaret',\n        pattern: '^^',\n    }),\n    Bang: createToken({\n        name: 'Bang',\n        pattern: '!',\n    }),\n    LogicalOr: createToken({\n        name: 'LogicalOr',\n        pattern: '||',\n    }),\n    LogicalAnd: createToken({\n        name: 'LogicalAnd',\n        pattern: '&&',\n    }),\n    Equals: createToken({\n        name: 'Equals',\n        pattern: '=',\n    }),\n    NotEquals: createToken({\n        name: 'NotEquals',\n        pattern: '!=',\n    }),\n    LessThan: createToken({\n        name: 'LessThan',\n        pattern: '<',\n    }),\n    GreaterThan: createToken({\n        name: 'GreaterThan',\n        pattern: '>',\n    }),\n    LessThanEquals: createToken({\n        name: 'LessThanEquals',\n        pattern: '<=',\n    }),\n    GreaterThanEquals: createToken({\n        name: 'GreaterThanEquals',\n        pattern: '>=',\n    }),\n    LEmbed: createToken({\n        name: 'LEmbed',\n        pattern: '<<',\n    }),\n    REmbed: createToken({\n        name: 'REmbed',\n        pattern: '>>',\n    }),\n    SELECT: keywords.SELECT,\n    CONSTRUCT: keywords.CONSTRUCT,\n    DISTINCT: keywords.DISTINCT,\n    START: keywords.START,\n    END: keywords.END,\n    VIA: keywords.VIA,\n    CYCLIC: keywords.CYCLIC,\n    PATHS_SHORTEST: keywords.PATHS_SHORTEST,\n    PATHS_ALL: keywords.PATHS_ALL,\n    PATHS: keywords.PATHS,\n    AS: keywords.AS,\n    WHERE: keywords.WHERE,\n    A: keywords.A,\n    GROUP_BY: keywords.GROUP_BY,\n    ORDER_BY: keywords.ORDER_BY,\n    BY: keywords.BY,\n    BASE: keywords.BASE,\n    PREFIX: keywords.PREFIX,\n    DESCRIBE: keywords.DESCRIBE,\n    ASK: keywords.ASK,\n    FROM: keywords.FROM,\n    REDUCED: keywords.REDUCED,\n    NAMED: keywords.NAMED,\n    HAVING: keywords.HAVING,\n    ASC: keywords.ASC,\n    DESC: keywords.DESC,\n    OFFSET: keywords.OFFSET,\n    LIMIT: keywords.LIMIT,\n    VALUES: keywords.VALUES,\n    LOAD: keywords.LOAD,\n    SILENT: keywords.SILENT,\n    INTO: keywords.INTO,\n    CLEAR: keywords.CLEAR,\n    DROP: keywords.DROP,\n    CREATE: keywords.CREATE,\n    ADD: keywords.ADD,\n    TO: keywords.TO,\n    MOVE: keywords.MOVE,\n    COPY: keywords.COPY,\n    INSERT_DATA: keywords.INSERT_DATA,\n    DELETE_DATA: keywords.DELETE_DATA,\n    DELETE_WHERE: keywords.DELETE_WHERE,\n    WITH: keywords.WITH,\n    DELETE: keywords.DELETE,\n    INSERT: keywords.INSERT,\n    USING: keywords.USING,\n    DEFAULT: keywords.DEFAULT,\n    GRAPH: keywords.GRAPH,\n    ALL: keywords.ALL,\n    OPTIONAL: keywords.OPTIONAL,\n    SERVICE: keywords.SERVICE,\n    BIND: keywords.BIND,\n    UNNEST: keywords.UNNEST,\n    UNDEF: keywords.UNDEF,\n    MINUS: keywords.MINUS,\n    UNION: keywords.UNION,\n    FILTER: keywords.FILTER,\n    STR: keywords.STR,\n    LANG: keywords.LANG,\n    LANGMATCHES: keywords.LANGMATCHES,\n    DATATYPE: keywords.DATATYPE,\n    BOUND: keywords.BOUND,\n    IRI: keywords.IRI,\n    URI: keywords.URI,\n    BNODE: keywords.BNODE,\n    RAND: keywords.RAND,\n    ABS: keywords.ABS,\n    CEIL: keywords.CEIL,\n    FLOOR: keywords.FLOOR,\n    ROUND: keywords.ROUND,\n    CONCAT: keywords.CONCAT,\n    STRLEN: keywords.STRLEN,\n    UCASE: keywords.UCASE,\n    LCASE: keywords.LCASE,\n    ENCODE_FOR_URI: keywords.ENCODE_FOR_URI,\n    CONTAINS: keywords.CONTAINS,\n    STRSTARTS: keywords.STRSTARTS,\n    STRENDS: keywords.STRENDS,\n    STRBEFORE: keywords.STRBEFORE,\n    STRAFTER: keywords.STRAFTER,\n    YEAR: keywords.YEAR,\n    MONTH: keywords.MONTH,\n    DAY: keywords.DAY,\n    HOURS: keywords.HOURS,\n    MINUTES: keywords.MINUTES,\n    SECONDS: keywords.SECONDS,\n    TIMEZONE: keywords.TIMEZONE,\n    TZ: keywords.TZ,\n    NOW: keywords.NOW,\n    UUID: keywords.UUID,\n    STRUUID: keywords.STRUUID,\n    MD5: keywords.MD5,\n    SHA1: keywords.SHA1,\n    SHA256: keywords.SHA256,\n    SHA384: keywords.SHA384,\n    SHA512: keywords.SHA512,\n    COALESCE: keywords.COALESCE,\n    IF: keywords.IF,\n    STRLANG: keywords.STRLANG,\n    STRDT: keywords.STRDT,\n    sameTerm: keywords.sameTerm,\n    isIRI: keywords.isIRI,\n    isURI: keywords.isURI,\n    isBLANK: keywords.isBLANK,\n    isLITERAL: keywords.isLITERAL,\n    isNUMERIC: keywords.isNUMERIC,\n    REGEX: keywords.REGEX,\n    SUBSTR: keywords.SUBSTR,\n    REPLACE: keywords.REPLACE,\n    EXISTS: keywords.EXISTS,\n    NOT_EXISTS: keywords.NOT_EXISTS,\n    COUNT: keywords.COUNT,\n    SUM: keywords.SUM,\n    MIN: keywords.MIN,\n    AVG: keywords.AVG,\n    SAMPLE: keywords.SAMPLE,\n    GROUP_CONCAT: keywords.GROUP_CONCAT,\n    SEPARATOR: keywords.SEPARATOR,\n    TRUE: keywords.TRUE,\n    FALSE: keywords.FALSE,\n    IN: keywords.IN,\n    NOT_IN: keywords.NOT_IN,\n    MAX_LENGTH: keywords.MAX_LENGTH,\n    MAX: keywords.MAX,\n};\nexport var baseTokens = [\n    sparqlTokenMap.NIL,\n    sparqlTokenMap.ANON,\n    sparqlTokenMap.LCurly,\n    sparqlTokenMap.RCurly,\n    sparqlTokenMap.LParen,\n    sparqlTokenMap.RParen,\n    sparqlTokenMap.WhiteSpace,\n    sparqlTokenMap.IRIREF,\n    sparqlTokenMap.LANGTAG,\n    sparqlTokenMap.DOUBLE,\n    sparqlTokenMap.DECIMAL,\n    sparqlTokenMap.INTEGER,\n    sparqlTokenMap.DOUBLE_POSITIVE,\n    sparqlTokenMap.DECIMAL_POSITIVE,\n    sparqlTokenMap.INTEGER_POSITIVE,\n    sparqlTokenMap.DOUBLE_NEGATIVE,\n    sparqlTokenMap.DECIMAL_NEGATIVE,\n    sparqlTokenMap.INTEGER_NEGATIVE,\n    sparqlTokenMap.STRING_LITERAL1,\n    sparqlTokenMap.STRING_LITERAL2,\n    sparqlTokenMap.STRING_LITERAL_LONG1,\n    sparqlTokenMap.STRING_LITERAL_LONG2,\n    sparqlTokenMap.PNAME_NS,\n    sparqlTokenMap.PNAME_LN,\n    sparqlTokenMap.BLANK_NODE_LABEL,\n    sparqlTokenMap.VAR1,\n    sparqlTokenMap.VAR2,\n    sparqlTokenMap.Comment,\n    sparqlTokenMap.SELECT,\n    sparqlTokenMap.CONSTRUCT,\n    sparqlTokenMap.DISTINCT,\n    sparqlTokenMap.Star,\n    sparqlTokenMap.WHERE,\n    sparqlTokenMap.GROUP_BY,\n    sparqlTokenMap.ORDER_BY,\n    sparqlTokenMap.BY,\n    sparqlTokenMap.Period,\n    sparqlTokenMap.QuestionMark,\n    sparqlTokenMap.Plus,\n    sparqlTokenMap.Minus,\n    sparqlTokenMap.LBracket,\n    sparqlTokenMap.RBracket,\n    sparqlTokenMap.PERCENT,\n    sparqlTokenMap.BASE,\n    sparqlTokenMap.PREFIX,\n    sparqlTokenMap.DESCRIBE,\n    sparqlTokenMap.ASK,\n    sparqlTokenMap.FROM,\n    sparqlTokenMap.REDUCED,\n    sparqlTokenMap.NAMED,\n    sparqlTokenMap.HAVING,\n    sparqlTokenMap.ASC,\n    sparqlTokenMap.DESC,\n    sparqlTokenMap.OFFSET,\n    sparqlTokenMap.LIMIT,\n    sparqlTokenMap.VALUES,\n    sparqlTokenMap.LOAD,\n    sparqlTokenMap.SILENT,\n    sparqlTokenMap.INTO,\n    sparqlTokenMap.AS,\n    sparqlTokenMap.CLEAR,\n    sparqlTokenMap.DROP,\n    sparqlTokenMap.CREATE,\n    sparqlTokenMap.ADD,\n    sparqlTokenMap.TO,\n    sparqlTokenMap.MOVE,\n    sparqlTokenMap.COPY,\n    sparqlTokenMap.INSERT_DATA,\n    sparqlTokenMap.DELETE_DATA,\n    sparqlTokenMap.DELETE_WHERE,\n    sparqlTokenMap.WITH,\n    sparqlTokenMap.DELETE,\n    sparqlTokenMap.INSERT,\n    sparqlTokenMap.USING,\n    sparqlTokenMap.DEFAULT,\n    sparqlTokenMap.GRAPH,\n    sparqlTokenMap.ALL,\n    sparqlTokenMap.OPTIONAL,\n    sparqlTokenMap.SERVICE,\n    sparqlTokenMap.BIND,\n    sparqlTokenMap.UNDEF,\n    sparqlTokenMap.MINUS,\n    sparqlTokenMap.UNION,\n    sparqlTokenMap.FILTER,\n    sparqlTokenMap.LANGMATCHES,\n    sparqlTokenMap.LANG,\n    sparqlTokenMap.DATATYPE,\n    sparqlTokenMap.BOUND,\n    sparqlTokenMap.IRI,\n    sparqlTokenMap.URI,\n    sparqlTokenMap.BNODE,\n    sparqlTokenMap.RAND,\n    sparqlTokenMap.ABS,\n    sparqlTokenMap.CEIL,\n    sparqlTokenMap.FLOOR,\n    sparqlTokenMap.ROUND,\n    sparqlTokenMap.CONCAT,\n    sparqlTokenMap.STRLEN,\n    sparqlTokenMap.UCASE,\n    sparqlTokenMap.LCASE,\n    sparqlTokenMap.ENCODE_FOR_URI,\n    sparqlTokenMap.CONTAINS,\n    sparqlTokenMap.STRSTARTS,\n    sparqlTokenMap.STRENDS,\n    sparqlTokenMap.STRBEFORE,\n    sparqlTokenMap.STRAFTER,\n    sparqlTokenMap.YEAR,\n    sparqlTokenMap.MONTH,\n    sparqlTokenMap.DAY,\n    sparqlTokenMap.HOURS,\n    sparqlTokenMap.MINUTES,\n    sparqlTokenMap.SECONDS,\n    sparqlTokenMap.TIMEZONE,\n    sparqlTokenMap.TZ,\n    sparqlTokenMap.NOW,\n    sparqlTokenMap.UUID,\n    sparqlTokenMap.STRUUID,\n    sparqlTokenMap.MD5,\n    sparqlTokenMap.SHA1,\n    sparqlTokenMap.SHA256,\n    sparqlTokenMap.SHA384,\n    sparqlTokenMap.SHA512,\n    sparqlTokenMap.COALESCE,\n    sparqlTokenMap.IF,\n    sparqlTokenMap.STRLANG,\n    sparqlTokenMap.STRDT,\n    sparqlTokenMap.STR,\n    sparqlTokenMap.sameTerm,\n    sparqlTokenMap.isIRI,\n    sparqlTokenMap.isURI,\n    sparqlTokenMap.isBLANK,\n    sparqlTokenMap.isLITERAL,\n    sparqlTokenMap.isNUMERIC,\n    sparqlTokenMap.REGEX,\n    sparqlTokenMap.SUBSTR,\n    sparqlTokenMap.REPLACE,\n    sparqlTokenMap.EXISTS,\n    sparqlTokenMap.NOT_EXISTS,\n    sparqlTokenMap.COUNT,\n    sparqlTokenMap.SUM,\n    sparqlTokenMap.MIN,\n    sparqlTokenMap.MAX_LENGTH,\n    sparqlTokenMap.MAX,\n    sparqlTokenMap.AVG,\n    sparqlTokenMap.SAMPLE,\n    sparqlTokenMap.GROUP_CONCAT,\n    sparqlTokenMap.SEPARATOR,\n    sparqlTokenMap.TRUE,\n    sparqlTokenMap.FALSE,\n    sparqlTokenMap.Semicolon,\n    sparqlTokenMap.Comma,\n    sparqlTokenMap.ForwardSlash,\n    sparqlTokenMap.DoubleCaret,\n    sparqlTokenMap.Caret,\n    sparqlTokenMap.LogicalOr,\n    sparqlTokenMap.Pipe,\n    sparqlTokenMap.LogicalAnd,\n    sparqlTokenMap.NotEquals,\n    sparqlTokenMap.Bang,\n    sparqlTokenMap.Equals,\n    sparqlTokenMap.LessThanEquals,\n    sparqlTokenMap.GreaterThanEquals,\n    sparqlTokenMap.LEmbed,\n    sparqlTokenMap.REmbed,\n    sparqlTokenMap.LessThan,\n    sparqlTokenMap.GreaterThan,\n    sparqlTokenMap.IN,\n    sparqlTokenMap.NOT_IN,\n    sparqlTokenMap.A,\n    sparqlTokenMap.UNKNOWN,\n];\nexport var pathsTokens = [\n    sparqlTokenMap.START,\n    sparqlTokenMap.END,\n    sparqlTokenMap.VIA,\n    sparqlTokenMap.CYCLIC,\n    sparqlTokenMap.PATHS_SHORTEST,\n    sparqlTokenMap.PATHS_ALL,\n    sparqlTokenMap.PATHS,\n];\nexport var nonStandardTokens = pathsTokens.concat([sparqlTokenMap.UNNEST]);\nvar indexOfSelect = baseTokens.indexOf(sparqlTokenMap.SELECT);\nexport var stardogSparqlTokens = baseTokens.slice(0, indexOfSelect).concat(nonStandardTokens, baseTokens.slice(indexOfSelect));\nexport var sparqlTokenTypes = baseTokens.concat(nonStandardTokens);\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport escapeStringRegexp from 'escape-string-regexp';\nimport { isCstNode } from 'helpers/cst';\n// Given a SHACL prefix, returns a RegExp that can be used for grabbing the\n// local name (e.g., the 'NodeShape' in 'sh:NodeShape') from either a full\n// SHACL IRI or a prefixed local name.\nvar getShaclLocalNameMatcher = function (shaclPrefix) {\n    return new RegExp(\"(?:shacl#|\" + escapeStringRegexp(shaclPrefix) + \":)(\\\\S+?)>?$\");\n};\n// Traverses the tree of descendants for a given CstNode until a token is\n// found. Returns the \"start\" token for the CstNode (i.e., the earliest token\n// encompassed by the CstNode). This is useful for diagnostics.\nvar getUnderlyingStartToken = function (ctx) {\n    var currentNode = ctx;\n    while (currentNode.children) {\n        var currentNodeKey = Object.keys(currentNode.children)[0];\n        currentNode = currentNode.children[currentNodeKey][0];\n    }\n    return currentNode;\n};\n// Grabs the local name (e.g., the 'NodeShape' in 'sh:NodeShape') from either\n// a full SHACL IRI or a prefixed local name, if it is available.\nvar getLocalName = function (iri, matcher) {\n    var result = matcher.exec(iri);\n    if (result) {\n        return result[1];\n    }\n};\n// Given an initial (possibly partially complete) `shape` object and an array\n// of CstElements matching the `shaclRulePredicateObjectList` grammar rule,\n// transforms the `shape` into a complete `ShaclShape` with associated SHACL\n// types and predicates.\n// NOTE: mutates `shape`!\nvar addPredicatesAndTypesToShape = function (shape, shaclRulePredicateObjectListNodes) {\n    shaclRulePredicateObjectListNodes.forEach(function (node) {\n        var child = node.children[Object.keys(node.children)[0]][0];\n        switch (child.name) {\n            case 'shaclVerbShape': {\n                var token = getUnderlyingStartToken(child);\n                var verbTokenInsensitive = token.image.toLowerCase();\n                var isTypeVerb = verbTokenInsensitive === 'a' ||\n                    verbTokenInsensitive === 'rdf:type' ||\n                    verbTokenInsensitive ===\n                        '<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>';\n                if (!isTypeVerb) {\n                    return;\n                }\n                Object.keys(child.children).forEach(function (key) {\n                    if (key !== 'shaclShapeType') {\n                        return;\n                    }\n                    var shapeTypeNode = child.children[key][0];\n                    if (shapeTypeNode.children.SHACL_NodeShape) {\n                        shape.types.push({\n                            type: 'NodeShape',\n                            token: getUnderlyingStartToken(shapeTypeNode),\n                        });\n                    }\n                    else if (shapeTypeNode.children.SHACL_PropertyShape) {\n                        shape.types.push({\n                            type: 'PropertyShape',\n                            token: getUnderlyingStartToken(shapeTypeNode),\n                        });\n                    }\n                });\n                break;\n            }\n            case 'shaclPredicateIRI': {\n                if (child.children.SingleIriTakingPredicate) {\n                    shape.predicates.push({\n                        type: 'SingleIriTakingPredicate',\n                        token: getUnderlyingStartToken(child.children\n                            .SingleIriTakingPredicate[0]),\n                    });\n                }\n                else if (child.children.ManyIriTakingPredicate) {\n                    shape.predicates.push({\n                        type: 'ManyIriTakingPredicate',\n                        token: getUnderlyingStartToken(child.children\n                            .ManyIriTakingPredicate[0]),\n                    });\n                }\n                break;\n            }\n            case 'shaclNodeKind':\n                shape.predicates.push({\n                    type: 'nodeKind',\n                    token: child.children.SHACL_nodeKind[0],\n                });\n                break;\n            case 'shaclTargetNode':\n                shape.predicates.push({\n                    type: 'targetNode',\n                    token: child.children.SHACL_targetNode[0],\n                });\n                break;\n            case 'shaclPropertyPath':\n                shape.predicates.push({\n                    type: 'path',\n                    token: child.children.SHACL_path[0],\n                });\n                break;\n            case 'shaclLiteralConstraint':\n                shape.predicates.push({\n                    type: 'LiteralConstraint',\n                    token: getUnderlyingStartToken(child),\n                });\n                break;\n            case 'shaclListTakingConstraint':\n                shape.predicates.push({\n                    type: 'ListTakingConstraint',\n                    token: getUnderlyingStartToken(child),\n                });\n                break;\n            case 'shaclShapeExpectingConstraint':\n                shape.predicates.push({\n                    type: 'ShapeExpectingPredicate',\n                    token: child.children.ShapeExpectingPredicate[0],\n                });\n                break;\n            case 'shaclHasValueConstraint':\n                shape.predicates.push({\n                    type: 'hasValue',\n                    token: child.children.SHACL_hasValue[0],\n                });\n                break;\n            default:\n                console.log(\"SHACL predicateObjectList with name \" + child.name + \" not recognized.\");\n        }\n    });\n};\n// Utility method for constructing a `ShaclShape` from CstElements matching the\n// `shaclShape` grammar rule.\nvar getShaclShapeFromBlankNodePropertyList = function (ctx) {\n    var blankNodeNode = ctx.blankNodePropertyList[0];\n    var predicateObjectListNode = blankNodeNode.children.predicateObjectList[0];\n    var optionalPredicateObjectListNode = ctx.predicateObjectList\n        ? ctx.predicateObjectList[0]\n        : null;\n    if (!isCstNode(predicateObjectListNode) &&\n        !isCstNode(optionalPredicateObjectListNode)) {\n        return;\n    }\n    var shaclRulePredicateObjectListNodes = optionalPredicateObjectListNode &&\n        optionalPredicateObjectListNode.children &&\n        optionalPredicateObjectListNode.children.shaclRulePredicateObjectList\n        ? (predicateObjectListNode.children.shaclRulePredicateObjectList ||\n            []).concat(optionalPredicateObjectListNode.children\n            .shaclRulePredicateObjectList) : predicateObjectListNode.children.shaclRulePredicateObjectList;\n    if (!shaclRulePredicateObjectListNodes) {\n        return;\n    }\n    var shape = {\n        subject: {\n            type: 'blankNodePropertyList',\n            token: getUnderlyingStartToken(blankNodeNode),\n        },\n        types: [],\n        predicates: [],\n    };\n    addPredicatesAndTypesToShape(shape, shaclRulePredicateObjectListNodes);\n    return shape;\n};\n// Returns a new SHACL visitor that extends that given BaseVisitor. The SHACL\n// visitor is capable of constructing ShaclShape objects from a given CST and\n// then using those shapes to perform validations that cannot be performed in\n// the initial parse of a SHACL document.\nexport var getShaclVisitor = function (BaseVisitor) {\n    var ShaclVisitor = /** @class */ (function (_super) {\n        __extends(ShaclVisitor, _super);\n        function ShaclVisitor() {\n            var _this = _super.call(this) || this;\n            // `triples` have two alternatives, one with a `subject` and one with a\n            // `blankNodePropertyList`. This method constructs SHACL shapes for each\n            // alternative.\n            _this.triples = function (ctx) {\n                if (ctx.subject) {\n                    var predicateObjectListNode = ctx.predicateObjectList[0];\n                    if (!isCstNode(predicateObjectListNode)) {\n                        return;\n                    }\n                    var shaclRulePredicateObjectListNodes = predicateObjectListNode.children.shaclRulePredicateObjectList;\n                    if (!shaclRulePredicateObjectListNodes) {\n                        return;\n                    }\n                    var shape = {\n                        subject: {\n                            type: Object.keys(ctx.subject[0].children)[0] === 'collection'\n                                ? 'collection'\n                                : 'subject',\n                            token: getUnderlyingStartToken(ctx.subject[0]),\n                        },\n                        types: [],\n                        predicates: [],\n                    };\n                    addPredicatesAndTypesToShape(shape, shaclRulePredicateObjectListNodes);\n                    _this.shapes.push(shape);\n                    _this.visit(ctx.subject);\n                    _this.visit(predicateObjectListNode);\n                }\n                else {\n                    var shape = getShaclShapeFromBlankNodePropertyList(ctx);\n                    if (!shape) {\n                        return;\n                    }\n                    _this.shapes.push(shape);\n                    _this.visit(ctx.blankNodePropertyList);\n                    if (ctx.predicateObjectList) {\n                        _this.visit(ctx.predicateObjectList);\n                    }\n                }\n            };\n            // Some SHACL shapes (e.g., nested PropertyShapes) are not matched\n            // by the `triples` grammar rule; instead, they match `shapeShape`.\n            _this.shaclShape = function (ctx) {\n                if (!ctx.blankNodePropertyList) {\n                    // Not an inline shape we need to traverse, just an identifier.\n                    return;\n                }\n                var shape = getShaclShapeFromBlankNodePropertyList(ctx);\n                if (!shape) {\n                    return;\n                }\n                _this.shapes.push(shape);\n                _this.visit(ctx.blankNodePropertyList);\n            };\n            _this.$resetState = function () {\n                _this.shapes = [];\n            };\n            _this.$validateShapes = function (_a) {\n                var shaclPrefix = _a.shacl;\n                var validationErrors = [];\n                var localNameMatcher = getShaclLocalNameMatcher(shaclPrefix);\n                var bnodeCount = 0;\n                var shapesConsolidatedBySubject = _this.shapes.reduce(function (consolidatedShapes, shape) {\n                    var image = shape.subject.token.image;\n                    var subjectImage = image === '[' ? \"bnode\" + ++bnodeCount : image;\n                    if (!consolidatedShapes[subjectImage]) {\n                        consolidatedShapes[subjectImage] = {\n                            subjects: [shape.subject],\n                            types: shape.types,\n                            predicates: shape.predicates,\n                        };\n                    }\n                    else {\n                        var consolidatedShape = consolidatedShapes[subjectImage];\n                        consolidatedShapes[subjectImage] = {\n                            subjects: consolidatedShape.subjects.concat([shape.subject]),\n                            types: consolidatedShape.types.concat(shape.types),\n                            predicates: consolidatedShape.predicates.concat(shape.predicates),\n                        };\n                    }\n                    return consolidatedShapes;\n                }, {});\n                Object.keys(shapesConsolidatedBySubject).forEach(function (subjectImage) {\n                    var _a = shapesConsolidatedBySubject[subjectImage], subjects = _a.subjects, types = _a.types, predicates = _a.predicates;\n                    var shapeType;\n                    types.forEach(function (_a) {\n                        var type = _a.type;\n                        if (shapeType && type !== shapeType) {\n                            validationErrors.push({\n                                name: 'ShapeTypeError',\n                                message: 'A SHACL shape can be at most one of NodeShape or PropertyShape.',\n                                token: subjects[0].token,\n                            });\n                        }\n                        else if (!shapeType) {\n                            shapeType = type;\n                        }\n                    });\n                    var pathPredicates = [];\n                    var nonPathPredicateMap = {};\n                    predicates.forEach(function (predicate) {\n                        var image = predicate.token.image;\n                        var localName = getLocalName(image, localNameMatcher);\n                        var predicateImage = localName\n                            ? shaclPrefix + \":\" + localName\n                            : image;\n                        if (predicateImage === shaclPrefix + \":path\") {\n                            pathPredicates.push(predicate);\n                        }\n                        else {\n                            if (!nonPathPredicateMap[predicateImage]) {\n                                nonPathPredicateMap[predicateImage] = [];\n                            }\n                            nonPathPredicateMap[predicateImage].push(predicate);\n                        }\n                    });\n                    if (pathPredicates.length > 0) {\n                        if (shapeType === 'NodeShape') {\n                            validationErrors.push({\n                                name: 'ShapePropertyError',\n                                message: 'SHACL instances of `NodeShape` cannot have a value for the `path` property.',\n                                token: pathPredicates[0].token,\n                            });\n                        }\n                        else {\n                            shapeType = 'PropertyShape';\n                        }\n                        if (pathPredicates.length > 1) {\n                            validationErrors.push({\n                                name: 'ShapePropertyError',\n                                message: 'A shape can have at most one value for sh:path.',\n                                token: pathPredicates[1].token,\n                            });\n                        }\n                    }\n                    if (shapeType === 'NodeShape') {\n                        [\n                            'minCount',\n                            'maxCount',\n                            'uniqueLang',\n                            'lessThan',\n                            'lessThanOrEquals',\n                            'qualifiedValueShape',\n                        ].forEach(function (image) {\n                            var prefixedImage = shaclPrefix + \":\" + image;\n                            if (nonPathPredicateMap[prefixedImage]) {\n                                validationErrors.push({\n                                    name: 'ShapePropertyError',\n                                    message: \"A NodeShape cannot have any value for \" + prefixedImage + \".\",\n                                    token: nonPathPredicateMap[prefixedImage][0].token,\n                                });\n                            }\n                        });\n                    }\n                    else {\n                        [\n                            'deactivated',\n                            'severity',\n                            'datatype',\n                            'nodeKind',\n                            'minCount',\n                            'maxCount',\n                            'minExclusive',\n                            'minInclusive',\n                            'maxExclusive',\n                            'maxInclusive',\n                            'minLength',\n                            'maxLength',\n                            'languageIn',\n                            'uniqueLang',\n                            'in',\n                        ].forEach(function (image) {\n                            var prefixedImage = shaclPrefix + \":\" + image;\n                            if (nonPathPredicateMap[prefixedImage] &&\n                                nonPathPredicateMap[prefixedImage].length > 1) {\n                                validationErrors.push({\n                                    name: 'ShapePropertyError',\n                                    message: \"A shape can have at most one value for \" + prefixedImage + \".\",\n                                    token: nonPathPredicateMap[prefixedImage][1].token,\n                                });\n                            }\n                        });\n                    }\n                });\n                return { validationErrors: validationErrors };\n            };\n            _this.validateVisitor();\n            _this.shapes = [];\n            return _this;\n        }\n        return ShaclVisitor;\n    }(BaseVisitor));\n    return new ShaclVisitor();\n};\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { TurtleParser } from '../turtle/TurtleParser';\nimport { Lexer, Parser, } from 'chevrotain';\nimport { getShaclVisitor } from 'shacl/visitor';\nvar _a = require('./tokens'), getShaclTokenTypes = _a.getShaclTokenTypes, getShaclTokenMap = _a.getShaclTokenMap, categoryTokenMap = _a.categoryTokenMap;\nvar turtleTokenMap = require('../turtle/tokens').turtleTokenMap;\n// A SHACL parser for the Turtle serialization of SHACL only. The parser can\n// can accept any arbitrary namespace prefix for SHACL/XSD and still tokenize\n// and parse the document correctly (it will also, of course, parse docuemnts\n// using the full SHACL/XSD IRIs). The parser runs both a parse phase and a\n// second validation phase (using a visitor) in order to accommodate SHACL\n// rules that are not purely syntactic.\nvar ShaclParser = /** @class */ (function (_super) {\n    __extends(ShaclParser, _super);\n    function ShaclParser(config, prefixes) {\n        if (prefixes === void 0) { prefixes = { shacl: 'sh', xsd: 'xsd' }; }\n        var _this = _super.call(this, __assign({ outputCst: true, recoveryEnabled: true }, config), getShaclTokenTypes(prefixes), getShaclTokenTypes(prefixes), false) || this;\n        // Some SHACL rules cannot be checked for violations during the first parse.\n        // The visitor accepts the CST that results from parsing and checks\n        // conformity with these SHACL rules.\n        _this.validateWithVisitor = function (cst) {\n            // To save resources while parsing, the shaclVisitor is a singleton.\n            if (!_this.shaclVisitor) {\n                var BaseSrsVisitor = _this.getBaseCstVisitorConstructorWithDefaults();\n                _this.shaclVisitor = getShaclVisitor(BaseSrsVisitor);\n            }\n            else {\n                _this.shaclVisitor.$resetState();\n            }\n            _this.shaclVisitor.visit(cst);\n            return _this.shaclVisitor.$validateShapes(_this.prefixes);\n        };\n        _this.tokenize = function (document) {\n            return _this.lexer.tokenize(document).tokens;\n        };\n        _this.parse = function (document) {\n            _this.input = _this.tokenize(document);\n            var cst = _this.turtleDoc();\n            var validationErrors = _this.validateWithVisitor(cst).validationErrors;\n            // Next two items are copied so that they can be returned/held after parse\n            // state is cleared.\n            var errors = _this.errors.slice();\n            var semanticErrors = _this.semanticErrors.concat(validationErrors);\n            return {\n                errors: errors,\n                semanticErrors: semanticErrors,\n                cst: cst,\n            };\n        };\n        _this.predicateObjectList = _this.OVERRIDE_RULE('predicateObjectList', function () {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.shaclRulePredicateObjectList);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.SUBRULE(_this.verb);\n                        _this.SUBRULE(_this.objectList);\n                    },\n                },\n            ]);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Semicolon);\n                _this.OPTION(function () {\n                    _this.OR1([\n                        {\n                            ALT: function () {\n                                _this.SUBRULE1(_this.shaclRulePredicateObjectList);\n                            },\n                        },\n                        {\n                            ALT: function () {\n                                _this.SUBRULE1(_this.verb);\n                                _this.SUBRULE1(_this.objectList);\n                            },\n                        },\n                    ]);\n                });\n            });\n        });\n        _this.shaclRulePredicateObjectList = _this.RULE('shaclRulePredicateObjectList', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclPredicateIRI); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclNodeKind); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclTargetNode); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclPropertyPath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclLiteralConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclListTakingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShapeExpectingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclHasValueConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclVerbShape); },\n                },\n            ]);\n        });\n        _this.shaclPredicateIRI = _this.RULE('shaclPredicateIRI', function () {\n            _this.OR([\n                {\n                    ALT: function () {\n                        _this.CONSUME(categoryTokenMap.SingleIriTakingPredicate);\n                        _this.SUBRULE(_this.iri);\n                    },\n                },\n                {\n                    ALT: function () {\n                        _this.CONSUME(categoryTokenMap.ManyIriTakingPredicate);\n                        _this.SUBRULE1(_this.iri);\n                        _this.MANY(function () {\n                            _this.CONSUME(turtleTokenMap.Comma);\n                            _this.SUBRULE2(_this.iri);\n                        });\n                    },\n                },\n            ]);\n        });\n        _this.shaclNodeKind = _this.RULE('shaclNodeKind', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_nodeKind);\n            _this.CONSUME(categoryTokenMap.NodeKindIRI);\n        });\n        _this.shaclTargetNode = _this.RULE('shaclTargetNode', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_targetNode);\n            _this.SUBRULE(_this.shaclIRIOrLiteral);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Comma);\n                _this.SUBRULE1(_this.shaclIRIOrLiteral);\n            });\n        });\n        _this.shaclVerbShape = _this.RULE('shaclVerbShape', function () {\n            _this.SUBRULE(_this.verb);\n            _this.SUBRULE(_this.shaclShapeType);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.Comma);\n                _this.SUBRULE1(_this.shaclShapeType);\n            });\n        });\n        _this.shaclShapeType = _this.RULE('shaclShapeType', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_Shape); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_NodeShape); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_PropertyShape); },\n                },\n            ]);\n        });\n        _this.shaclPropertyPath = _this.RULE('shaclPropertyPath', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_path);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n        });\n        _this.shaclPropertyPathPath = _this.RULE('shaclPropertyPathPath', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclPredicatePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclSequencePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclAlternativePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclInversePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclZeroOrMorePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclOneOrMorePath); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclZeroOrOnePath); },\n                },\n            ]);\n        });\n        _this.shaclPredicatePath = _this.RULE('shaclPredicatePath', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.iri); },\n                },\n                {\n                    // This case does not seem to be allowed by the SHACL spec, but the\n                    // online W3C validator accepts one level of parens wrapping the IRI.\n                    ALT: function () {\n                        _this.CONSUME(turtleTokenMap.LParen);\n                        _this.SUBRULE1(_this.iri);\n                        _this.CONSUME(turtleTokenMap.RParen);\n                    },\n                },\n            ]);\n        });\n        _this.shaclSequencePath = _this.RULE('shaclSequencePath', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.AT_LEAST_ONE(function () { return _this.SUBRULE1(_this.shaclPropertyPathPath); });\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclAlternativePath = _this.RULE('shaclAlternativePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_alternativePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath); // This does not match the SHACL spec, but it does match the test cases, which violate the spec. ;_;\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclInversePath = _this.RULE('shaclInversePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_inversePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclZeroOrMorePath = _this.RULE('shaclZeroOrMorePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_zeroOrMorePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclOneOrMorePath = _this.RULE('shaclOneOrMorePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_oneOrMorePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclZeroOrOnePath = _this.RULE('shaclZeroOrOnePath', function () {\n            _this.CONSUME(turtleTokenMap.LBracket);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_zeroOrOnePath);\n            _this.SUBRULE(_this.shaclPropertyPathPath);\n            _this.OPTION(function () { return _this.CONSUME(turtleTokenMap.Semicolon); });\n            _this.CONSUME(turtleTokenMap.RBracket);\n        });\n        _this.shaclLiteralConstraint = _this.RULE('shaclLiteralConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclIntConstraint); },\n                },\n                // TODO: Some specificity here is possibly unnecessary -- e.g., maybe `shaclStringConstraint` and `shaclStringLiteralQuoteConstraint` can be consolidated in some way?\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclStringConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclStringLiteralQuoteConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclLangStringConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclBooleanConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclAnyLiteralConstraint); },\n                },\n            ]);\n        });\n        _this.shaclIntConstraint = _this.RULE('shaclIntConstraint', function () {\n            _this.CONSUME(categoryTokenMap.IntTakingPredicate);\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(turtleTokenMap.INTEGER); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclXsdInteger); },\n                },\n            ]);\n        });\n        _this.shaclStringConstraint = _this.RULE('shaclStringConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_select); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_ask); },\n                },\n            ]);\n            _this.SUBRULE(_this.String); // TODO: a bit too lax?\n        });\n        _this.shaclStringLiteralQuoteConstraint = _this.RULE('shaclStringLiteralQuoteConstraint', function () {\n            _this.CONSUME(categoryTokenMap.StringLiteralQuoteTakingPredicate);\n            _this.CONSUME(turtleTokenMap.STRING_LITERAL_QUOTE);\n            _this.OPTION(function () {\n                _this.OR([\n                    {\n                        ALT: function () { return _this.CONSUME(turtleTokenMap.LANGTAG); },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(turtleTokenMap.DoubleCaret);\n                            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_string);\n                        },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME1(turtleTokenMap.DoubleCaret);\n                            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_anyURI);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.shaclLangStringConstraint = _this.RULE('shaclLangStringConstraint', function () {\n            _this.CONSUME(categoryTokenMap.LangStringTakingPredicate);\n            _this.SUBRULE(_this.String);\n            _this.OPTION(function () {\n                _this.OR([\n                    {\n                        ALT: function () { return _this.CONSUME(turtleTokenMap.LANGTAG); },\n                    },\n                    {\n                        ALT: function () {\n                            _this.CONSUME(turtleTokenMap.DoubleCaret);\n                            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_string);\n                        },\n                    },\n                ]);\n            });\n        });\n        _this.shaclBooleanConstraint = _this.RULE('shaclBooleanConstraint', function () {\n            _this.CONSUME(categoryTokenMap.BooleanTakingPredicate);\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(turtleTokenMap.TRUE); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(turtleTokenMap.FALSE); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclXsdBoolean); },\n                },\n            ]);\n        });\n        _this.shaclAnyLiteralConstraint = _this.RULE('shaclAnyLiteralConstraint', function () {\n            _this.CONSUME(categoryTokenMap.AnyLiteralTakingPredicate);\n            _this.SUBRULE(_this.literal);\n        });\n        _this.shaclListTakingConstraint = _this.RULE('shaclListTakingConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclLanguageInConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShapeListTakingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclIRIListTakingConstraint); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShapeOrLiteralListTakingConstraint); },\n                },\n            ]);\n        });\n        _this.shaclLanguageInConstraint = _this.RULE('shaclLanguageInConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_languageIn);\n            _this.SUBRULE(_this.shaclStringCollection);\n        });\n        _this.shaclStringCollection = _this.RULE('shaclStringCollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.CONSUME(turtleTokenMap.STRING_LITERAL_QUOTE);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclShapeListTakingConstraint = _this.RULE('shaclShapeListTakingConstraint', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_and); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_or); },\n                },\n                {\n                    ALT: function () { return _this.CONSUME(_this.shaclTokenMap.SHACL_xone); },\n                },\n            ]);\n            _this.SUBRULE(_this.shaclShapeCollection);\n        });\n        _this.shaclShapeCollection = _this.RULE('shaclShapeCollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.SUBRULE(_this.shaclShape);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclIRIListTakingConstraint = _this.RULE('shaclIRIListTakingConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_ignoredProperties);\n            _this.SUBRULE(_this.shaclIRICollection);\n        });\n        _this.shaclIRICollection = _this.RULE('shaclIRICollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.SUBRULE(_this.iri);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclShapeOrLiteralListTakingConstraint = _this.RULE('shaclShapeOrLiteralListTakingConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_in);\n            _this.SUBRULE(_this.shaclShapeOrLiteralCollection);\n        });\n        _this.shaclShapeOrLiteralCollection = _this.RULE('shaclShapeOrLiteralCollection', function () {\n            _this.CONSUME(turtleTokenMap.LParen);\n            _this.MANY(function () {\n                _this.SUBRULE(_this.shaclShapeOrLiteral);\n            });\n            _this.CONSUME(turtleTokenMap.RParen);\n        });\n        _this.shaclShapeExpectingConstraint = _this.RULE('shaclShapeExpectingConstraint', function () {\n            _this.CONSUME(categoryTokenMap.ShapeExpectingPredicate);\n            _this.SUBRULE(_this.shaclShape);\n        });\n        _this.shaclHasValueConstraint = _this.RULE('shaclHasValueConstraint', function () {\n            _this.CONSUME(_this.shaclTokenMap.SHACL_hasValue);\n            _this.SUBRULE(_this.shaclShapeOrLiteral);\n        });\n        _this.shaclShape = _this.RULE('shaclShape', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.iri); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.blankNodePropertyList); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.BlankNode); },\n                },\n            ]);\n        });\n        _this.shaclShapeOrLiteral = _this.RULE('shaclShapeOrLiteral', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.shaclShape); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.literal); },\n                },\n            ]);\n        });\n        _this.shaclIRIOrLiteral = _this.RULE('shaclIRIOrLiteral', function () {\n            _this.OR([\n                {\n                    ALT: function () { return _this.SUBRULE(_this.iri); },\n                },\n                {\n                    ALT: function () { return _this.SUBRULE(_this.literal); },\n                },\n            ]);\n        });\n        _this.shaclXsdBoolean = _this.RULE('shaclXsdBoolean', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_boolean);\n        });\n        _this.shaclXsdString = _this.RULE('shaclXsdString', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_string);\n        });\n        _this.shaclXsdInteger = _this.RULE('shaclXsdInteger', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_integer);\n        });\n        _this.shaclXsdDate = _this.RULE('shaclXsdDate', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_date);\n        });\n        _this.shaclXsdAnyURI = _this.RULE('shaclXsdAnyURI', function () {\n            _this.SUBRULE(_this.shaclStringWithDoubleCaret);\n            _this.CONSUME(_this.shaclTokenMap.SHACL_xsd_anyURI);\n        });\n        _this.shaclStringWithDoubleCaret = _this.RULE('shaclStringWithDoubleCaret', function () {\n            _this.SUBRULE(_this.String);\n            _this.CONSUME(turtleTokenMap.DoubleCaret);\n        });\n        _this.prefixes = prefixes;\n        _this.lexer = new Lexer(getShaclTokenTypes(prefixes));\n        _this.shaclTokenMap = getShaclTokenMap(prefixes);\n        Parser.performSelfAnalysis(_this);\n        return _this;\n    }\n    return ShaclParser;\n}(TurtleParser));\nexport { ShaclParser };\n","export * from './ShaclParser';\n// Convenience imports/exports that aren't core functionality:\n// NOTE: Tokens MUST be imported using CommonJS syntax; see here: https://github.com/SAP/chevrotain/issues/345\nexport var shaclTokens = require('./tokens');\n","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nexport var traverse = function (root, visit) {\n    _traverse(root, null, visit);\n};\nexport var unsafeTraverse = function (root, visit) {\n    _traverse(root, null, visit, false);\n};\nexport function isCstNode(object) {\n    return Boolean(object && 'name' in object);\n}\nvar TraverseContext = /** @class */ (function () {\n    function TraverseContext(_a) {\n        var node = _a.node, parentCtx = _a.parentCtx;\n        this.node = __assign({}, node);\n        this.parentCtx = __assign({}, parentCtx);\n    }\n    return TraverseContext;\n}());\nvar _traverse = function (root, ctx, visit, visitSafely) {\n    if (ctx === void 0) { ctx = new TraverseContext({ node: root }); }\n    if (visitSafely === void 0) { visitSafely = true; }\n    if (!isCstNode(root)) {\n        // must be a token\n        return visit(visitSafely ? __assign({}, ctx) : ctx);\n    }\n    // is a grammar rule node\n    var children = root.children;\n    Object.keys(children).forEach(function (key) {\n        var childType = children[key];\n        if (!childType.length) {\n            return;\n        }\n        childType.forEach(function (child) {\n            var childCtx = visitSafely\n                ? new TraverseContext({ node: child, parentCtx: ctx })\n                : { node: child, parentCtx: ctx };\n            var afterVisit = function (transformedCtx) {\n                var nextCtx = childCtx;\n                if (transformedCtx) {\n                    nextCtx = visitSafely\n                        ? new TraverseContext({\n                            node: transformedCtx.node,\n                            parentCtx: transformedCtx.parentCtx,\n                        })\n                        : {\n                            node: transformedCtx.node,\n                            parentCtx: transformedCtx.parentCtx,\n                        };\n                }\n                _traverse(child, nextCtx, visit, visitSafely);\n            };\n            visit(childCtx, afterVisit);\n        });\n    });\n};\n","/*\nCopyright 20122018 Ruben Verborgh\nWith modifications Copyright 2018 Stardog Union\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nvar escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\[uU]|\\\\(.)/g;\nvar escapeReplacements = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\"': '\"',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    f: '\\f',\n    b: '\\b',\n    _: '_',\n    '~': '~',\n    '.': '.',\n    '-': '-',\n    '!': '!',\n    $: '$',\n    '&': '&',\n    '(': '(',\n    ')': ')',\n    '*': '*',\n    '+': '+',\n    ',': ',',\n    ';': ';',\n    '=': '=',\n    '/': '/',\n    '?': '?',\n    '#': '#',\n    '@': '@',\n    '%': '%',\n};\nexport var unescapedStringLiteralQuote = /^\"([^\"\\\\\\r\\n]+)\"/; // non-empty string without escape sequences\nexport var unescapedStringLiteralSingleQuote = /^'([^'\\\\\\r\\n]+)'/;\nexport var stringLiteralQuote = /^\"((?:[^\"\\\\\\r\\n]|\\\\.)*)\"(?=[^\"])/;\nexport var stringLiteralSingleQuote = /^'((?:[^'\\\\\\r\\n]|\\\\.)*)'(?=[^'])/;\nexport var stringLiteralLongQuote = /^\"\"\"([^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*)\"\"\"/;\nexport var stringLiteralLongSingleQuote = /^'''([^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*)'''/;\nexport var illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\nexport var escapedIri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/;\nexport var unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/;\n// Handle special unescaping needs related to the IRIREF rule and others.\nexport var unescape = function (item) {\n    try {\n        return item.replace(escapeSequence, function (_, unicode4, unicode8, escapedChar) {\n            if (unicode4) {\n                return String.fromCharCode(parseInt(unicode4, 16));\n            }\n            else if (unicode8) {\n                var charCode = parseInt(unicode8, 16);\n                if (charCode <= 0xffff) {\n                    return String.fromCharCode(charCode);\n                }\n                return String.fromCharCode(0xd800 + (charCode -= 0x10000) / 0x400, 0xdc00 + (charCode & 0x3ff));\n            }\n            else {\n                var replacement = escapeReplacements[escapedChar];\n                if (!replacement) {\n                    throw new Error();\n                }\n                return replacement;\n            }\n        });\n    }\n    catch (error) {\n        return null;\n    }\n};\n","var sparqlTokenMap = require('../sparql/tokens').sparqlTokenMap;\nimport { createToken } from 'chevrotain';\nimport { regex } from '../helpers/regex';\nimport { EXPONENT, ECHAR, PLX, HEX, PN_CHARS_BASE, PN_CHARS_U, PN_CHARS, PN_PREFIX, PN_LOCAL, PN_LOCAL_ESC, } from '../helpers/matchers';\nimport { unescape, stringLiteralLongSingleQuote, stringLiteralLongQuote, unescapedStringLiteralQuote, stringLiteralQuote, unescapedStringLiteralSingleQuote, stringLiteralSingleQuote, unescapedIri, escapedIri, illegalIriChars, } from '../helpers/unescape';\nvar unicodeRegexp = /[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nexport var turtleTokenMap = {\n    Comment: createToken({\n        name: 'Comment',\n        pattern: /#[^\\n]*/,\n        group: 'comments',\n    }),\n    LBracket: sparqlTokenMap.LBracket,\n    RBracket: sparqlTokenMap.RBracket,\n    LCurly: sparqlTokenMap.LCurly,\n    RCurly: sparqlTokenMap.RCurly,\n    LParen: sparqlTokenMap.LParen,\n    RParen: sparqlTokenMap.RParen,\n    Period: sparqlTokenMap.Period,\n    WhiteSpace: sparqlTokenMap.WhiteSpace,\n    // 'true' and 'false' are case sensitive in Turtle but not in SPARQL\n    TRUE: createToken({\n        name: 'TRUE',\n        pattern: /true/,\n    }),\n    FALSE: createToken({\n        name: 'FALSE',\n        pattern: /false/,\n    }),\n    DoubleCaret: sparqlTokenMap.DoubleCaret,\n    LEmbed: sparqlTokenMap.LEmbed,\n    REmbed: sparqlTokenMap.REmbed,\n    Comma: sparqlTokenMap.Comma,\n    Semicolon: sparqlTokenMap.Semicolon,\n    A: sparqlTokenMap.A,\n    PREFIX: sparqlTokenMap.PREFIX,\n    BASE: sparqlTokenMap.BASE,\n    PNAME_NS: sparqlTokenMap.PNAME_NS,\n    PNAME_LN: sparqlTokenMap.PNAME_LN,\n    BLANK_NODE_LABEL: sparqlTokenMap.BLANK_NODE_LABEL,\n    TTL_BASE: createToken({ name: 'TTL_BASE', pattern: /@base/ }),\n    TTL_PREFIX: createToken({ name: 'TTL_PREFIX', pattern: /@prefix/ }),\n    LANGTAG: sparqlTokenMap.LANGTAG,\n    INTEGER: createToken({\n        name: 'INTEGER',\n        pattern: regex.and(regex.option(/[+-]/), /\\d+/),\n    }),\n    DECIMAL: createToken({\n        name: 'DECIMAL',\n        pattern: regex.and(regex.option(/[+-]/), /(\\d*\\.\\d+)/),\n    }),\n    DOUBLE: createToken({\n        name: 'DOUBLE',\n        pattern: regex.and(regex.option(/[+-]/), regex.or(regex.and(/\\d+\\.\\d*/, EXPONENT), regex.and(/\\.\\d+/, EXPONENT), regex.and(/\\d+/, EXPONENT))),\n    }),\n    EXPONENT: createToken({ name: 'EXPONENT', pattern: EXPONENT }),\n    ECHAR: createToken({ name: 'ECHAR', pattern: ECHAR }),\n    ANON: sparqlTokenMap.ANON,\n    PLX: createToken({ name: 'PLX', pattern: PLX }),\n    PERCENT: sparqlTokenMap.PERCENT,\n    HEX: createToken({ name: 'HEX', pattern: HEX }),\n    STRING_LITERAL_LONG_SINGLE_QUOTE: createToken({\n        name: 'STRING_LITERAL_LONG_SINGLE_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var match = stringLiteralLongSingleQuote.exec(text.slice(startOffset));\n            if (!match || unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: true,\n    }),\n    STRING_LITERAL_LONG_QUOTE: createToken({\n        name: 'STRING_LITERAL_LONG_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var match = stringLiteralLongQuote.exec(text.slice(startOffset));\n            if (!match || unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: true,\n    }),\n    STRING_LITERAL_QUOTE: createToken({\n        name: 'STRING_LITERAL_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedStringLiteralQuote.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = stringLiteralQuote.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            if (unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    STRING_LITERAL_SINGLE_QUOTE: createToken({\n        name: 'STRING_LITERAL_SINGLE_QUOTE',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedStringLiteralSingleQuote.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = stringLiteralSingleQuote.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            if (unescape(match[1]) === null) {\n                // Bad characters\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    UCHAR: createToken({\n        name: 'UCHAR',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            return unicodeRegexp.exec(text.slice(startOffset));\n        },\n        line_breaks: false,\n    }),\n    IRIREF: createToken({\n        name: 'IRIREF',\n        pattern: function (text, startOffset) {\n            if (startOffset === void 0) { startOffset = 0; }\n            var textToMatch = text.slice(startOffset);\n            var match = unescapedIri.exec(textToMatch);\n            if (match) {\n                return match;\n            }\n            match = escapedIri.exec(textToMatch);\n            if (!match) {\n                return null;\n            }\n            var value = unescape(match[1]);\n            if (value === null || illegalIriChars.test(value)) {\n                return null;\n            }\n            return match;\n        },\n        line_breaks: false,\n    }),\n    PN_CHARS_BASE: createToken({ name: 'PN_CHARS_BASE', pattern: PN_CHARS_BASE }),\n    PN_CHARS_U: createToken({ name: 'PN_CHARS_U', pattern: PN_CHARS_U }),\n    PN_CHARS: createToken({ name: 'PN_CHARS', pattern: PN_CHARS }),\n    PN_PREFIX: createToken({ name: 'PN_PREFIX', pattern: PN_PREFIX }),\n    PN_LOCAL: createToken({ name: 'PN_LOCAL', pattern: PN_LOCAL }),\n    PN_LOCAL_ESC: createToken({ name: 'PN_LOCAL_ESC', pattern: PN_LOCAL_ESC }),\n    UNKNOWN: sparqlTokenMap.UNKNOWN,\n};\nexport var turtleTokenTypes = [\n    turtleTokenMap.Comment,\n    sparqlTokenMap.ANON,\n    sparqlTokenMap.LBracket,\n    sparqlTokenMap.RBracket,\n    sparqlTokenMap.LCurly,\n    sparqlTokenMap.RCurly,\n    sparqlTokenMap.LParen,\n    sparqlTokenMap.RParen,\n    sparqlTokenMap.WhiteSpace,\n    turtleTokenMap.TRUE,\n    turtleTokenMap.FALSE,\n    sparqlTokenMap.Comma,\n    sparqlTokenMap.Semicolon,\n    sparqlTokenMap.PNAME_NS,\n    sparqlTokenMap.A,\n    sparqlTokenMap.PREFIX,\n    sparqlTokenMap.BASE,\n    sparqlTokenMap.PNAME_LN,\n    sparqlTokenMap.BLANK_NODE_LABEL,\n    turtleTokenMap.TTL_BASE,\n    turtleTokenMap.TTL_PREFIX,\n    sparqlTokenMap.LANGTAG,\n    turtleTokenMap.DOUBLE,\n    turtleTokenMap.DECIMAL,\n    sparqlTokenMap.Period,\n    sparqlTokenMap.DoubleCaret,\n    turtleTokenMap.LEmbed,\n    turtleTokenMap.REmbed,\n    turtleTokenMap.IRIREF,\n    turtleTokenMap.STRING_LITERAL_LONG_SINGLE_QUOTE,\n    turtleTokenMap.STRING_LITERAL_LONG_QUOTE,\n    turtleTokenMap.STRING_LITERAL_QUOTE,\n    turtleTokenMap.STRING_LITERAL_SINGLE_QUOTE,\n    turtleTokenMap.INTEGER,\n    turtleTokenMap.EXPONENT,\n    turtleTokenMap.PLX,\n    sparqlTokenMap.PERCENT,\n    turtleTokenMap.HEX,\n    turtleTokenMap.PN_CHARS_BASE,\n    turtleTokenMap.PN_CHARS_U,\n    turtleTokenMap.PN_CHARS,\n    turtleTokenMap.PN_PREFIX,\n    turtleTokenMap.PN_LOCAL,\n    turtleTokenMap.PN_LOCAL_ESC,\n    turtleTokenMap.ECHAR,\n    turtleTokenMap.UCHAR,\n    turtleTokenMap.UNKNOWN,\n];\n"],"sourceRoot":""}