import { TurtleParser } from '../turtle/TurtleParser';
import { Lexer, IToken, IRecognitionException, IParserConfig } from 'chevrotain';
export declare class ShaclParser extends TurtleParser {
    protected lexer: Lexer;
    private shaclTokenMap;
    tokenize: (document: string) => IToken[];
    parse: (document: string) => {
        errors: IRecognitionException[];
        semanticErrors: IRecognitionException[];
        cst: any;
    };
    constructor(config?: Partial<IParserConfig>, prefixes?: {
        shacl: string;
        xsd: string;
    });
    predicateObjectList: (idxInCallingRule?: number, ...args: any[]) => void;
    shaclRulePredicateObjectList: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclPredicateIRI: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclNodeKind: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclTargetNode: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclVerbShape: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclShapeType: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclPropertyPath: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclPropertyPathPath: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclSequencePath: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclAlternativePath: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclInversePath: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclZeroOrMorePath: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclOneOrMorePath: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclZeroOrOnePath: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclLiteralConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclIntConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclStringConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclStringLiteralQuoteConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclLangStringConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclBooleanConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclAnyLiteralConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclListTakingConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclLanguageInConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclStringCollection: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclShapeListTakingConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclShapeCollection: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclIRIListTakingConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclIRICollection: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclShapeOrLiteralListTakingConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclShapeOrLiteralCollection: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclShapeExpectingConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclHasValueConstraint: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclShape: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclShapeOrLiteral: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclIRIOrLiteral: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclXsdBoolean: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclXsdString: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclXsdInteger: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclXsdDate: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclXsdAnyURI: (idxInCallingRule?: number, ...args: any[]) => any;
    shaclStringWithDoubleCaret: (idxInCallingRule?: number, ...args: any[]) => any;
}
