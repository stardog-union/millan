// @ts-ignore: import types for declarations
import { createToken, Lexer, TokenType } from 'chevrotain';
import { terminals } from './terminals';
import { keywords } from './keywords';

export const sparqlTokenMap = {
  IRIREF: terminals.IRIREF,
  LANGTAG: terminals.LANGTAG,
  INTEGER: terminals.INTEGER,
  DECIMAL: terminals.DECIMAL,
  DOUBLE: terminals.DOUBLE,
  INTEGER_POSITIVE: terminals.INTEGER_POSITIVE,
  DECIMAL_POSITIVE: terminals.DECIMAL_POSITIVE,
  DOUBLE_POSITIVE: terminals.DOUBLE_POSITIVE,
  INTEGER_NEGATIVE: terminals.INTEGER_NEGATIVE,
  DECIMAL_NEGATIVE: terminals.DECIMAL_NEGATIVE,
  DOUBLE_NEGATIVE: terminals.DOUBLE_NEGATIVE,
  STRING_LITERAL1: terminals.STRING_LITERAL1,
  STRING_LITERAL2: terminals.STRING_LITERAL2,
  STRING_LITERAL_LONG1: terminals.STRING_LITERAL_LONG1,
  STRING_LITERAL_LONG2: terminals.STRING_LITERAL_LONG2,
  NIL: terminals.NIL,
  ANON: terminals.ANON,
  PNAME_NS: terminals.PNAME_NS,
  PNAME_LN: terminals.PNAME_LN,
  BLANK_NODE_LABEL: terminals.BLANK_NODE_LABEL,
  VAR1: terminals.VAR1,
  VAR2: terminals.VAR2,
  PERCENT: terminals.PERCENT,

  Comment: createToken({
    name: 'Comment',
    pattern: /#[^\n]*/,
    group: 'comments',
  }),
  LCurly: createToken({ name: 'LCurly', pattern: '{' }),
  RCurly: createToken({ name: 'RCurly', pattern: '}' }),
  LParen: createToken({ name: 'LParen', pattern: '(' }),
  RParen: createToken({ name: 'RParen', pattern: ')' }),
  WhiteSpace: createToken({
    name: 'WhiteSpace',
    pattern: /\s+/,
    group: Lexer.SKIPPED,
    line_breaks: true,
  }),

  Star: createToken({
    name: 'Star',
    pattern: '*',
  }),

  Unknown: createToken({
    name: 'Unknown',
    // Unknown comes _before_ `A` in the token ordering because we need it to
    // match custom/XPath functions like `atan`, etc. But we also need it to
    // _not_ capture `A` tokens. This pattern catches anything that is either
    // (1) 'a' followed by non-whitespace (up to the next non-word character) or
    // (2) not 'a' or whitespace (up to the next non-word character).
    pattern: /(?:a\S|[^a\s])\w*/i,
  }),

  Period: createToken({
    name: 'Period',
    pattern: '.',
  }),

  QuestionMark: createToken({
    name: 'QuestionMark',
    pattern: '?',
  }),

  Plus: createToken({
    name: 'Plus',
    pattern: '+',
  }),

  Minus: createToken({
    name: 'Minus',
    pattern: '-',
  }),

  LBracket: createToken({
    name: 'LBracket',
    pattern: '[',
  }),

  RBracket: createToken({
    name: 'RBracket',
    pattern: ']',
  }),

  Semicolon: createToken({
    name: 'Semicolon',
    pattern: ';',
  }),

  Comma: createToken({
    name: 'Comma',
    pattern: ',',
  }),

  Pipe: createToken({
    name: 'Pipe',
    pattern: '|',
  }),

  ForwardSlash: createToken({
    name: 'ForwardSlash',
    pattern: '/',
  }),

  Caret: createToken({
    name: 'Caret',
    pattern: '^',
  }),

  DoubleCaret: createToken({
    name: 'DoubleCaret',
    pattern: '^^',
  }),

  Bang: createToken({
    name: 'Bang',
    pattern: '!',
  }),

  LogicalOr: createToken({
    name: 'LogicalOr',
    pattern: '||',
  }),

  LogicalAnd: createToken({
    name: 'LogicalAnd',
    pattern: '&&',
  }),

  Equals: createToken({
    name: 'Equals',
    pattern: '=',
  }),

  NotEquals: createToken({
    name: 'NotEquals',
    pattern: '!=',
  }),

  LessThan: createToken({
    name: 'LessThan',
    pattern: '<',
  }),

  GreaterThan: createToken({
    name: 'GreaterThan',
    pattern: '>',
  }),

  LessThanEquals: createToken({
    name: 'LessThanEquals',
    pattern: '<=',
  }),

  GreaterThanEquals: createToken({
    name: 'GreaterThanEquals',
    pattern: '>=',
  }),

  LEmbed: createToken({
    name: 'LEmbed',
    pattern: '<<',
  }),

  REmbed: createToken({
    name: 'REmbed',
    pattern: '>>',
  }),

  SELECT: keywords.SELECT,
  CONSTRUCT: keywords.CONSTRUCT,
  DISTINCT: keywords.DISTINCT,
  START: keywords.START,
  END: keywords.END,
  VIA: keywords.VIA,
  CYCLIC: keywords.CYCLIC,
  PATHS_SHORTEST: keywords.PATHS_SHORTEST,
  PATHS_ALL: keywords.PATHS_ALL,
  PATHS: keywords.PATHS,
  AS: keywords.AS,
  WHERE: keywords.WHERE,
  A: keywords.A,
  GROUP_BY: keywords.GROUP_BY,
  ORDER_BY: keywords.ORDER_BY,
  BY: keywords.BY,
  BASE: keywords.BASE,
  PREFIX: keywords.PREFIX,
  DESCRIBE: keywords.DESCRIBE,
  ASK: keywords.ASK,
  FROM: keywords.FROM,
  REDUCED: keywords.REDUCED,
  NAMED: keywords.NAMED,
  HAVING: keywords.HAVING,
  ASC: keywords.ASC,
  DESC: keywords.DESC,
  OFFSET: keywords.OFFSET,
  LIMIT: keywords.LIMIT,
  VALUES: keywords.VALUES,
  LOAD: keywords.LOAD,
  SILENT: keywords.SILENT,
  INTO: keywords.INTO,
  CLEAR: keywords.CLEAR,
  DROP: keywords.DROP,
  CREATE: keywords.CREATE,
  ADD: keywords.ADD,
  TO: keywords.TO,
  MOVE: keywords.MOVE,
  COPY: keywords.COPY,
  INSERT_DATA: keywords.INSERT_DATA,
  DELETE_DATA: keywords.DELETE_DATA,
  DELETE_WHERE: keywords.DELETE_WHERE,
  WITH: keywords.WITH,
  DELETE: keywords.DELETE,
  INSERT: keywords.INSERT,
  USING: keywords.USING,
  DEFAULT: keywords.DEFAULT,
  GRAPH: keywords.GRAPH,
  ALL: keywords.ALL,
  OPTIONAL: keywords.OPTIONAL,
  SERVICE: keywords.SERVICE,
  BIND: keywords.BIND,
  UNNEST: keywords.UNNEST,
  UNDEF: keywords.UNDEF,
  MINUS: keywords.MINUS,
  UNION: keywords.UNION,
  FILTER: keywords.FILTER,
  STR: keywords.STR,
  LANG: keywords.LANG,
  LANGMATCHES: keywords.LANGMATCHES,
  DATATYPE: keywords.DATATYPE,
  BOUND: keywords.BOUND,
  IRI: keywords.IRI,
  URI: keywords.URI,
  BNODE: keywords.BNODE,
  RAND: keywords.RAND,
  ABS: keywords.ABS,
  CEIL: keywords.CEIL,
  FLOOR: keywords.FLOOR,
  ROUND: keywords.ROUND,
  CONCAT: keywords.CONCAT,
  STRLEN: keywords.STRLEN,
  UCASE: keywords.UCASE,
  LCASE: keywords.LCASE,
  ENCODE_FOR_URI: keywords.ENCODE_FOR_URI,
  CONTAINS: keywords.CONTAINS,
  STRSTARTS: keywords.STRSTARTS,
  STRENDS: keywords.STRENDS,
  STRBEFORE: keywords.STRBEFORE,
  STRAFTER: keywords.STRAFTER,
  YEAR: keywords.YEAR,
  MONTH: keywords.MONTH,
  DAY: keywords.DAY,
  HOURS: keywords.HOURS,
  MINUTES: keywords.MINUTES,
  SECONDS: keywords.SECONDS,
  TIMEZONE: keywords.TIMEZONE,
  TZ: keywords.TZ,
  NOW: keywords.NOW,
  UUID: keywords.UUID,
  STRUUID: keywords.STRUUID,
  MD5: keywords.MD5,
  SHA1: keywords.SHA1,
  SHA256: keywords.SHA256,
  SHA384: keywords.SHA384,
  SHA512: keywords.SHA512,
  COALESCE: keywords.COALESCE,
  IF: keywords.IF,
  STRLANG: keywords.STRLANG,
  STRDT: keywords.STRDT,
  sameTerm: keywords.sameTerm,
  isIRI: keywords.isIRI,
  isURI: keywords.isURI,
  isBLANK: keywords.isBLANK,
  isLITERAL: keywords.isLITERAL,
  isNUMERIC: keywords.isNUMERIC,
  REGEX: keywords.REGEX,
  SUBSTR: keywords.SUBSTR,
  REPLACE: keywords.REPLACE,
  EXISTS: keywords.EXISTS,
  NOT_EXISTS: keywords.NOT_EXISTS,
  COUNT: keywords.COUNT,
  SUM: keywords.SUM,
  MIN: keywords.MIN,
  AVG: keywords.AVG,
  SAMPLE: keywords.SAMPLE,
  GROUP_CONCAT: keywords.GROUP_CONCAT,
  SEPARATOR: keywords.SEPARATOR,
  TRUE: keywords.TRUE,
  FALSE: keywords.FALSE,
  IN: keywords.IN,
  NOT_IN: keywords.NOT_IN,
  MAX_LENGTH: keywords.MAX_LENGTH,
  MAX: keywords.MAX,
};

export const baseTokens = [
  sparqlTokenMap.NIL,
  sparqlTokenMap.ANON,
  sparqlTokenMap.LCurly,
  sparqlTokenMap.RCurly,
  sparqlTokenMap.LParen,
  sparqlTokenMap.RParen,
  sparqlTokenMap.WhiteSpace,
  sparqlTokenMap.IRIREF,
  sparqlTokenMap.LANGTAG,
  sparqlTokenMap.DOUBLE,
  sparqlTokenMap.DECIMAL,
  sparqlTokenMap.INTEGER,
  sparqlTokenMap.DOUBLE_POSITIVE,
  sparqlTokenMap.DECIMAL_POSITIVE,
  sparqlTokenMap.INTEGER_POSITIVE,
  sparqlTokenMap.DOUBLE_NEGATIVE,
  sparqlTokenMap.DECIMAL_NEGATIVE,
  sparqlTokenMap.INTEGER_NEGATIVE,
  sparqlTokenMap.STRING_LITERAL1,
  sparqlTokenMap.STRING_LITERAL2,
  sparqlTokenMap.STRING_LITERAL_LONG1,
  sparqlTokenMap.STRING_LITERAL_LONG2,
  sparqlTokenMap.PNAME_NS,
  sparqlTokenMap.PNAME_LN,
  sparqlTokenMap.BLANK_NODE_LABEL,
  sparqlTokenMap.VAR1,
  sparqlTokenMap.VAR2,
  sparqlTokenMap.Comment,
  sparqlTokenMap.SELECT,
  sparqlTokenMap.CONSTRUCT,
  sparqlTokenMap.DISTINCT,
  sparqlTokenMap.Star,
  sparqlTokenMap.WHERE,
  sparqlTokenMap.GROUP_BY,
  sparqlTokenMap.ORDER_BY,
  sparqlTokenMap.BY,
  sparqlTokenMap.Period,
  sparqlTokenMap.QuestionMark,
  sparqlTokenMap.Plus,
  sparqlTokenMap.Minus,
  sparqlTokenMap.LBracket,
  sparqlTokenMap.RBracket,
  sparqlTokenMap.PERCENT,
  sparqlTokenMap.BASE,
  sparqlTokenMap.PREFIX,
  sparqlTokenMap.DESCRIBE,
  sparqlTokenMap.ASK,
  sparqlTokenMap.FROM,
  sparqlTokenMap.REDUCED,
  sparqlTokenMap.NAMED,
  sparqlTokenMap.HAVING,
  sparqlTokenMap.ASC,
  sparqlTokenMap.DESC,
  sparqlTokenMap.OFFSET,
  sparqlTokenMap.LIMIT,
  sparqlTokenMap.VALUES,
  sparqlTokenMap.LOAD,
  sparqlTokenMap.SILENT,
  sparqlTokenMap.INTO,
  sparqlTokenMap.AS,
  sparqlTokenMap.CLEAR,
  sparqlTokenMap.DROP,
  sparqlTokenMap.CREATE,
  sparqlTokenMap.ADD,
  sparqlTokenMap.TO,
  sparqlTokenMap.MOVE,
  sparqlTokenMap.COPY,
  sparqlTokenMap.INSERT_DATA,
  sparqlTokenMap.DELETE_DATA,
  sparqlTokenMap.DELETE_WHERE,
  sparqlTokenMap.WITH,
  sparqlTokenMap.DELETE,
  sparqlTokenMap.INSERT,
  sparqlTokenMap.USING,
  sparqlTokenMap.DEFAULT,
  sparqlTokenMap.GRAPH,
  sparqlTokenMap.ALL,
  sparqlTokenMap.OPTIONAL,
  sparqlTokenMap.SERVICE,
  sparqlTokenMap.BIND,
  sparqlTokenMap.UNDEF,
  sparqlTokenMap.MINUS,
  sparqlTokenMap.UNION,
  sparqlTokenMap.FILTER,
  sparqlTokenMap.LANGMATCHES,
  sparqlTokenMap.LANG,
  sparqlTokenMap.DATATYPE,
  sparqlTokenMap.BOUND,
  sparqlTokenMap.IRI,
  sparqlTokenMap.URI,
  sparqlTokenMap.BNODE,
  sparqlTokenMap.RAND,
  sparqlTokenMap.ABS,
  sparqlTokenMap.CEIL,
  sparqlTokenMap.FLOOR,
  sparqlTokenMap.ROUND,
  sparqlTokenMap.CONCAT,
  sparqlTokenMap.STRLEN,
  sparqlTokenMap.UCASE,
  sparqlTokenMap.LCASE,
  sparqlTokenMap.ENCODE_FOR_URI,
  sparqlTokenMap.CONTAINS,
  sparqlTokenMap.STRSTARTS,
  sparqlTokenMap.STRENDS,
  sparqlTokenMap.STRBEFORE,
  sparqlTokenMap.STRAFTER,
  sparqlTokenMap.YEAR,
  sparqlTokenMap.MONTH,
  sparqlTokenMap.DAY,
  sparqlTokenMap.HOURS,
  sparqlTokenMap.MINUTES,
  sparqlTokenMap.SECONDS,
  sparqlTokenMap.TIMEZONE,
  sparqlTokenMap.TZ,
  sparqlTokenMap.NOW,
  sparqlTokenMap.UUID,
  sparqlTokenMap.STRUUID,
  sparqlTokenMap.MD5,
  sparqlTokenMap.SHA1,
  sparqlTokenMap.SHA256,
  sparqlTokenMap.SHA384,
  sparqlTokenMap.SHA512,
  sparqlTokenMap.COALESCE,
  sparqlTokenMap.IF,
  sparqlTokenMap.STRLANG,
  sparqlTokenMap.STRDT,
  sparqlTokenMap.STR,
  sparqlTokenMap.sameTerm,
  sparqlTokenMap.isIRI,
  sparqlTokenMap.isURI,
  sparqlTokenMap.isBLANK,
  sparqlTokenMap.isLITERAL,
  sparqlTokenMap.isNUMERIC,
  sparqlTokenMap.REGEX,
  sparqlTokenMap.SUBSTR,
  sparqlTokenMap.REPLACE,
  sparqlTokenMap.EXISTS,
  sparqlTokenMap.NOT_EXISTS,
  sparqlTokenMap.COUNT,
  sparqlTokenMap.SUM,
  sparqlTokenMap.MIN,
  sparqlTokenMap.MAX_LENGTH,
  sparqlTokenMap.MAX,
  sparqlTokenMap.AVG,
  sparqlTokenMap.SAMPLE,
  sparqlTokenMap.GROUP_CONCAT,
  sparqlTokenMap.SEPARATOR,
  sparqlTokenMap.TRUE,
  sparqlTokenMap.FALSE,
  sparqlTokenMap.Semicolon,
  sparqlTokenMap.Comma,
  sparqlTokenMap.ForwardSlash,
  sparqlTokenMap.DoubleCaret,
  sparqlTokenMap.Caret,
  sparqlTokenMap.LogicalOr,
  sparqlTokenMap.Pipe,
  sparqlTokenMap.LogicalAnd,
  sparqlTokenMap.NotEquals,
  sparqlTokenMap.Bang,
  sparqlTokenMap.Equals,
  sparqlTokenMap.LessThanEquals,
  sparqlTokenMap.GreaterThanEquals,
  sparqlTokenMap.LEmbed,
  sparqlTokenMap.REmbed,
  sparqlTokenMap.LessThan,
  sparqlTokenMap.GreaterThan,
  sparqlTokenMap.IN,
  sparqlTokenMap.NOT_IN,
  sparqlTokenMap.Unknown,
  sparqlTokenMap.A,
];

export const pathsTokens = [
  sparqlTokenMap.START,
  sparqlTokenMap.END,
  sparqlTokenMap.VIA,
  sparqlTokenMap.CYCLIC,
  sparqlTokenMap.PATHS_SHORTEST,
  sparqlTokenMap.PATHS_ALL,
  sparqlTokenMap.PATHS,
];

export const nonStandardTokens = [...pathsTokens, sparqlTokenMap.UNNEST];

const indexOfSelect = baseTokens.indexOf(sparqlTokenMap.SELECT);
export const stardogSparqlTokens = [
  ...baseTokens.slice(0, indexOfSelect),
  ...nonStandardTokens,
  ...baseTokens.slice(indexOfSelect),
];

export const sparqlTokenTypes = [...baseTokens, ...nonStandardTokens];
